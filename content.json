[{"title":"在配置不同的状态后端时，到底对 flink 任务有什么影响","date":"2022-11-15T06:25:58.000Z","path":"2022/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/03_state/04_当我们在配置不同的状态后端时，到底影响了什么东西/","text":"1.大家首先要知道的一些背景状态：状态就是用户在程序中使用的数据结构。比如 flink 中的 MapState，ValueState，ListState。在一个 flink 任务中，不管我们使用了多少状态，这些状态只会分为 operator state，keyed state 两类状态。 状态管理：为了防止 long run 的 flink 任务挂了导致状态丢失，产生数据质量问题，flink 提供了状态管理（Checkpoint，Savepoint）的能力把我们使用的状态给管理起来，定时的保存到远程。然后可以在 flink 任务 failover 时，从远程把状态数据恢复到 flink 任务中，保障数据质量。 状态后端：状态后端就是决定了以什么样数据结构，什么样的存储方式去存储和管理我们的状态。flink 目前官方提供了 memory、filesystem，rocksdb 三种状态后端来存储我们的状态。 2.在配置不同的状态后端时，到底对 flink 任务有什么影响其实所有的内容都浓缩到了这样图中： 横向（行）来看，分为 Operator state-backend、Keyed state-backend 来管理一个 flink 任务中的所有状态（operator state，keyed state） 纵向（列）来看，用户可以通过配置 memory，filesystem，rocksdb，在 flink 任务中生成 MemoryStateBackend，FsStateBackend，RocksdbStateBackend，其声明了整个任务的状态管理后端类型 每个格子中的内容就是用户在配置 xx 状态后端（列）时，给用户使用的状态（行）生成的状态后端实例，生成的这个实例就是用于管理用户使用的状态的。 那么可以得到的结论就是： flink 任务中的 operator state。无论用户配置哪种状态后端（无论是 memory，filesystem，rocksdb），都是使用 DefaultOperatorStateBackend 来管理的，状态数据都存储在内存中。 flink 任务中的 keyed state，会有不同。用户在配置 rocksdb 时，会使用 RocksdbKeyedStateBackend 去管理状态；用户在配置 memory，filesystem 时，会使用 HeapKeyedStateBackend 去管理状态。 那么也就是说，你配置的 rocksdb 只会影响 keyed state 存储的方式和地方，operator state 不会受到影响。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十九）：Table 与 DataStream 的转转转","date":"2021-11-16T08:26:59.000Z","path":"2021/11/16/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/21_flinksql知其所以然（十九）：flinksqltable转换为datastream/","text":"看了那么多的技术文，你能明白作者想让你在读完文章后学到什么吗？ 大数据羊说的文章会让你明白 博主会阐明博主期望本文能给小伙伴们带来什么帮助，让小伙伴萌能直观明白博主的心思 博主会以实际的应用场景和案例入手，不只是知识点的简单堆砌 博主会把重要的知识点的原理进行剖析，让小伙伴萌做到深入浅出 1.序篇源码公众号后台回复1.13.2 table datastream获取。 废话不多说，咱们先直接上本文的目录和结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 背景及应用场景介绍：博主期望你能了解到，Flink 支持了 SQL 和 Table API 中的 Table 与 DataStream 互转的接口。通过这种互转的方式，我们就可以将一些自定义的数据源（DataStream）创建为 SQL 表，也可以将 SQL 执行结果转换为 DataStream 然后后续去完成一些在 SQL 中实现不了的复杂操作。肥肠的方便。 目前只有流任务支持互转，批任务不支持：在 1.13 版本中，由于流和批的 env 接口不一样，流任务为 StreamTableEnvironment，批任务为 TableEnvironment，目前只有 StreamTableEnvironment 支持了互转的接口，TableEnvironment 没有这样的接口，因此目前流任务支持互转，批任务不支持。但是 1.14 版本中流批任务的 env 都统一到了 StreamTableEnvironment 中，流批任务中就都可以进行互转了。 Retract 语义 SQL 转 DataStream 需要重点注意：Append 语义的 SQL 转为 DataStream 使用的 API 为 StreamTableEnvironment::toDataStream，Retract 语义的 SQL 转为 DataStream 使用的 API 为 StreamTableEnvironment::toRetractStream，两个接口不一样，小伙伴萌一定要特别注意。 2.背景及应用场景介绍相信大家看到本文的标题时，会比较好奇，要写 SQL 就纯 SQL 呗，要写 DataStream 就纯 DataStream 呗，为啥还要把这两个接口做集成呢？ 博主举一个案例：在拼多多发优惠券的场景下，为了控制成本，希望能在每日优惠券发放金额加和超过 1w 时，及时报警出来，控制预算。 优惠券表的发放数据： id（id） time（时间） money（金额） 1 2021-11-01 00:01:03 10 2 2021-11-01 00:03:00 20 3 2021-11-01 00:05:00 30 4 2021-11-01 00:06:00 40 5 2021-11-01 00:07:00 50 最终期望的结果是：每天的 money 之和超过 1w 的时候，报警报警报警！！！ 那么针对上述场景，有两种对应的解决方案： 方案 1：可想而知，DataStream 是必然能够解决我们的问题的。 方案 2：DataStream 开发效率不高，可以使用 SQL 计算优惠券发放的结果，但是 SQL 无法做到报警。所以可以将 SQL 的查询的结果（即 Table）转为 DataStream，然后在 DataStream 后自定义报警逻辑的算子，超过阈值进行报警。 本节就介绍方案 2 的实现思路。 注意： 当然还有一些其他的比如模式识别监控异常然后报警的场景使用 DataStream 去实现就更加复杂了，所以我们也可以使用类似的思路，先 SQL 实现业务逻辑，然后接一个 DataStream 算子实现报警逻辑。 3.Table 与 DataStream API 的转换具体实现3.1.先看一个官网的简单案例官网的案例主要是让大家看看要做到 Table 与 DataStream API 的转换会涉及到使用哪些接口。 1234567891011121314151617181920212223242526272829303132import org.apache.flink.streaming.api.datastream.DataStream;import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;import org.apache.flink.table.api.Table;import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;import org.apache.flink.types.Row;StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);DataStream&lt;String&gt; dataStream = env.fromElements(&quot;Alice&quot;, &quot;Bob&quot;, &quot;John&quot;);// 1. 使用 StreamTableEnvironment::fromDataStream API 将 DataStream 转为 TableTable inputTable = tableEnv.fromDataStream(dataStream);// 将 Table 注册为一个临时表tableEnv.createTemporaryView(&quot;InputTable&quot;, inputTable);// 然后就可以在这个临时表上做一些自定义的查询了Table resultTable = tableEnv.sqlQuery(&quot;SELECT UPPER(f0) FROM InputTable&quot;);// 2. 也可以使用 StreamTableEnvironment::toDataStream 将 Table 转为 DataStream// 注意：这里只能转为 DataStream&lt;Row&gt;，其中的数据类型只能为 RowDataStream&lt;Row&gt; resultStream = tableEnv.toDataStream(resultTable);// 将 DataStream 结果打印到控制台resultStream.print();env.execute();// prints:// +I[Alice]// +I[Bob]// +I[John] 可以看到重点的接口就是： StreamTableEnvironment::toDataStream：将 Table 转为 DataStream StreamTableEnvironment::fromDataStream：将 DataStream 转为 Table 3.2.实现第 2 节中的逻辑我们使用上面介绍的两个接口对优惠券发放金额预警的案例做一个实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Slf4jpublic class AlertExample &#123; public static void main(String[] args) throws Exception &#123; FlinkEnv flinkEnv = FlinkEnvUtils.getStreamTableEnv(args); String createTableSql = &quot;CREATE TABLE source_table (\\n&quot; + &quot; id BIGINT,\\n&quot; + &quot; money BIGINT,\\n&quot; + &quot; row_time AS cast(CURRENT_TIMESTAMP as timestamp_LTZ(3)),\\n&quot; + &quot; WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;datagen&#x27;,\\n&quot; + &quot; &#x27;rows-per-second&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.id.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.id.max&#x27; = &#x27;100000&#x27;,\\n&quot; + &quot; &#x27;fields.money.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.money.max&#x27; = &#x27;100000&#x27;\\n&quot; + &quot;)\\n&quot;; String querySql = &quot;SELECT UNIX_TIMESTAMP(CAST(window_end AS STRING)) * 1000 as window_end, \\n&quot; + &quot; window_start, \\n&quot; + &quot; sum(money) as sum_money,\\n&quot; + &quot; count(distinct id) as count_distinct_id\\n&quot; + &quot;FROM TABLE(CUMULATE(\\n&quot; + &quot; TABLE source_table\\n&quot; + &quot; , DESCRIPTOR(row_time)\\n&quot; + &quot; , INTERVAL &#x27;5&#x27; SECOND\\n&quot; + &quot; , INTERVAL &#x27;1&#x27; DAY))\\n&quot; + &quot;GROUP BY window_start, \\n&quot; + &quot; window_end&quot;; // 1. 创建数据源表，即优惠券发放明细数据 flinkEnv.streamTEnv().executeSql(createTableSql); // 2. 执行 query 查询，计算每日发放金额 Table resultTable = flinkEnv.streamTEnv().sqlQuery(querySql); // 3. 报警逻辑（toDataStream 返回 Row 类型），如果 sum_money 超过 1w，报警 flinkEnv.streamTEnv() .toDataStream(resultTable, Row.class) .flatMap(new FlatMapFunction&lt;Row, Object&gt;() &#123; @Override public void flatMap(Row value, Collector&lt;Object&gt; out) throws Exception &#123; long l = Long.parseLong(String.valueOf(value.getField(&quot;sum_money&quot;))); if (l &gt; 10000L) &#123; log.info(&quot;报警，超过 1w&quot;); &#125; &#125; &#125;); flinkEnv.env().execute(); &#125;&#125; 执行效果如下： 3.3.Table 和 DataStream 转换注意事项3.3.1.目前只支持流任务互转（1.13）目前在 1.13 版本中，Flink 对于 Table 和 DataStream 的转化是有一些限制的： 目前流任务使用的 env 为 StreamTableEnvironment，批任务为 TableEnvironment，而 Table 和 DataStream 之间的转换目前只有 StreamTableEnvironment 的接口支持。 所以其实小伙伴萌可以理解为只有流任务才支持 Table 和 DataStream 之间的转换，批任务是不支持的（虽然可以使用流模式处理有界流（批数据），但效率较低，这种骚操作不建议大家搞）。 那什么时候才能支持批任务的 Table 和 DataStream 之间的转换呢？ 1.14 版本支持。1.14 版本中，流和批的都统一到了 StreamTableEnvironment 中，因此就可以做 Table 和 DataStream 的互相转换了。 3.3.2.Retract 语义 SQL 转 DataStream 注意事项Retract 语义的 SQL 使用 toDataStream 转换会报错不支持。具体报错截图如下。意思是不支持 update 类型的结果数据。 如果要把 Retract 语义的 SQL 转为 DataStream，我们需要使用 toRetractStream。如下案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Slf4jpublic class AlertExampleRetract &#123; public static void main(String[] args) throws Exception &#123; FlinkEnv flinkEnv &#x3D; FlinkEnvUtils.getStreamTableEnv(args); String createTableSql &#x3D; &quot;CREATE TABLE source_table (\\n&quot; + &quot; id BIGINT,\\n&quot; + &quot; money BIGINT,\\n&quot; + &quot; &#96;time&#96; as cast(CURRENT_TIMESTAMP as bigint) * 1000\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#39;connector&#39; &#x3D; &#39;datagen&#39;,\\n&quot; + &quot; &#39;rows-per-second&#39; &#x3D; &#39;1&#39;,\\n&quot; + &quot; &#39;fields.id.min&#39; &#x3D; &#39;1&#39;,\\n&quot; + &quot; &#39;fields.id.max&#39; &#x3D; &#39;100000&#39;,\\n&quot; + &quot; &#39;fields.money.min&#39; &#x3D; &#39;1&#39;,\\n&quot; + &quot; &#39;fields.money.max&#39; &#x3D; &#39;100000&#39;\\n&quot; + &quot;)\\n&quot;; String querySql &#x3D; &quot;SELECT max(&#96;time&#96;), \\n&quot; + &quot; sum(money) as sum_money\\n&quot; + &quot;FROM source_table\\n&quot; + &quot;GROUP BY (&#96;time&#96; + 8 * 3600 * 1000) &#x2F; (24 * 3600 * 1000)&quot;; &#x2F;&#x2F; 1. 创建数据源表，即优惠券发放明细数据 flinkEnv.streamTEnv().executeSql(createTableSql); &#x2F;&#x2F; 2. 执行 query 查询，计算每日发放金额 Table resultTable &#x3D; flinkEnv.streamTEnv().sqlQuery(querySql); &#x2F;&#x2F; 3. 报警逻辑（toRetractStream 返回 Tuple2&lt;Boolean, Row&gt; 类型），如果 sum_money 超过 1w，报警 &#x2F;&#x2F; Tuple2&lt;Boolean, Row&gt; f0 的 Boolean 标识是否是回撤消息 flinkEnv.streamTEnv() .toRetractStream(resultTable, Row.class) .flatMap(new FlatMapFunction&lt;Tuple2&lt;Boolean, Row&gt;, Object&gt;() &#123; @Override public void flatMap(Tuple2&lt;Boolean, Row&gt; value, Collector&lt;Object&gt; out) throws Exception &#123; long l &#x3D; Long.parseLong(String.valueOf(value.f1.getField(&quot;sum_money&quot;))); if (l &gt; 10000L) &#123; log.info(&quot;报警，超过 1w&quot;); &#125; &#125; &#125;); flinkEnv.env().execute(); &#125;&#125; 5.总结与展望源码公众号后台回复1.13.2 table datastream获取。 本文主要介绍了 flink 中 Table 和 DataStream 互转使用方式，并介绍了一些使用注意事项，总结如下： 背景及应用场景介绍：博主期望你能了解到，Flink 支持了 SQL 和 Table API 中的 Table 与 DataStream 互转的接口。通过这种互转的方式，我们就可以将一些自定义的数据源（DataStream）创建为 SQL 表，也可以将 SQL 执行结果转换为 DataStream 然后后续去完成一些在 SQL 中实现不了的复杂操作。肥肠的方便。 目前只有流任务支持互转，批任务不支持：在 1.13 版本中，由于流和批的 env 接口不一样，流任务为 StreamTableEnvironment，批任务为 TableEnvironment，目前只有 StreamTableEnvironment 支持了互转的接口，TableEnvironment 没有这样的接口，因此目前流任务支持互转，批任务不支持。但是 1.14 版本中流批任务的 env 都统一到了 StreamTableEnvironment 中，流批任务中就都可以进行互转了。 Retract 语义 SQL 转 DataStream 需要重点注意：Append 语义的 SQL 转为 DataStream 使用的 API 为 StreamTableEnvironment::toDataStream，Retract 语义的 SQL 转为 DataStream 使用的 API 为 StreamTableEnvironment::toRetractStream，两个接口不一样，小伙伴萌一定要特别注意。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十七）：flink sql 开发利器之 Zeppelin","date":"2021-11-15T08:26:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/18_flink sql 知其所以然（十七）：flink-sql-开发利器之zeppelin/","text":"1.序篇上节介绍了 flink sql 的企业级开发利器 Dlink。本节就来介绍下 Apache Zeppelin。 本节主要介绍一下博主在本地部署 Apache Zeppelin 的过程以及感受。 先说下安装感受，Apache Zeppelin 安装起来真的是非常的方便！！！ 几步就完成了。 2.Apache Zeppelin 平台效果具体功能如下图所示： 3.安装部署篇安装真的很简单。 可以参考 jeff 大佬的安装教程，也可以参考博主本文的安装教程。 jeff 大佬安装教程：https://www.yuque.com/jeffzhangjianfeng/gldg8w/bam5y1 3.1.安装 flink这一步是为了配置 flink 的环境。 https://archive.apache.org/dist/flink/flink-1.13.2/ 点击链接之后可以直接下载。 下载完成之后直接 tar -xvf jar 包解压就行。 就得到了以下的 flink 目录。 我们要把 lib 目录下的 flink-python_2.11-1.13.2.jar 复制到 opt 目录下 然后就完成了本地 flink 环境的配置。 3.2.下载 zeppelin 的 tar 包这一步是为了配置 zeppelin 的环境。 https://zeppelin.apache.org/download.html 点击上述链接直接下载：博主这里为了使用方便直接下载包含所有 interpreter 的包，下载完成之后直接 tar -xvf jar 包解压就行。 得到以下目录。 直接 bin/zeppelin-daemon.sh start 就完事了。看到下面的 console，就代表启动成功了。 打开 localhost:8080 就可以直接看到页面了。看到下面的页面说明就没啥问题了。 3.3.在 zeppelin 中配置 flink 环境信息按照下面的步骤配置环境信息。 然后我们就可以直接在 Zeppelin 中编辑 sql 了。 可以看到上述流程是非常简单的。 几乎没有什么学习和复杂配置的成本。 推荐大家可以尝试安装。 真的是肥肠的方便。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十八）：在 flink 中怎么使用 hive udf？","date":"2021-11-15T08:26:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/19_flink sql 知其所以然（十八）：flinksqludf/","text":"1.序篇源码公众号后台回复1.13.2 sql hive udf获取。 废话不多说，咱们先直接上本文的目录和结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 背景及应用场景介绍：博主期望你能了解到，其实很多场景下实时数仓的建设都是随着离线数仓而建设的（相同的逻辑在实时数仓中重新实现一遍），因此能够在 flink sql 中复用 hive udf 是能够大大提高人效的。 flink 扩展支持 hive 内置 udf：flink sql 提供了扩展 udf 的能力，即 module，并且 flink sql 也内置了 HiveModule（需要你主动加载进环境），来支持一些 hive 内置的 udf （比如 get_json_object）给小伙伴们使用。 flink 扩展支持用户自定义的 hive udf：主要介绍 flink sql 流任务中，不能使用 create temporary function 去引入一个用户自定义的 hive udf。因此博主只能通过 flink sql 提供的 module 插件能力，自定义了 module，来支持引入用户自定义的 hive udf。 2.背景及应用场景介绍其实大多数公司都是从离线数仓开始建设的。相信大家必然在自己的生产环境中开发了非常多的 hive udf。随着需求对于时效性要求的增高，越来越多的公司也开始建设起实时数仓。很多场景下实时数仓的建设都是随着离线数仓而建设的。实时数据使用 flink 产出，离线数据使用 hive\\spark 产出。 那么回到我们文章标题的问题：为什么需要 flink 支持 hive udf 呢？ 博主分析了下，结论如下： 站在数据需求的角度来说，一般会有以下两种情况： 以前已经有了离线数据链路，需求方也想要实时数据。如果直接能用已经开发好的 hive udf，则不用将相同的逻辑迁移到 flink udf 中，并且后续无需费时费力维护两个 udf 的逻辑一致性。 实时和离线的需求都是新的，需要新开发。如果只开发一套 udf，则事半功倍。 因此在 flink 中支持 hive udf 这件事对开发人员提效来说是非常有好处的。 3.在扩展前，你需要知道一些基本概念flink 支持 hive udf 这件事分为两个部分。 flink 扩展支持 hive 内置 udf flink 扩展支持用户自定义 hive udf 第一部分：flink 扩展支持 hive 内置 udf，比如 get_json_object，rlike 等等。 有同学问了，这么基本的 udf，flink 都没有吗？ 确实没有。关于 flink sql 内置的 udf 见如下链接，大家可以看看 flink 支持了哪些 udf：https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/functions/systemfunctions/ 那么如果我如果强行使用 get_json_object 这个 udf，会发生啥呢？结果如下图。 直接报错找不到 udf。 第二部分：flink 扩展支持用户自定义 hive udf。 内置函数解决不了用户的复杂需求，用户就需要自己写 hive udf，并且这部分自定义 udf 也想在 flink sql 中使用。 下面看看怎么在 flink sql 中进行这两种扩展。 4.hive udf 扩展支持4.1.flink sql module涉及到扩展 udf 就不得不提到 flink 提供的 module。见官网下图。 从第一句话就可以看到，module 的作用就是让用户去扩展 udf 的。 flink 本身已经内置了一个 module，名字叫 CoreModule，其中已经包含了一些 udf。 那我们要怎么使用 module 这玩意去扩展我们的 hive udf 呢？ 4.2.flink 扩展支持 hive 内置 udf步骤如下： 引入 hive 的 connector。其中包含了 flink 官方提供的一个 HiveModule。在 HiveModule 中包含了 hive 内置的 udf。 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-hive_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在 StreamTableEnvironment 中加载 HiveModule。 123String name = &quot;default&quot;;String version = &quot;3.1.2&quot;;tEnv.loadModule(name, new HiveModule(version)); 然后在控制台打印一下目前有的 module。 12String[] modules = tEnv.listModules();Arrays.stream(modules).forEach(System.out::println); 然后可以看到除了 core module，还有我们刚刚加载进去的 default module。 12defaultcore 查看所有 module 的所有 udf。在控制台打印一下。12String[] functions = tEnv.listFunctions();Arrays.stream(functions).forEach(System.out::println); 就会将 default 和 core module 中的所有包含的 udf 给列举出来，当然也就包含了 hive module 中的 get_json_object。 然后我们再去在 flink sql 中使用 get_json_object 这个 udf，就没有报错，能正常输出结果了。 使用 flink hive connector 自带的 HiveModule，已经能够解决很大一部分常见 udf 使用的问题了。 4.2.flink 扩展支持用户自定义 hive udf原本博主是直接想要使用 flink sql 中的 create temporary function 去执行引入自定义 hive udf 的。 举例如下： 1CREATE TEMPORARY FUNCTION test_hive_udf as &#x27;flink.examples.sql._09.udf._02_stream_hive_udf.TestGenericUDF&#x27;; 发现在执行这句 sql 时，是可以执行成功，将 udf 注册进去的。 但是在后续 udf 初始化时就报错了。具体错误如下图。直接报错 ClassCastException。 看了下源码，flink 流环境下（未连接 hive catalog 时）在创建 udf 时会认为这个 udf 是 flink 生态体系中的 udf。 所以在初始化我们引入的 TestGenericUDF 时，默认会按照 flink 的 UserDefinedFunction 强转，因此才会报强转错误。 那么我们就不能使用 hive udf 了吗？ 错误，小伙伴萌岂敢有这种想法。博主都把这个标题列出来了（牛逼都吹出去了），还能给不出解决方案嘛。 思路见下一章节。 4.3.flink 扩展支持用户自定义 hive udf 的增强 module其实思路很简单。 使用 flink sql 中的 create temporary function 虽然不能执行，但是 flink 提供了插件化的自定义 module。 我们可以扩展一个支持用户自定义 hive udf 的 module，使用这个 module 来支持自定义的 hive udf。 实现的代码也非常简单。简单的把 flink hive connector 提供的 HiveModule 做一个增强即可，即下图中的 HiveModuleV2。 使用方式如下图所示： 源码公众号后台回复1.13.2 sql hive udf获取。 然后程序就正常跑起来了。 肥肠滴好用！ 5.总结与展望源码公众号后台回复1.13.2 sql hive udf获取。 本文主要介绍了如果在 flink sql 使用 hive 内置 udf 及用户自定义 hive udf，总结如下： 背景及应用场景介绍：博主期望你能了解到，其实很多场景下实时数仓的建设都是随着离线数仓而建设的（相同的逻辑在实时数仓中重新实现一遍），因此能够在 flink sql 中复用 hive udf 是能够大大提高人效的。 flink 扩展支持 hive 内置 udf：flink sql 提供了扩展 udf 的能力，即 module，并且 flink sql 也内置了 HiveModule（需要你主动加载进环境），来支持一些 hive 内置的 udf （比如 get_json_object）给小伙伴们使用。 flink 扩展支持用户自定义的 hive udf：主要介绍 flink sql 流任务中，不能使用 create temporary function 去引入一个用户自定义的 hive udf。因此博主只能通过 flink sql 提供的 module 插件能力，自定义了 module，来支持引入用户自定义的 hive udf。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"史上最全干货！Flink SQL 成神之路（全文 18 万字、138 个案例、42 张图）","date":"2021-11-15T08:26:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/20_史上最全干货！FlinkSQL成神之路（全文6万字、110个知识点、160张图）/","text":"1.前言提前说明，如有抄袭，版权必究。 呕心沥血，Flink SQL 成神之路出品。小伙伴萌可以先体验一下下图大纲。由于微信公众号限制上传图片像素，所以博主分隔成了 5 张图片。。。 2.基础概念篇2.1.SQL &amp; Table 简介及运行环境2.1.1.简介Apache Flink 提供了两种关系型 API 用于统一流和批处理，Table 和 SQL API。 ⭐ Table API 是一种集成在 Java、Scala 和 Python 语言中的查询 API，简单理解就是用 Java、Scala、Python 按照 SQL 的查询接口封装了一层 lambda 表达式的查询 API，它允许以强类型接口的方式组合各种关系运算符（如选择、筛选和联接）的查询操作，然后生成一个 Flink 任务运行。如下案例所示： 12345678910111213141516171819202122import org.apache.flink.table.api.*;import static org.apache.flink.table.api.Expressions.*;EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() .build();TableEnvironment tEnv = TableEnvironment.create(settings);// 下面就是 Table API 的案例，其语义等同于// select a, count(b) as cnt // from Orders// group by aDataSet&lt;Row&gt; result = tEnv .from(&quot;Orders&quot;) .groupBy($(&quot;a&quot;)) .select($(&quot;a&quot;), $(&quot;b&quot;).count().as(&quot;cnt&quot;)) .toDataSet(counts, Row.class);result.print(); ⭐ SQL API 是基于 SQL 标准的 Apache Calcite 框架实现的，我们可以使用纯 SQL 来开发和运行一个 Flink 任务。如下案例所示： 1234insert into targetselect a, count(b) as cntfrom Ordersgroup by a 注意：无论输入是连续（流处理）还是有界（批处理），在 Table 和 SQL 任一 API 中同一条查询语句是具有相同的语义并且会产出相同的结果的。这就是说为什么 Flink SQL 和 Table API 可以做到在用户接口层面的流批统一。xdm，用一套 SQL 既能跑流任务，也能跑批任务，它不香嘛？ Table API 和 SQL API 也与 DataStream API 做到了无缝集成。可以轻松地在三种 API 之间灵活切换。例如，可以使用 SQL 的 MATCH_RECOGNIZE 子句匹配出异常的数据，然后使用再转为 DataStream API 去灵活的构建针对于异常数据的自定义报警机制。 在 xdm 大体了解了这两个 API 是干啥的之后，我们就可以直接来看看，怎么使用这两个 API 了。 2.1.2.SQL 和 Table API 运行环境依赖根据小伙伴们使用的编程语言的不同（Java 或 Scala），需要将对应的依赖包添加到项目中。 ⭐ Java 依赖如下 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-java-bridge_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner-blink_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-common&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt;&lt;/dependency&gt; ⭐ Scala 依赖如下 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-scala-bridge_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner-blink_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-common&lt;/artifactId&gt; &lt;version&gt;1.13.5&lt;/version&gt;&lt;/dependency&gt; 引入上述依赖之后，小伙伴萌就可以开始使用 Table\\SQL API 了。具体案例如下文所示。 2.2.SQL &amp; Table 的基本概念及常用 API在小伙伴萌看下文之前，先看一下 2.2 节整体的思路，跟着博主思路走，会更清晰： ⭐ 先通过一个 SQL\\Table API 任务看一下我们在实际开发时的代码结构应该长啥样，让大家能有直观的感受 ⭐ 重点介绍 SQL\\Table API 中核心 API - TableEnvironment。SQL\\Table 所有能用的接口都在 TableEnvironment 中 ⭐ 通过两个角度（外部表\\视图、临时\\非临时）认识 Flink SQL 体系中的表的概念 ⭐ 举几个创建外部表、视图的实际应用案例 2.2.1.一个 SQL\\Table API 任务的代码结构12345678910111213141516171819202122// 创建一个 TableEnvironment，为后续使用 SQL 或者 Table API 提供上线EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() // 声明为流任务 //.inBatchMode() // 声明为批任务 .build();TableEnvironment tEnv = TableEnvironment.create(settings);// 创建一个输入表tableEnv.executeSql(&quot;CREATE TEMPORARY TABLE table1 ... WITH ( &#x27;connector&#x27; = ... )&quot;);// 创建一个输出表tableEnv.executeSql(&quot;CREATE TEMPORARY TABLE outputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;);// 1. 使用 Table API 做一个查询并返回 TableTable table2 = tableEnv.from(&quot;table1&quot;).select(...);// 2. 使用 SQl API 做一个查询并返回 TableTable table3 = tableEnv.sqlQuery(&quot;SELECT ... FROM table1 ... &quot;);// 将 table2 的结果使用 Table API 写入 outputTable 中，并返回结果TableResult tableResult = table2.executeInsert(&quot;outputTable&quot;);tableResult... 总结一下上面案例使用到的一些 API，让大家先对 Table\\SQL API 的能力有一个大概了解： ⭐ TableEnvironment：Table API 和 SQL API 的都集成在一个统一上下文（即 TableEnvironment）中，其地位等同于 DataStream API 中的 StreamExecutionEnvironment 的地位 ⭐ TableEnvironment::executeSql：用于 SQL API 中，可以执行一段完整 DDL，DML SQL。举例，方法入参可以是 CREATE TABLE xxx，INSERT INTO xxx SELECT xxx FROM xxx。 ⭐ TableEnvironment::from(xxx)：用于 Table API 中，可以以强类型接口的方式运行。方法入参是一个表名称。 ⭐ TableEnvironment::sqlQuery：用于 SQL API 中，可以执行一段查询 SQL，并把结果以 Table 的形式返回。举例，方法的入参是 SELECT xxx FROM xxx ⭐ Table::executeInsert：用于将 Table 的结果插入到结果表中。方法入参是写入的目标表。 无论是对于 SQL API 来说还是对于 Table API 来说，都是使用 TableEnvironment 接口承载我们的业务查询逻辑的。只是在用户的使用接口的方式上有区别，以上述的 Java 代码为例，Table API 其实就是模拟 SQL 的查询方式封装了 Java 语言的 lambda 强类型 API，SQL 就是纯 SQL 查询。Table 和 SQL 很多时候都是掺杂在一起的，大家理解的时候就可以直接将 Table 和 SQL API 直接按照 SQL 进行理解，不用强行做特殊的区分。 而且博主推荐的话，直接上 SQL API 就行，其实 Table API 在企业实战中用的不是特别多。你说 Table API 方便吧，它确实比 DataStream API 方便，但是又比 SQL 复杂。一般生产使用不多。 注意：由于 Table 和 SQL API 基本上属于一回事，后续如果没有特别介绍的话，博主就直接按照 SQL API 进行介绍了。 如果 xdm 想直接上手运行一段 Flink SQL 的代码。 可以直接在公众号后台回复1.13.2 最全 flink sql获取源代码。所有的源码都开源到 github 上面了。里面包含了非常多的案例。可以直接拿来在本地运行的！！！肥肠的方便。 2.2.2.SQL 上下文：TableEnvironmentTableEnvironment 是使用 SQL API 永远都离不开的一个接口。其是 SQL API 使用的入口（上下文），就像是你要使用 Java DataStream API 去写一个 Flink 任务需要使用到 StreamExecutionEnvironment 一样。 可以认为 TableEnvironment 在 SQL API 中的地位和 StreamExecutionEnvironment 在 DataStream 中的地位是一样的，都是包含了一个 Flink 任务运行时的所有上下文环境信息。大家这样对比学习会比较好理解。 TableEnvironment 包含的功能如下： ⭐ ️Catalog 管理：Catalog 可以理解为 Flink 的 MetaStore，类似 Hive MetaStore 对在 Hive 中的地位，关于 Flink Catalog 的详细内容后续进行介绍 ⭐ ️表管理：在 Catalog 中注册表 ⭐️ SQL 查询：（这 TMD 还用说，最基本的功能啊），就像 DataStream 中提供了 addSource、map、flatmap 等接口 ⭐ UDF 管理：注册用户定义（标量函数：一进一出、表函数：一进多出、聚合函数：多进一出）函数 ⭐️ UDF 扩展：加载可插拔 Module（Module 可以理解为 Flink 管理 UDF 的模块，是可插拔的，可以让小伙伴萌自定义 Module，去支持奇奇怪怪的 UDF 功能） ⭐ DataStream 和 Table（Table\\SQL API 的查询结果）之间进行转换：目前 1.13 版本的只有流任务支持，批任务不支持。1.14 支持批任务。 接下来介绍如何创建一个 TableEnvironment。案例为 Java。easy game。 ⭐ 方法 1：通过 EnvironmentSettings 创建 TableEnvironment 123456789101112import org.apache.flink.table.api.EnvironmentSettings;import org.apache.flink.table.api.TableEnvironment;// 1. 就是设置一些环境信息EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() // 声明为流任务 //.inBatchMode() // 声明为批任务 .build();// 2. 创建 TableEnvironmentTableEnvironment tEnv = TableEnvironment.create(settings); 在 1.13 版本中。 如果你是 inStreamingMode，则最终创建出来的 TableEnvironment 实例为 StreamTableEnvironmentImpl。 如果你是 inBatchMode，则最终创建出来的 TableEnvironment 实例为 TableEnvironmentImpl。 它两虽然都继承了 TableEnvironment 接口，但是 StreamTableEnvironmentImpl 支持的功能更多一些。大家可以直接去看看接口实验一下，这里就不进行详细介绍。 ⭐ 方法 2：通过已有的 StreamExecutionEnvironment 创建 TableEnvironment 123456import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;import org.apache.flink.table.api.EnvironmentSettings;import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();StreamTableEnvironment tEnv = StreamTableEnvironment.create(env); 2.2.3.SQL 中表的概念一个表的全名（标识）会由三个部分组成：Catalog 名称.数据库名称.表名称。如果 Catalog 名称或者数据库名称没有指明，就会使用当前默认值 default。 举个例子，下面这个 SQL 创建的 Table 的全名为 default.default.table1。 1tableEnv.executeSql(&quot;CREATE TEMPORARY TABLE table1 ... WITH ( &#x27;connector&#x27; = ... )&quot;); 下面这个 SQL 创建的 Table 的全名为 default.mydatabase.table1。 1tableEnv.executeSql(&quot;CREATE TEMPORARY TABLE mydatabase.table1 ... WITH ( &#x27;connector&#x27; = ... )&quot;); 表可以是常规的（外部表 TABLE），也可以是虚拟的（视图 VIEW）。 ⭐ 外部表 TABLE：描述的是外部数据，例如文件（HDFS）、消息队列（Kafka）等。依然拿离线 Hive SQL 举个例子，离线中一个表指的是 Hive 表，也就是所说的外部数据。 ⭐ 视图 VIEW：从已经存在的表中创建，视图一般是一个 SQL 逻辑的查询结果。对比到离线的 Hive SQL 中，在离线的场景（Hive 表）中 VIEW 也都是从已有的表中去创建的。其实 Flink 也是一样的。 注意： 这里有不同的地方就是，离线 Hive MetaStore 中不会有 Catalog 这个概念，其标识都是 数据库.数据表。 2.2.4.SQL 临时表、永久表表（视图、外部表）可以是临时的，并与单个 Flink session（可以理解为 Flink 任务运行一次就是一个 session）的生命周期绑定。 表（视图、外部表）也可以是永久的，并且对多个 Flink session 都生效。 ⭐ 临时表：通常保存于内存中并且仅在创建它们的 Flink session（可以理解为一次 Flink 任务的运行）持续期间存在。这些表对于其它 session（即其他 Flink 任务或非此次运行的 Flink 任务）是不可见的。因为这个表的元数据没有被持久化。如下案例： 12345678910111213141516-- 临时外部表CREATE TEMPORARY TABLE source_table ( user_id BIGINT, `name` STRING) WITH ( &#x27;connector&#x27; = &#x27;user_defined&#x27;, &#x27;format&#x27; = &#x27;json&#x27;, &#x27;class.name&#x27; = &#x27;flink.examples.sql._03.source_sink.table.user_defined.UserDefinedSource&#x27;);-- 临时视图CREATE TEMPORARY VIEW query_view asSELECT *FROM source_table; ⭐ 永久表：需要外部 Catalog（例如 Hive Metastore）来持久化表的元数据。一旦永久表被创建，它将对任何连接到这个 Catalog 的 Flink session 可见且持续存在，直至从 Catalog 中被明确删除。如下案例： 12345678910111213141516-- 永久外部表。需要外部 Catalog 持久化！！！CREATE TABLE source_table ( user_id BIGINT, `name` STRING) WITH ( &#x27;connector&#x27; = &#x27;user_defined&#x27;, &#x27;format&#x27; = &#x27;json&#x27;, &#x27;class.name&#x27; = &#x27;flink.examples.sql._03.source_sink.table.user_defined.UserDefinedSource&#x27;);-- 永久视图。需要外部 Catalog 持久化！！！CREATE VIEW query_view asSELECT *FROM source_table; ⭐ 如果临时表和永久表使用了相同的名称（Catalog名.数据库名.表名）。那么在这个 Flink session 中，你的任务访问到这个表时，访问到的永远是临时表（即相同名称的表，临时表会屏蔽永久表）。 2.2.5.SQL 外部数据表由于目前在实时数据的场景中多以消息队列作为数据表。此处就以 Kafka 为例创建一个外部数据表。 ⭐ Table API 创建外部数据表 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode() .build(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings); // kafka 数据源 DataStream&lt;Row&gt; r = env.addSource(new FlinkKafkaConsumer&lt;Row&gt;(xxx)); // 将 DataStream 转为一个 Table API 中的 Table 对象进行使用 Table sourceTable = tEnv.fromDataStream(r , Schema .newBuilder() .column(&quot;f0&quot;, &quot;string&quot;) .column(&quot;f1&quot;, &quot;string&quot;) .column(&quot;f2&quot;, &quot;bigint&quot;) .columnByExpression(&quot;proctime&quot;, &quot;PROCTIME()&quot;) .build()); tEnv.createTemporaryView(&quot;source_table&quot;, sourceTable); String selectWhereSql = &quot;select f0 from source_table where f1 = &#x27;b&#x27;&quot;; Table resultTable = tEnv.sqlQuery(selectWhereSql); tEnv.toRetractStream(resultTable, Row.class).print(); env.execute();&#125; 上述案例中，Table API 将一个 DataStream 的结果集通过 StreamTableEnvironment::fromDataStream 转为一个 Table 对象来使用。 ⭐ SQL API 创建外部数据表 1234567891011121314151617181920212223EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode() .build();StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings);// SQL API 执行 create table 创建表tEnv.executeSql( &quot;CREATE TABLE KafkaSourceTable (\\n&quot; + &quot; `f0` STRING,\\n&quot; + &quot; `f1` STRING\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;kafka&#x27;,\\n&quot; + &quot; &#x27;topic&#x27; = &#x27;topic&#x27;,\\n&quot; + &quot; &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;,\\n&quot; + &quot; &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;,\\n&quot; + &quot; &#x27;format&#x27; = &#x27;json&#x27;\\n&quot; + &quot;)&quot;);Table t = tEnv.sqlQuery(&quot;SELECT * FROM KafkaSourceTable&quot;); 具体的创建方式就是使用 Create Table xxx DDL 定义一个 Kafka 数据源（输入）表（也可以是 Kafka 数据汇（输出）表）。 xdm，是不是又和 Hive 一样？惊不惊喜意不意外。对比学习 +1。 2.2.6.SQL 视图 VIEW上文已经说了，一个 VIEW 其实就是一段 SQL 逻辑的查询结果。 视图 VIEW 在 Table API 中的体现就是：一个 Table 的 Java 对象，其封装了一段查询逻辑。如下案例所示： ⭐ Table API 创建 VIEW 123456789101112131415import org.apache.flink.table.api.EnvironmentSettings;import org.apache.flink.table.api.TableEnvironment;EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() // 声明为流任务 .build();TableEnvironment tEnv = TableEnvironment.create(settings);// Table API 中的一个 Table 对象Table projTable = tEnv.from(&quot;X&quot;).select(...);// 将 projTable 创建为一个叫做 projectedTable 的 VIEWtEnv.createTemporaryView(&quot;projectedTable&quot;, projTable); Table API 是使用了 TableEnvironment::createTemporaryView 接口将一个 Table 对象创建为一个 VIEW。 ⭐ SQL API 创建 VIEW 12345678910111213141516171819202122232425262728293031323334353637import org.apache.flink.table.api.EnvironmentSettings;import org.apache.flink.table.api.TableEnvironment;EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() // 声明为流任务 .build();TableEnvironment tEnv = TableEnvironment.create(settings);String sql = &quot;CREATE TABLE source_table (\\n&quot; + &quot; user_id BIGINT,\\n&quot; + &quot; `name` STRING\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;user_defined&#x27;,\\n&quot; + &quot; &#x27;format&#x27; = &#x27;json&#x27;,\\n&quot; + &quot; &#x27;class.name&#x27; = &#x27;flink.examples.sql._03.source_sink.table.user_defined.UserDefinedSource&#x27;\\n&quot; + &quot;);\\n&quot; + &quot;\\n&quot; + &quot;CREATE TABLE sink_table (\\n&quot; + &quot; user_id BIGINT,\\n&quot; + &quot; name STRING\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;print&#x27;\\n&quot; + &quot;);\\n&quot; + &quot;CREATE VIEW query_view as\\n&quot; // 创建 VIEW + &quot;SELECT\\n&quot; + &quot; *\\n&quot; + &quot;FROM source_table\\n&quot; + &quot;;\\n&quot; + &quot;INSERT INTO sink_table\\n&quot; + &quot;SELECT\\n&quot; + &quot; *\\n&quot; + &quot;FROM query_view;&quot;;Arrays.stream(sql.split(&quot;;&quot;)) .forEach(tEnv::executeSql); SQL API 是直接通过一段 CREATE VIEW query_view as select * from source_table 来创建的 VIEW，是纯 SQL 写法。 这种创建方式是不是贼熟悉，和离线 Hive 一样 +1~ 注意： 在 Table API 中的一个 Table 对象被后续的多个查询使用的场景下：Table 对象不会真的产生一个中间表供下游多个查询去引用，即多个查询不共享这个 Table 的结果，小伙伴萌可以理解为是一种中间表的简化写法，不会先产出一个中间表结果，然后将这个结果在下游多个查询中复用，后续的多个查询会将这个 Table 的逻辑执行多次。类似于 with tmp as (DML) 的语法 2.2.7.一个 SQL 查询案例首先，如果 xdm 想直接上手运行一段 Flink SQL 的代码。 可以直接在公众号后台回复1.13.2 最全 flink sql获取源代码。所有的源码都开源到 github 上面了。里面包含了非常多的案例。可以直接拿来在本地运行的！！！肥肠的方便。 来看看一个 SQL 查询案例。 ⭐ 案例场景：计算每一种商品（sku_id 唯一标识）的售出个数、总销售额、平均销售额、最低价、最高价 ⭐ 数据准备：数据源为商品的销售流水（sku_id：商品，price：销售价格），然后写入到 Kafka 的指定 topic（sku_id：商品，count_result：售出个数、sum_result：总销售额、avg_result：平均销售额、min_result：最低价、max_result：最高价）当中 ⭐ 任务代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() // 声明为流任务 //.inBatchMode() // 声明为批任务 .build();TableEnvironment tEnv = TableEnvironment.create(settings);// 1. 创建一个数据源（输入）表，这里的数据源是 flink 自带的一个随机 mock 数据的数据源。String sourceSql = &quot;CREATE TABLE source_table (\\n&quot; + &quot; sku_id STRING,\\n&quot; + &quot; price BIGINT\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;datagen&#x27;,\\n&quot; + &quot; &#x27;rows-per-second&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.sku_id.length&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.price.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.price.max&#x27; = &#x27;1000000&#x27;\\n&quot; + &quot;)&quot;;// 2. 创建一个数据汇（输出）表，输出到 kafka 中String sinkSql = &quot;CREATE TABLE sink_table (\\n&quot; + &quot; sku_id STRING,\\n&quot; + &quot; count_result BIGINT,\\n&quot; + &quot; sum_result BIGINT,\\n&quot; + &quot; avg_result DOUBLE,\\n&quot; + &quot; min_result BIGINT,\\n&quot; + &quot; max_result BIGINT,\\n&quot; + &quot; PRIMARY KEY (`sku_id`) NOT ENFORCED\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;upsert-kafka&#x27;,\\n&quot; + &quot; &#x27;topic&#x27; = &#x27;tuzisir&#x27;,\\n&quot; + &quot; &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;,\\n&quot; + &quot; &#x27;key.format&#x27; = &#x27;json&#x27;,\\n&quot; + &quot; &#x27;value.format&#x27; = &#x27;json&#x27;\\n&quot; + &quot;)&quot;;// 3. 执行一段 group by 的聚合 SQL 查询String selectWhereSql = &quot;insert into sink_table\\n&quot; + &quot;select sku_id,\\n&quot; + &quot; count(*) as count_result,\\n&quot; + &quot; sum(price) as sum_result,\\n&quot; + &quot; avg(price) as avg_result,\\n&quot; + &quot; min(price) as min_result,\\n&quot; + &quot; max(price) as max_result\\n&quot; + &quot;from source_table\\n&quot; + &quot;group by sku_id&quot;;tEnv.executeSql(sourceSql);tEnv.executeSql(sinkSql);tEnv.executeSql(selectWhereSql); 2.2.8.SQL 与 DataStream API 的转换大家会比较好奇，要写 SQL 就纯 SQL 呗，要写 DataStream 就纯 DataStream 呗，为啥还要把这两类接口做集成呢？ 博主举一个案例：在 pdd 这种发补贴券的场景下，希望可以在发的补贴券总金额超过 1w 元时，及时报警出来，来帮助控制预算，防止发的太多。 对应的解决方案，我们可以想到使用 SQL 计算补贴券发放的结果，但是 SQL 的问题在于无法做到报警。所以我们可以将 SQL 的查询的结果（即 Table 对象）转为 DataStream，然后就可以在 DataStream 后自定义报警逻辑的算子。 我们直接上 SQL 和 DataStream API 互相转化的案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static void main(String[] args) throws Exception &#123; FlinkEnv flinkEnv = FlinkEnvUtils.getStreamTableEnv(args); // 1. pdd 发补贴券流水数据 String createTableSql = &quot;CREATE TABLE source_table (\\n&quot; + &quot; id BIGINT,\\n&quot; -- 补贴券的流水 id + &quot; money BIGINT,\\n&quot; -- 补贴券的金额 + &quot; row_time AS cast(CURRENT_TIMESTAMP as timestamp_LTZ(3)),\\n&quot; + &quot; WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;datagen&#x27;,\\n&quot; + &quot; &#x27;rows-per-second&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.id.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.id.max&#x27; = &#x27;100000&#x27;,\\n&quot; + &quot; &#x27;fields.money.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.money.max&#x27; = &#x27;100000&#x27;\\n&quot; + &quot;)\\n&quot;; // 2. 计算总计发放补贴券的金额 String querySql = &quot;SELECT UNIX_TIMESTAMP(CAST(window_end AS STRING)) * 1000 as window_end, \\n&quot; + &quot; window_start, \\n&quot; + &quot; sum(money) as sum_money,\\n&quot; -- 补贴券的发放总金额 + &quot; count(distinct id) as count_distinct_id\\n&quot; + &quot;FROM TABLE(CUMULATE(\\n&quot; + &quot; TABLE source_table\\n&quot; + &quot; , DESCRIPTOR(row_time)\\n&quot; + &quot; , INTERVAL &#x27;5&#x27; SECOND\\n&quot; + &quot; , INTERVAL &#x27;1&#x27; DAY))\\n&quot; + &quot;GROUP BY window_start, \\n&quot; + &quot; window_end&quot;; flinkEnv.streamTEnv().executeSql(createTableSql); Table resultTable = flinkEnv.streamTEnv().sqlQuery(querySql); // 3. 将金额结果转为 DataStream，然后自定义超过 1w 的报警逻辑 flinkEnv.streamTEnv() .toDataStream(resultTable, Row.class) .flatMap(new FlatMapFunction&lt;Row, Object&gt;() &#123; @Override public void flatMap(Row value, Collector&lt;Object&gt; out) throws Exception &#123; long l = Long.parseLong(String.valueOf(value.getField(&quot;sum_money&quot;))); if (l &gt; 10000L) &#123; log.info(&quot;报警，超过 1w&quot;); &#125; &#125; &#125;); flinkEnv.env().execute();&#125; 注意： 目前在 1.13 版本中，Flink 对于 Table 和 DataStream 的转化是有一些限制的：上面的案例可以看到，Table 和 DataStream 之间的转换目前只有 StreamTableEnvironment::toDataStream、StreamTableEnvironment::fromDataStream 接口支持。 所以其实小伙伴萌可以理解为只有流任务才支持 Table 和 DataStream 之间的转换，批任务是不支持的（虽然可以使用流执行模式处理有界流 - 批数据，也就是模拟按照批执行，但效率较低，这种骚操作不建议大家搞）。 那什么时候才能支持批任务的 Table 和 DataStream 之间的转换呢？1.14 版本支持。1.14 版本中，流和批的都统一到了 StreamTableEnvironment 中，因此就可以做 Table 和 DataStream 的互相转换了。 2.3.SQL 数据类型在介绍完一些基本概念之后，我们来认识一下，Flink SQL 中的数据类型。 Flink SQL 内置了很多常见的数据类型，并且也为用户提供了自定义数据类型的能力。 总共包含 3 部分： ⭐ 原子数据类型 ⭐ 复合数据类型 ⭐ 用户自定义数据类型 2.3.1.原子数据类型 ⭐ 字符串类型： ⭐ CHAR、CHAR(n)：定长字符串，就和 Java 中的 Char 一样，n 代表字符的定长，取值范围 [1, 2,147,483,647]。如果不指定 n，则默认为 1。 ⭐ VARCHAR、VARCHAR(n)、STRING：可变长字符串，就和 Java 中的 String 一样，n 代表字符的最大长度，取值范围 [1, 2,147,483,647]。如果不指定 n，则默认为 1。STRING 等同于 VARCHAR(2147483647)。 ⭐ 二进制字符串类型： ⭐ BINARY、BINARY(n)：定长二进制字符串，n 代表定长，取值范围 [1, 2,147,483,647]。如果不指定 n，则默认为 1。 ⭐ VARBINARY、VARBINARY(n)、BYTES：可变长二进制字符串，n 代表字符的最大长度，取值范围 [1, 2,147,483,647]。如果不指定 n，则默认为 1。BYTES 等同于 VARBINARY(2147483647)。 ⭐ 精确数值类型： ⭐ DECIMAL、DECIMAL(p)、DECIMAL(p, s)、DEC、DEC(p)、DEC(p, s)、NUMERIC、NUMERIC(p)、NUMERIC(p, s)：固定长度和精度的数值类型，就和 Java 中的 BigDecimal 一样，p 代表数值位数（长度），取值范围 [1, 38]；s 代表小数点后的位数（精度），取值范围 [0, p]。如果不指定，p 默认为 10，s 默认为 0。 ⭐ TINYINT：-128 到 127 的 1 字节大小的有符号整数，就和 Java 中的 byte 一样。 ⭐ SMALLINT：-32,768 to 32,767 的 2 字节大小的有符号整数，就和 Java 中的 short 一样。 ⭐ INT、INTEGER：-2,147,483,648 to 2,147,483,647 的 4 字节大小的有符号整数，就和 Java 中的 int 一样。 ⭐ BIGINT：-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 的 8 字节大小的有符号整数，就和 Java 中的 long 一样。 ⭐ 有损精度数值类型： ⭐ FLOAT：4 字节大小的单精度浮点数值，就和 Java 中的 float 一样。 ⭐ DOUBLE、DOUBLE PRECISION：8 字节大小的双精度浮点数值，就和 Java 中的 double 一样。 ⭐ 关于 FLOAT 和 DOUBLE 的区别可见 https://www.runoob.com/w3cnote/float-and-double-different.html ⭐ 布尔类型：BOOLEAN ⭐ NULL 类型：NULL ⭐ Raw 类型：RAW(‘class’, ‘snapshot’) 。只会在数据发生网络传输时进行序列化，反序列化操作，可以保留其原始数据。以 Java 举例，class 参数代表具体对应的 Java 类型，snapshot 代表类型在发生网络传输时的序列化器 ⭐ 日期、时间类型： ⭐ DATE：由 年-月-日 组成的 不带时区含义 的日期类型，取值范围 [0000-01-01, 9999-12-31] ⭐ TIME、TIME(p)：由 小时：分钟：秒[.小数秒] 组成的 不带时区含义 的的时间的数据类型，精度高达纳秒，取值范围 [00:00:00.000000000到23:59:59.9999999]。其中 p 代表小数秒的位数，取值范围 [0, 9]，如果不指定 p，默认为 0。 ⭐ TIMESTAMP、TIMESTAMP(p)、TIMESTAMP WITHOUT TIME ZONE、TIMESTAMP(p) WITHOUT TIME ZONE：由 年-月-日 小时：分钟：秒[.小数秒] 组成的 不带时区含义 的时间类型，取值范围 [0000-01-01 00:00:00.000000000, 9999-12-31 23:59:59.999999999]。其中 p 代表小数秒的位数，取值范围 [0, 9]，如果不指定 p，默认为 6。 ⭐ TIMESTAMP WITH TIME ZONE、TIMESTAMP(p) WITH TIME ZONE：由 年-月-日 小时：分钟：秒[.小数秒] 时区 组成的 带时区含义 的时间类型，取值范围 [0000-01-01 00:00:00.000000000 +14:59, 9999-12-31 23:59:59.999999999 -14:59]。其中 p 代表小数秒的位数，取值范围 [0, 9]，如果不指定 p，默认为 6。 ⭐ TIMESTAMP_LTZ、TIMESTAMP_LTZ(p)：由 年-月-日 小时：分钟：秒[.小数秒] 时区 组成的 带时区含义 的时间类型，取值范围 [0000-01-01 00:00:00.000000000 +14:59, 9999-12-31 23:59:59.999999999 -14:59]。其中 p 代表小数秒的位数，取值范围 [0, 9]，如果不指定 p，默认为 6。 ⭐ TIMESTAMP_LTZ 与 TIMESTAMP WITH TIME ZONE 的区别在于：TIMESTAMP WITH TIME ZONE 的时区信息是携带在数据中的，举例：其输入数据应该是 2022-01-01 00:00:00.000000000 +08:00；TIMESTAMP_LTZ 的时区信息不是携带在数据中的，而是由 Flink SQL 任务的全局配置决定的，我们可以由 table.local-time-zone 参数来设置时区。 ⭐ INTERVAL YEAR TO MONTH、 INTERVAL DAY TO SECOND：interval 的涉及到的种类比较多。INTERVAL 主要是用于给 TIMESTAMP、TIMESTAMP_LTZ 添加偏移量的。举例，比如给 TIMESTAMP 加、减几天、几个月、几年。INTERVAL 子句总共涉及到的语法种类如下 Flink SQL 案例所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960CREATE TABLE sink_table ( result_interval_year TIMESTAMP(3), result_interval_year_p TIMESTAMP(3), result_interval_year_p_to_month TIMESTAMP(3), result_interval_month TIMESTAMP(3), result_interval_day TIMESTAMP(3), result_interval_day_p1 TIMESTAMP(3), result_interval_day_p1_to_hour TIMESTAMP(3), result_interval_day_p1_to_minute TIMESTAMP(3), result_interval_day_p1_to_second_p2 TIMESTAMP(3), result_interval_hour TIMESTAMP(3), result_interval_hour_to_minute TIMESTAMP(3), result_interval_hour_to_second TIMESTAMP(3), result_interval_minute TIMESTAMP(3), result_interval_minute_to_second_p2 TIMESTAMP(3), result_interval_second TIMESTAMP(3), result_interval_second_p2 TIMESTAMP(3)) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT -- Flink SQL 支持的所有 INTERVAL 子句如下，总体可以分为 `年-月`、`日-小时-秒` 两种 -- 1. 年-月。取值范围为 [-9999-11, +9999-11]，其中 p 是指有效位数，取值范围 [1, 4]，默认值为 2。比如如果值为 1000，但是 p = 2，则会直接报错。 -- INTERVAL YEAR f1 + INTERVAL &#x27;10&#x27; YEAR as result_interval_year -- INTERVAL YEAR(p) , f1 + INTERVAL &#x27;100&#x27; YEAR(3) as result_interval_year_p -- INTERVAL YEAR(p) TO MONTH , f1 + INTERVAL &#x27;10-03&#x27; YEAR(3) TO MONTH as result_interval_year_p_to_month -- INTERVAL MONTH , f1 + INTERVAL &#x27;13&#x27; MONTH as result_interval_month -- 2. 日-小时-秒。取值范围为 [-999999 23:59:59.999999999, +999999 23:59:59.999999999]，其中 p1\\p2 都是有效位数，p1 取值范围 [1, 6]，默认值为 2；p2 取值范围 [0, 9]，默认值为 6 -- INTERVAL DAY , f1 + INTERVAL &#x27;10&#x27; DAY as result_interval_day -- INTERVAL DAY(p1) , f1 + INTERVAL &#x27;100&#x27; DAY(3) as result_interval_day_p1 -- INTERVAL DAY(p1) TO HOUR , f1 + INTERVAL &#x27;10 03&#x27; DAY(3) TO HOUR as result_interval_day_p1_to_hour -- INTERVAL DAY(p1) TO MINUTE , f1 + INTERVAL &#x27;10 03:12&#x27; DAY(3) TO MINUTE as result_interval_day_p1_to_minute -- INTERVAL DAY(p1) TO SECOND(p2) , f1 + INTERVAL &#x27;10 00:00:00.004&#x27; DAY TO SECOND(3) as result_interval_day_p1_to_second_p2 -- INTERVAL HOUR , f1 + INTERVAL &#x27;10&#x27; HOUR as result_interval_hour -- INTERVAL HOUR TO MINUTE , f1 + INTERVAL &#x27;10:03&#x27; HOUR TO MINUTE as result_interval_hour_to_minute -- INTERVAL HOUR TO SECOND(p2) , f1 + INTERVAL &#x27;00:00:00.004&#x27; HOUR TO SECOND(3) as result_interval_hour_to_second -- INTERVAL MINUTE , f1 + INTERVAL &#x27;10&#x27; MINUTE as result_interval_minute -- INTERVAL MINUTE TO SECOND(p2) , f1 + INTERVAL &#x27;05:05.006&#x27; MINUTE TO SECOND(3) as result_interval_minute_to_second_p2 -- INTERVAL SECOND , f1 + INTERVAL &#x27;3&#x27; SECOND as result_interval_second -- INTERVAL SECOND(p2) , f1 + INTERVAL &#x27;300&#x27; SECOND(3) as result_interval_second_p2FROM (SELECT TO_TIMESTAMP_LTZ(1640966476500, 3) as f1) 2.3.2.复合数据类型 ⭐ 数组类型：ARRAY、t ARRAY。数组最大长度为 2,147,483,647。t 代表数组内的数据类型。举例 ARRAY、ARRAY，其等同于 INT ARRAY、STRING ARRAY ⭐ Map 类型：MAP&lt;kt, vt&gt;。Map 类型就和 Java 中的 Map 类型一样，key 是没有重复的。举例 Map&lt;STRING, INT&gt;、Map&lt;BIGINT, STRING&gt; ⭐ 集合类型：MULTISET、t MULTISET。就和 Java 中的 List 类型，一样，运行重复的数据。举例 MULTISET，其等同于 INT MULTISET ⭐ 对象类型：ROW&lt;n0 t0, n1 t1, …&gt;、ROW&lt;n0 t0 ‘d0’, n1 t1 ‘d1’, …&gt;、ROW(n0 t0, n1 t1, …&gt;、ROW(n0 t0 ‘d0’, n1 t1 ‘d1’, …)。就和 Java 中的自定义对象一样。举例：ROW(myField INT, myOtherField BOOLEAN)，其等同于 ROW&lt;myField INT, myOtherField BOOLEAN&gt; 2.3.3.用户自定义数据类型用户自定义类型就是运行用户使用 Java 等语言自定义一个数据类型出来。但是目前数据类型不支持使用 CREATE TABLE 的 DDL 进行定义，只支持作为函数的输入输出参数。如下案例： ⭐ 第一步，自定义数据类型 12345678910public class User &#123; // 1. 基础类型，Flink 可以通过反射类型信息自动把数据类型获取到 // 关于 SQL 类型和 Java 类型之间的映射见：https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/types/#data-type-extraction public int age; public String name; // 2. 复杂类型，用户可以通过 @DataTypeHint(&quot;DECIMAL(10, 2)&quot;) 注解标注此字段的数据类型 public @DataTypeHint(&quot;DECIMAL(10, 2)&quot;) BigDecimal totalBalance;&#125; ⭐ 第二步，在 UDF 中使用此数据类型 123456789101112131415161718192021222324252627282930313233343536public class UserScalarFunction extends ScalarFunction &#123; // 1. 自定义数据类型作为输出参数 public User eval(long i) &#123; if (i &gt; 0 &amp;&amp; i &lt;= 5) &#123; User u = new User(); u.age = (int) i; u.name = &quot;name1&quot;; u.totalBalance = new BigDecimal(1.1d); return u; &#125; else &#123; User u = new User(); u.age = (int) i; u.name = &quot;name2&quot;; u.totalBalance = new BigDecimal(2.2d); return u; &#125; &#125; // 2. 自定义数据类型作为输入参数 public String eval(User i) &#123; if (i.age &gt; 0 &amp;&amp; i.age &lt;= 5) &#123; User u = new User(); u.age = 1; u.name = &quot;name1&quot;; u.totalBalance = new BigDecimal(1.1d); return u.name; &#125; else &#123; User u = new User(); u.age = 2; u.name = &quot;name2&quot;; u.totalBalance = new BigDecimal(2.2d); return u.name; &#125; &#125;&#125; ⭐ 第三步，在 Flink SQL 中使用 12345678910111213141516171819202122232425262728293031323334-- 1. 创建 UDFCREATE FUNCTION user_scalar_func AS &#x27;flink.examples.sql._12_data_type._02_user_defined.UserScalarFunction&#x27;;-- 2. 创建数据源表CREATE TABLE source_table ( user_id BIGINT NOT NULL COMMENT &#x27;用户 id&#x27;) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;10&#x27;);-- 3. 创建数据汇表CREATE TABLE sink_table ( result_row_1 ROW&lt;age INT, name STRING, totalBalance DECIMAL(10, 2)&gt;, result_row_2 STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 4. SQL 查询语句INSERT INTO sink_tableselect -- 4.a. 用户自定义类型作为输出 user_scalar_func(user_id) as result_row_1, -- 4.b. 用户自定义类型作为输出及输入 user_scalar_func(user_scalar_func(user_id)) as result_row_2from source_table;-- 5. 查询结果+I[+I[9, name2, 2.20], name2]+I[+I[1, name1, 1.10], name1]+I[+I[5, name1, 1.10], name1] 2.4.SQL 动态表 &amp; 连续查询在小伙伴萌看下文之前，先看一下 2.4 节整体的思路，跟着博主思路走，会更清晰： ⭐ 先分析一下将 SQL 应用到流处理的思路 ⭐ SQL 应用于批处理已经很成熟了，通过对比流批处理在输入、数据处理、输出的异同点来分析出将 SQL 应用于流处理的核心要解决的问题点 ⭐ 分析如何使用 SQL 动态输入表 技术来将 输入数据流 映射到 SQL 中的输入表 ⭐ 分析如何使用 SQL 连续查询 技术来将 计算逻辑 映射到 SQL 中的运算语义 ⭐ 使用 SQL 动态表 &amp; 连续查询技术 两种技术方案来将 流式 SQL 实际应用到两个常见案例中 ⭐ 分析 SQL 连续查询 的两种类型：更新（Update）查询 &amp; 追加（Append）查询 ⭐ 分析如何使用 SQL 动态输出表 技术来将 输出数据流 映射到 SQL 中的输出表 博主认为读完本节你应该掌握： ⭐ SQL 动态输入表、SQL 动态输出表 ⭐ SQL 连续查询 的两种类型分别对应的查询场景及 SQL 语义 2.4.1.SQL 应用于流处理的思路在流式 SQL 诞生之前，所有的基于 SQL 的数据查询都是基于批数据的，没有将 SQL 应用到流数据处理这一说法。 那么如果我们想将 SQL 应用到流处理中，必然要站在巨人的肩膀（批数据处理的流程）上面进行，那么具体的分析思路如下： ⭐ 步骤一：先比较 批处理 与 流处理 的异同之处：如果有相同的部分，那么可以直接复用；不同之处才是我们需要重点克服和关注的。 ⭐ 步骤二：摘出 1 中说到的不同之处，分析如果要满足这个不同之处，目前有哪些技术是类似的 ⭐ 步骤三：再从这些类似的技术上进一步发展，以满足将 SQL 应用于流任务中 博主下文就会根据上述三个步骤来一步一步介绍 动态表 诞生的背景以及这个概念是如何诞生的。 2.4.2.流批处理的异同点及将 SQL 应用于流处理核心解决的问题首先对比一下常见的 批处理 和 流处理 中 数据源（输入表）、处理逻辑、数据汇（结果表） 的异同点。 - 输入表 处理逻辑 结果表 批处理 静态表：输入数据有限、是有界集合 批式计算：每次执行查询能够访问到完整的输入数据，然后计算，输出完整的结果数据 静态表：数据有限 流处理 动态表：输入数据无限，数据实时增加，并且源源不断 流式计算：执行时不能够访问到完整的输入数据，每次计算的结果都是一个中间结果 动态表：数据无限 对比上述流批处理之后，我们得到了要将 SQL 应用于流式任务的三个要解决的核心点： ⭐ SQL 输入表：分析如何将一个实时的，源源不断的输入流数据表示为 SQL 中的输入表。 ⭐ SQL 处理计算：分析将 SQL 查询逻辑翻译成什么样的底层处理技术才能够实时的处理流式输入数据，然后产出流式输出数据。 ⭐ SQL 输出表：分析如何将 SQL 查询输出的源源不断的流数据表示为一个 SQL 中的输出表。 将上面 3 个点总结一下，也就引出了本节的 动态表 和 连续查询 两种技术方案： ⭐ 动态表：源源不断的输入、输出流数据映射到 动态表 ⭐ 连续查询：实时处理输入数据，产出输出数据的实时处理技术 2.4.3.SQL 流处理的输入：输入流映射为 SQL 动态输入表动态表。这里的动态其实是相比于批处理的静态（有界）来说的。 ⭐ 静态表：应用于批处理数据中，静态表可以理解为是不随着时间实时进行变化的。一般都是一天、一小时的粒度新生成一个分区。 ⭐ 动态表：动态表是随时间实时进行变化的。是将 SQL 体系中表的概念应用到 Flink 上面的的核心点。 来看一个具体的案例，下图显示了点击事件流（左侧）如何转换为动态表（右侧）。当数据源生成更多的点击事件记录时，映射出来的动态表也会不断增长，这就是动态表的概念： 2.4.4.SQL 流处理的计算：实时处理底层技术 - SQL 连续查询连续查询。 部分高级关系数据库系统提供了一个称为物化视图（Materialized Views) 的特性。 物化视图其实就是一条 SQL 查询，就像常规的虚拟视图 VIEW 一样。但与虚拟视图不同的是，物化视图会缓存查询的结果，因此在请求访问视图时不需要对查询进行重新计算，可以直接获取物化视图的结果，小伙伴萌可以认为物化视图其实就是把结果缓存了下来。 举个例子：批处理中，如果以 Hive 天级别的物化视图来说，其实就是每天等数据源 ready 之后，调度物化视图的 SQL 执行然后产生新的结果提供服务。那么就可以认为一条表示了输入、处理、输出的 SQL 就是一个构建物化视图的过程。 映射到我们的流任务中，输入、处理逻辑、输出这一套流程也是一个物化视图的概念。相比批处理来说，流处理中，我们的数据源表的数据是源源不断的。那么从输入、处理、输出的整个物化视图的维护流程也必须是实时的。 因此我们就需要引入一种实时视图维护（Eager View Maintenance）的技术去做到：一旦更新了物化视图的数据源表就立即更新视图的结果，从而保证输出的结果也是最新的。 这种 实时视图维护（Eager View Maintenance）的技术就叫做 连续查询。 注意： ⭐ 连续查询（Continuous Query） 不断的消费动态输入表的的数据，不断的更新动态结果表的数据。 ⭐ 连续查询（Continuous Query） 的产出的结果 = 批处理模式在输入表的上执行的相同查询的结果。相同的 SQL，对应于同一个输入数据，虽然执行方式不同，但是流处理和批处理的结果是永远都会相同的。 2.4.5.SQL 流处理实际应用：动态表 &amp; 连续查询技术的两个实战案例总结前两节，动态表 &amp; 连续查询 两项技术在一条流 SQL 中的执行流程总共包含了三个步骤，如下图及总结所示： ⭐ 第一步：将数据输入流转换为 SQL 中的动态输入表。这里的转化其实就是指将输入流映射（绑定）为一个动态输入表。上图虽然分开画了，但是可以理解为一个东西。 ⭐ 第二步：在动态输入表上执行一个连续查询，然后生成一个新的动态结果表。 ⭐ 第三步：生成的动态结果表被转换回数据输出流。 我们实际介绍一个案例来看看其运行方式，以上文介绍到的点击事件流为例，点击事件流数据的字段如下： 12345[ user: VARCHAR, &#x2F;&#x2F; 用户名 cTime: TIMESTAMP, &#x2F;&#x2F; 访问 URL 的时间 url: VARCHAR &#x2F;&#x2F; 用户访问的 URL] ⭐ 第一步，将输入数据流映射为一个动态输入表。以下图为例，我们将点击事件流（图左）转换为动态表 (图右)。当点击数据源源不断的来到时，动态表的数据也会不断的增加。 ⭐ 第二步，在点击事件流映射的动态输入表上执行一个连续查询（Continuous Query），并生成一个新的动态输出表。 下面介绍两个查询的案例： 第一个查询：一个简单的 GROUP-BY COUNT 聚合查询，写过 SQL 的都不会陌生吧，这种应该都是最基础，最常用的对数据按照类别分组的方法。 如下图所示 group by 聚合的常用案例。 那么本案例中呢，是基于 clicks 表中 user 字段对 clicks 表（点击事件流）进行分组，来统计每一个 user 的访问的 URL 的数量。下面的图展示了当 clicks 输入表来了新数据（即表更新时），连续查询（Continuous Query） 的计算逻辑。 当查询开始，clicks 表(左侧)是空的。 ⭐ 当第一行数据被插入到 clicks 表时，连续查询（Continuous Query）开始计算结果数据。数据源表第一行数据 [Mary,./home] 输入后，会计算结果 [Mary, 1] 插入（insert）结果表。 ⭐ 当第二行 [Bob, ./cart] 插入到 clicks 表时，连续查询（Continuous Query）会计算结果 [Bob, 1]，并插入（insert）到结果表。 ⭐ 第三行 [Mary, ./prod?id=1] 输出时，会计算出[Mary, 2]（user 为 Mary 的数据总共来过两条，所以为 2），并更新（update）结果表，[Mary, 1] 更新成 [Mary, 2]。 ⭐ 最后，当第四行数据加入 clicks 表时，查询将第三行 [Liz, 1] 插入（insert）结果表中。 注意上述特殊标记出来的字体，可以看到连续查询对于结果的数据输出方式有两种： ⭐ 插入（insert）结果表 ⭐ 更新（update）结果表 大家对于 插入（insert）结果表 这件事都比较好理解，因为离线数据都只有插入这个概念。 但是 更新（update）结果表 就是离线处理中没有概念了。这就是连续查询中中比较重要一个概念。后文会介绍。 接下来介绍第二条查询语句。 第二条查询与第一条类似，但是 group by 中除了 user 字段之外，还 group by 了 tumble，其代表开了个滚动窗口（后面会详细说明滚动窗口的作用），然后计算 url 数量。 group by user，是按照类别（横向）给数据分组，group by tumble 滚动窗口是按时间粒度（纵向）给数据进行分组。如下图所示。 图形化一解释就很好理解了，两种都是对数据进行分组，一个是按照 类别 分组，另一种是按照 时间 分组。 与前面一样，左边显示了输入表 clicks。查询每小时持续计算结果并更新结果表。clicks 表有三列，user，cTime，url。其中 cTime 代表数据的时间戳，用于给数据按照时间粒度分组。 我们的滚动窗口的步长为 1 小时，即时间粒度上面的分组为 1 小时。其中时间戳在 12:00:00 - 12:59:59 之间有四条数据。13:00:00 - 13:59:59 有三条数据。14:00:00 - 14:59:59 之间有四条数据。 ⭐ 当 12:00:00 - 12:59:59 数据输入之后，1 小时的窗口，连续查询（Continuous Query）计算的结果如右图所示，将 [Mary, 3]，[Bob, 1] 插入（insert）结果表。 ⭐ 当 13:00:00 - 13:59:59 数据输入之后，1 小时的窗口，连续查询（Continuous Query）计算的结果如右图所示，将 [Bob, 1]，[Liz, 2] 插入（insert）结果表。 ⭐ 当 14:00:00 - 14:59:59 数据输入之后，1 小时的窗口，连续查询（Continuous Query）计算的结果如右图所示，将 [Mary, 1]，[Bob, 2]，[Liz, 1] 插入（insert）结果表。 而这个查询只有 插入（insert）结果表 这个行为。 2.4.6.SQL 连续查询的两种类型：更新（Update）查询 &amp; 追加（Append）查询虽然前一节的两个查询看起来非常相似（都计算分组进行计数聚合），但它们在一个重要方面不同： ⭐ 第一个查询（group by user），即（Update）查询：会更新先前输出的结果，即结果表流数据中包含 INSERT 和 UPDATE 数据。小伙伴萌可以理解为 group by user 这条语句当中，输入源的数据是一直有的，源源不断的，同一个 user 的数据之后可能还是会有的，因此可以认为此 SQL 的每次的输出结果都是一个中间结果，当同一个 user 下一条数据到来的时候，就要用新结果把上一次的产出中间结果（旧结果）给 UPDATE 了。所以这就是 UPDATE 查询的由来（其中 INSERT 就是第一条数据到来的时候，没有之前的中间结果，所以是 INSERT）。 ⭐ 第二个查询（group by user, tumble(xxx)），即（Append）查询：只追加到结果表，即结果表流数据中只包含 INSERT 的数据。小伙伴萌可以理解为虽然 group by user, tumble(xxx) 上游也是一个源源不断的数据，但是这个查询本质上是对时间上的划分，而时间都是越变越大的，当前这个滚动窗口结束之后，后面来的数据的时间都会比这个滚动窗口的结束时间大，都归属于之后的窗口了，当前这个滚动窗口的结果数据就不会再改变了，因此这条查询只有 INSERT 数据，即一个 Append 查询。 上面是 Flink SQL 连续查询处理机制上面的两类查询方式。我们可以发现连续查询的处理机制不一样，产出到结果表中的结果数据也是不一样的。针对上面两种结果表的更新方式，Flink SQL 提出了 changelog 表的概念来进行兼容。 changelog 表这个概念其实就和 MySQL binlog 是一样的。会包含 INSERT、UPDATE、DELETE 三种数据，通过这三种数据的处理来描述实时处理技术对于动态表的变更： ⭐ changelog 表：即第一个查询的输出表，输出结果数据不但会追加，还会发生更新 ⭐ changelog insert-only 表：即第二个查询的输出表，输出结果数据只会追加，不会发生更新 2.4.7.SQL 流处理的输出：动态输出表转化为输出数据可以看到我们的标题都是随着一个 SQL 的生命周期的。从 输入流映射为 SQL 动态输入表、实时处理底层技术 - SQL 连续查询 到本小节的 SQL 动态输出表转化为输出数据。都是有逻辑关系的。 我们上面介绍到了 连续查询（Continuous Query） 的输出结果表是一个 changelog。其可以像普通数据库表一样通过 INSERT、UPDATE 和 DELETE 来不断修改。 它可能是一个只有一行、不断更新 changelog 表，也可能是一个 insert-only 的 changelog 表，没有 UPDATE 和 DELETE 修改，或者介于两者之间的其他表。 在将动态表转换为流或将其写入外部系统时，需要对这些不同状态的数据进行编码。Flink 的 Table API 和 SQL API 支持三种方式来编码一个动态表的变化: ⭐ Append-only 流： 输出的结果只有 INSERT 操作的数据。 ⭐ Retract 流： ⭐ Retract 流包含两种类型的 message： add messages 和 retract messages 。其将 INSERT 操作编码为 add message、将 DELETE 操作编码为 retract message、将 UPDATE 操作编码为更新先前行的 retract message 和更新（新）行的 add message，从而将动态表转换为 retract 流。 ⭐ Retract 流写入到输出结果表的数据如下图所示，有 -，+ 两种，分别 - 代表撤回旧数据，+ 代表输出最新的数据。这两种数据最终都会写入到输出的数据引擎中。 ⭐ 如果下游还有任务去消费这条流的话，要注意需要正确处理 -，+ 两种数据，防止数据计算重复或者错误。 ⭐ Upsert 流： ⭐ Upsert 流包含两种类型的 message： upsert messages 和 delete messages。转换为 upsert 流的动态表需要唯一键（唯一键可以由多个字段组合而成）。其会将 INSERT 和 UPDATE 操作编码为 upsert message，将 DELETE 操作编码为 delete message。 ⭐ Upsert 流写入到输出结果表的数据如下图所示，每次输出的结果都是当前每一个 user 的最新结果数据，不会有 Retract 中的 - 回撤数据。 ⭐ 如果下游还有一个任务去消费这条流的话，消费流的算子需要知道唯一键（即 user），以便正确地根据唯一键（user）去拿到每一个 user 当前最新的状态。其与 retract 流的主要区别在于 UPDATE 操作是用单个 message 编码的，因此效率更高。下图显示了将动态表转换为 upsert 流的过程。 2.4.8.补充知识：SQL 与关系代数小伙伴萌会问到，关系代数是啥东西？ 其实关系代数就是对于数据集（即表）的一系列的 操作（即查询语句）。常见关系代数有： ⭐ 那么 SQL 和关系代数是啥关系呢？ SQL 就是能够表示关系代数一种面向用户的接口：即用户能使用 SQL 表达关系代数的处理逻辑，也就是我们可以用 SQL 去在表（数据集）上执行我们的业务逻辑操作（关系代数操作）。 2.5.SQL 的时间属性在小伙伴萌看下文之前，先看一下 2.5 节整体的思路，跟着博主思路走： ⭐ 与离线处理中常见的时间分区字段一样，在实时处理中，时间属性也是一个核心概念。Flink 支持 处理时间、事件时间、摄入时间 三种时间语义。 ⭐ 分别介绍三种时间语义的应用场景及案例。三种时间在生产环境的使用频次 事件时间（SQL 常用） &gt; 处理时间（SQL 几乎不用，DataStream 少用） &gt; 摄入时间（不用） 2.5.1.Flink 三种时间属性简介 ⭐ 事件时间：指的是数据本身携带的时间，这个时间是在事件产生时的时间，而且在 Flink SQL 触发计算时，也使用数据本身携带的时间。这就叫做 事件时间。目前生产环境中用的最多。 ⭐ 处理时间：指的是具体算子计算数据执行时的机器时间（例如在算子中 Java 取 System.currentTimeMillis()) ），在生产环境中用的次多。 ⭐ 摄入时间：指的是数据从数据源进入 Flink 的时间。摄入时间用的最少，可以说基本不使用。 小伙伴萌要注意到： ⭐ 上述的三种时间概念不是由于有了数据而诞生的，而是有了 Flink 之后根据实际的应用场景而诞生的。以事件时间举个例子，如果只是数据携带了时间，Flink 也消费了这个数据，但是在 Flink 中没有使用数据的这个时间作为计算的触发条件，也不能把这个 Flink 任务叫做事件时间的任务。 ⭐ 其次，要认识到，一般一个 Flink 任务只会有一个时间属性，所以时间属性通常认为是一个任务粒度的。举例：我们可以说 A 任务是事件时间语义的任务，B 任务是处理时间语义的任务。当然了，一个任务也可以存在多个时间属性。 2.5.2.Flink 三种时间属性的应用场景讲到这里，xdm 会问，博主上面写的 3 种时间属性到底对我们的任务有啥影响呢？3 种时间属性的应用场景是啥？ 先说结论，在 Flink 中时间的作用： ⭐ 主要体现在包含时间窗口的计算中：用于标识任务的时间进度，来判断是否需要触发窗口的计算。比如常用的滚动窗口、滑动窗口等都需要时间推动触发。这些窗口的应用场景后续会详细介绍。 ⭐ 次要体现在自定义时间语义的计算中：举个例子，比如用户可以自定义每隔 10s 的本地时间，或者消费到的数据的时间戳每增大 10s，就把计算结果输出一次，时间在此类应用中也是一种标识任务进度的作用。 博主以 滚动窗口 的聚合任务为例来介绍一下事件时间和处理时间的对比区别。 ⭐ 事件时间案例：还是以之前的 clicks 表拿来举例。 上面这个案例的窗口大小是 1 小时，需求方需要按照用户点击时间戳 cTime 划分数据（划分滚动窗口），然后计算出 count 聚合结果（这样计算能反映出事件的真实发生时间），那么就需要把 cTime 设置为窗口的划分时间戳，即代码中 tumble(cTime, interval &#39;1&#39; hour)。 上面这种就叫做事件时间。即用数据中自带的时间戳进行窗口的划分（点击操作真实的发生时间）。 后续 Flink SQL 任务在运行的过程中也会实际按照 cTime 的当前时间作为一小时窗口结束触发条件并计算一个小时窗口内的数据。 ⭐ 处理时间案例：还是以之前的 clicks 表拿来举例。 还是上面那个案例，但是这次需求方不需要按照数据上的时间戳划分数据（划分滚动窗口），只需要数据来了之后， 在 Flink 机器上的时间作为一小时窗口结束的书法条件并计算。 那么这种触发机制就是处理时间。 ⭐ 摄入时间案例：在 Flink 从外部数据源读取到数据时，给这条数据带上的当前数据源算子的本地时间戳。下游可以用这个时间戳进行窗口聚合，不过这种几乎不使用。 2.5.3.SQL 指定时间属性的两种方式如果要满足 Flink SQL 时间窗口类的聚合操作，SQL 或 Table API 中的 数据源表 就需要提供时间属性（相当于我们把这个时间属性在 数据源表 上面进行声明），以及支持时间相关的操作。 那么来看看 Flink SQL 为我们提供的两种指定时间戳的方式： ⭐ CREATE TABLE DDL 创建表的时候指定 ⭐ 可以在 DataStream 中指定，在后续的 DataStream 转的 Table 中使用 一旦时间属性定义好，它就可以像普通列一样使用，也可以在时间相关的操作中使用。 2.5.4.SQL 事件时间案例来看看 Flink 中如何指定事件时间。 ⭐ CREATE TABLE DDL 指定时间戳的方式。 123456789101112131415CREATE TABLE user_actions ( user_name STRING, data STRING, user_action_time TIMESTAMP(3), -- 使用下面这句来将 user_action_time 声明为事件时间，并且声明 watermark 的生成规则，即 user_action_time 减 5 秒 -- 事件时间列的字段类型必须是 TIMESTAMP 或者 TIMESTAMP_LTZ 类型 WATERMARK FOR user_action_time AS user_action_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( ...);SELECT TUMBLE_START(user_action_time, INTERVAL &#x27;10&#x27; MINUTE), COUNT(DISTINCT user_name)FROM user_actions-- 然后就可以在窗口算子中使用 user_action_timeGROUP BY TUMBLE(user_action_time, INTERVAL &#x27;10&#x27; MINUTE); 从上面这条语句可以看到，如果想使用事件时间，那么我们的时间戳类型必须是 TIMESTAMP 或者 TIMESTAMP_LTZ 类型。很多小伙伴会想到，我们的时间戳一般不都是秒或者是毫秒（BIGINT 类型）嘛，那这种情况怎么办？ 解决方案必须要有啊。如下。 1234567891011121314151617CREATE TABLE user_actions ( user_name STRING, data STRING, -- 1. 这个 ts 就是常见的毫秒级别时间戳 ts BIGINT, -- 2. 将毫秒时间戳转换成 TIMESTAMP_LTZ 类型 time_ltz AS TO_TIMESTAMP_LTZ(ts, 3), -- 3. 使用下面这句来将 user_action_time 声明为事件时间，并且声明 watermark 的生成规则，即 user_action_time 减 5 秒 -- 事件时间列的字段类型必须是 TIMESTAMP 或者 TIMESTAMP_LTZ 类型 WATERMARK FOR time_ltz AS time_ltz - INTERVAL &#x27;5&#x27; SECOND) WITH ( ...);SELECT TUMBLE_START(time_ltz, INTERVAL &#x27;10&#x27; MINUTE), COUNT(DISTINCT user_name)FROM user_actionsGROUP BY TUMBLE(time_ltz, INTERVAL &#x27;10&#x27; MINUTE); ⭐ DataStream 中指定事件时间。 之前介绍了 Table 和 DataStream 可以互转，那么 Flink 也提供了一个能力，就是在 Table 转为 DataStream 时，指定时间戳字段。如下案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class DataStreamSourceEventTimeTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode() .build(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings); // 1. 分配 watermark DataStream&lt;Row&gt; r = env.addSource(new UserDefinedSource()) .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;Row&gt;(Time.minutes(0L)) &#123; @Override public long extractTimestamp(Row element) &#123; return (long) element.getField(&quot;f2&quot;); &#125; &#125;); // 2. 使用 f2.rowtime 的方式将 f2 字段指为事件时间时间戳 Table sourceTable = tEnv.fromDataStream(r, &quot;f0, f1, f2.rowtime&quot;); tEnv.createTemporaryView(&quot;source_table&quot;, sourceTable); // 3. 在 tumble window 中使用 f2 String tumbleWindowSql = &quot;SELECT TUMBLE_START(f2, INTERVAL &#x27;5&#x27; SECOND), COUNT(DISTINCT f0)\\n&quot; + &quot;FROM source_table\\n&quot; + &quot;GROUP BY TUMBLE(f2, INTERVAL &#x27;5&#x27; SECOND)&quot; ; Table resultTable = tEnv.sqlQuery(tumbleWindowSql); tEnv.toDataStream(resultTable, Row.class).print(); env.execute(); &#125; private static class UserDefinedSource implements SourceFunction&lt;Row&gt;, ResultTypeQueryable&lt;Row&gt; &#123; private volatile boolean isCancel; @Override public void run(SourceContext&lt;Row&gt; sourceContext) throws Exception &#123; int i = 0; while (!this.isCancel) &#123; sourceContext.collect(Row.of(&quot;a&quot; + i, &quot;b&quot;, System.currentTimeMillis())); Thread.sleep(10L); i++; &#125; &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; @Override public TypeInformation&lt;Row&gt; getProducedType() &#123; return new RowTypeInfo(TypeInformation.of(String.class), TypeInformation.of(String.class), TypeInformation.of(Long.class)); &#125; &#125;&#125; 2.5.5.SQL 处理时间案例来看看 Flink SQL 中如何指定处理时间。 ⭐ CREATE TABLE DDL 指定时间戳的方式。 12345678910111213CREATE TABLE user_actions ( user_name STRING, data STRING, -- 使用下面这句来将 user_action_time 声明为处理时间 user_action_time AS PROCTIME()) WITH ( ...);SELECT TUMBLE_START(user_action_time, INTERVAL &#x27;10&#x27; MINUTE), COUNT(DISTINCT user_name)FROM user_actions-- 然后就可以在窗口算子中使用 user_action_timeGROUP BY TUMBLE(user_action_time, INTERVAL &#x27;10&#x27; MINUTE); ⭐ DataStream 中指定处理时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class DataStreamSourceProcessingTimeTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode() .build(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings); // 1. 分配 watermark DataStream&lt;Row&gt; r = env.addSource(new UserDefinedSource()); // 2. 使用 proctime.proctime 的方式将 f2 字段指为处理时间时间戳 Table sourceTable = tEnv.fromDataStream(r, &quot;f0, f1, f2, proctime.proctime&quot;); tEnv.createTemporaryView(&quot;source_table&quot;, sourceTable); // 3. 在 tumble window 中使用 f2 String tumbleWindowSql = &quot;SELECT TUMBLE_START(proctime, INTERVAL &#x27;5&#x27; SECOND), COUNT(DISTINCT f0)\\n&quot; + &quot;FROM source_table\\n&quot; + &quot;GROUP BY TUMBLE(proctime, INTERVAL &#x27;5&#x27; SECOND)&quot; ; Table resultTable = tEnv.sqlQuery(tumbleWindowSql); tEnv.toDataStream(resultTable, Row.class).print(); env.execute(); &#125; private static class UserDefinedSource implements SourceFunction&lt;Row&gt;, ResultTypeQueryable&lt;Row&gt; &#123; private volatile boolean isCancel; @Override public void run(SourceContext&lt;Row&gt; sourceContext) throws Exception &#123; int i = 0; while (!this.isCancel) &#123; sourceContext.collect(Row.of(&quot;a&quot; + i, &quot;b&quot;, System.currentTimeMillis())); Thread.sleep(10L); i++; &#125; &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; @Override public TypeInformation&lt;Row&gt; getProducedType() &#123; return new RowTypeInfo(TypeInformation.of(String.class), TypeInformation.of(String.class), TypeInformation.of(Long.class)); &#125; &#125;&#125; 2.6.SQL 时区问题2.6.1.SQL 时区解决的问题首先说一下这个问题的背景： 大家想一下离线 Hive 环境中，有遇到过时区时区相关的问题吗？ 至少博主目前没有碰到过，因为这个问题在底层的数据集成系统都已经给解决了，小伙伴萌拿到手的 ODS 层表都是已经按照所在地区的时区给格式化好的了。 举个例子：小伙伴萌看到日期分区为 2022-01-01 的 Hive 表时，可以默认认为该分区中的数据就对应到你所在地区的时区的 2022-01-01 日的数据。 但是 Flink 中时区问题要特别引起关注，不加小心就会误用。 而本节 SQL 时区旨在帮助大家了解到以下两个场景的问题： ⭐ 在 1.13 之前，DDL create table 中使用 PROCTIME() 指定处理时间列时，返回值类型为 TIMESTAMP(3) 类型，而 TIMESTAMP(3) 是不带任何时区信息的，默认为 UTC 时间（0 时区）。 ⭐ 使用 StreamTableEnvironment::createTemporaryView 将 DataStream 转为 Table 时，注册处理时间（proctime.proctime）、事件时间列（rowtime.rowtime）时，两列时间类型也为 TIMESTAMP(3) 类型，不带时区信息。 而以上两个场景就会导致： ⭐ 在北京时区的用户使用 TIMESTAMP(3) 类型的时间列开最常用的 1 天的窗口时，划分出来的窗口范围是北京时间的 [2022-01-01 08:00:00, 2022-01-02 08:00:00]，而不是北京时间的 [2022-01-01 00:00:00, 2022-01-02 00:00:00]。因为 TIMESTAMP(3) 是默认的 UTC 时间，即 0 时区。 ⭐ 北京时区的用户将 TIMESTAMP(3) 类型时间属性列转为 STRING 类型的数据展示时，也是 UTC 时区的，而不是北京时间的。 因此充分了解本节的知识内容可以很好的帮你避免时区问题错误。 2.6.1.SQL 时间类型 ⭐ Flink SQL 支持 TIMESTAMP（不带时区信息的时间）、TIMESTAMP_LTZ（带时区信息的时间） ⭐ TIMESTAMP（不带时区信息的时间）：是通过一个 年， 月， 日， 小时， 分钟， 秒 和 小数秒 的字符串来指定。举例：1970-01-01 00:00:04.001。 ⭐ 为什么要使用字符串来指定呢？因为此种类型不带时区信息，所以直接用一个字符串指定就好了 ⭐ 那 TIMESTAMP 字符串的时间代表的是什么时区的时间呢？UTC 时区，也就是默认 0 时区，对应中国北京是东八区 ⭐ TIMESTAMP_LTZ（带时区信息的时间）：没有字符串来指定，而是通过 java 标准 epoch 时间 1970-01-01T00:00:00Z 开始计算的毫秒数。举例：1640966400000 ⭐ 其时区信息是怎么指定的呢？是通过本次任务中的时区配置参数 table.local-time-zone 设置的 ⭐ 时间戳本身也不带有时区信息，为什么要使用时间戳来指定呢？就是因为时间戳不带有时区信息，所以我们通过配置 table.local-time-zone 时区参数之后，就能将一个不带有时区信息的时间戳转换为带有时区信息的字符串了。举例：table.local-time-zone 为 Asia/Shanghai 时，4001 时间戳转化为字符串的效果是 1970-01-01 08:00:04.001。 todo 如果你还对时区问题有疑惑，可以参考博主写的一篇时区相关的文章。 2.6.2.时区参数生效的 SQL 时间函数以下 SQL 中的时间函数都会受到时区参数的影响，从而做到最后显示给用户的时间、窗口的划分都按照用户设置时区之内的时间。 ⭐ LOCALTIME ⭐ LOCALTIMESTAMP ⭐ CURRENT_DATE ⭐ CURRENT_TIME ⭐ CURRENT_TIMESTAMP ⭐ CURRENT_ROW_TIMESTAMP() ⭐ NOW() ⭐ PROCTIME()：其中 PROCTIME() 在 1.13 版本及之后版本，返回值类型是 TIMESTAMP_LTZ(3) 在 Flink SQL client 中执行结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Flink SQL&gt; SET sql-client.execution.result-mode=tableau;Flink SQL&gt; CREATE VIEW MyView1 AS SELECT LOCALTIME, LOCALTIMESTAMP, CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_ROW_TIMESTAMP(), NOW(), PROCTIME();Flink SQL&gt; DESC MyView1;+------------------------+-----------------------------+-------+-----+--------+-----------+| name | type | null | key | extras | watermark |+------------------------+-----------------------------+-------+-----+--------+-----------+| LOCALTIME | TIME(0) | false | | | || LOCALTIMESTAMP | TIMESTAMP(3) | false | | | || CURRENT_DATE | DATE | false | | | || CURRENT_TIME | TIME(0) | false | | | || CURRENT_TIMESTAMP | TIMESTAMP_LTZ(3) | false | | | ||CURRENT_ROW_TIMESTAMP() | TIMESTAMP_LTZ(3) | false | | | || NOW() | TIMESTAMP_LTZ(3) | false | | | || PROCTIME() | TIMESTAMP_LTZ(3) *PROCTIME* | false | | | |+------------------------+-----------------------------+-------+-----+--------+-----------+Flink SQL&gt; SET table.local-time-zone=UTC;Flink SQL&gt; SELECT * FROM MyView1;+-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+| LOCALTIME | LOCALTIMESTAMP | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_ROW_TIMESTAMP() | NOW() | PROCTIME() |+-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+| 15:18:36 | 2021-04-15 15:18:36.384 | 2021-04-15 | 15:18:36 | 2021-04-15 15:18:36.384 | 2021-04-15 15:18:36.384 | 2021-04-15 15:18:36.384 | 2021-04-15 15:18:36.384 |+-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+Flink SQL&gt; SET table.local-time-zone=Asia/Shanghai;Flink SQL&gt; SELECT * FROM MyView1;+-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+| LOCALTIME | LOCALTIMESTAMP | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_ROW_TIMESTAMP() | NOW() | PROCTIME() |+-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+| 23:18:36 | 2021-04-15 23:18:36.384 | 2021-04-15 | 23:18:36 | 2021-04-15 23:18:36.384 | 2021-04-15 23:18:36.384 | 2021-04-15 23:18:36.384 | 2021-04-15 23:18:36.384 |+-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+Flink SQL&gt; CREATE VIEW MyView2 AS SELECT TO_TIMESTAMP_LTZ(4001, 3) AS ltz, TIMESTAMP &#x27;1970-01-01 00:00:01.001&#x27; AS ntz;Flink SQL&gt; DESC MyView2;+------+------------------+-------+-----+--------+-----------+| name | type | null | key | extras | watermark |+------+------------------+-------+-----+--------+-----------+| ltz | TIMESTAMP_LTZ(3) | true | | | || ntz | TIMESTAMP(3) | false | | | |+------+------------------+-------+-----+--------+-----------+Flink SQL&gt; SET table.local-time-zone=UTC;Flink SQL&gt; SELECT * FROM MyView2;+-------------------------+-------------------------+| ltz | ntz |+-------------------------+-------------------------+| 1970-01-01 00:00:04.001 | 1970-01-01 00:00:01.001 |+-------------------------+-------------------------+Flink SQL&gt; SET table.local-time-zone=Asia/Shanghai;Flink SQL&gt; SELECT * FROM MyView2;+-------------------------+-------------------------+| ltz | ntz |+-------------------------+-------------------------+| 1970-01-01 08:00:04.001 | 1970-01-01 00:00:01.001 |+-------------------------+-------------------------+Flink SQL&gt; CREATE VIEW MyView3 AS SELECT ltz, CAST(ltz AS TIMESTAMP(3)), CAST(ltz AS STRING), ntz, CAST(ntz AS TIMESTAMP_LTZ(3)) FROM MyView2;Flink SQL&gt; DESC MyView3;+-------------------------------+------------------+-------+-----+--------+-----------+| name | type | null | key | extras | watermark |+-------------------------------+------------------+-------+-----+--------+-----------+| ltz | TIMESTAMP_LTZ(3) | true | | | || CAST(ltz AS TIMESTAMP(3)) | TIMESTAMP(3) | true | | | || CAST(ltz AS STRING) | STRING | true | | | || ntz | TIMESTAMP(3) | false | | | || CAST(ntz AS TIMESTAMP_LTZ(3)) | TIMESTAMP_LTZ(3) | false | | | |+-------------------------------+------------------+-------+-----+--------+-----------+Flink SQL&gt; SELECT * FROM MyView3;+-------------------------+---------------------------+-------------------------+-------------------------+-------------------------------+| ltz | CAST(ltz AS TIMESTAMP(3)) | CAST(ltz AS STRING) | ntz | CAST(ntz AS TIMESTAMP_LTZ(3)) |+-------------------------+---------------------------+-------------------------+-------------------------+-------------------------------+| 1970-01-01 08:00:04.001 | 1970-01-01 08:00:04.001 | 1970-01-01 08:00:04.001 | 1970-01-01 00:00:01.001 | 1970-01-01 00:00:01.001 |+-------------------------+---------------------------+-------------------------+-------------------------+-------------------------------+ 2.6.3.事件时间和时区应用案例这里分两类，分别是 TIMESTAMP（不带时区信息的时间）、TIMESTAMP_LTZ（带时区信息的时间） 的事件时间 Flink SQL 任务 ⭐ TIMESTAMP（不带时区信息的时间） 123456789101112131415161718192021222324252627282930313233Flink SQL&gt; CREATE TABLE MyTable2 ( item STRING, price DOUBLE, ts TIMESTAMP(3), -- TIMESTAMP 类型的时间戳 WATERMARK FOR ts AS ts - INTERVAL &#x27;10&#x27; SECOND ) WITH ( &#x27;connector&#x27; = &#x27;socket&#x27;, &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, &#x27;port&#x27; = &#x27;9999&#x27;, &#x27;format&#x27; = &#x27;csv&#x27; );Flink SQL&gt; CREATE VIEW MyView4 AS SELECT TUMBLE_START(ts, INTERVAL &#x27;10&#x27; MINUTES) AS window_start, TUMBLE_END(ts, INTERVAL &#x27;10&#x27; MINUTES) AS window_end, TUMBLE_ROWTIME(ts, INTERVAL &#x27;10&#x27; MINUTES) as window_rowtime, item, MAX(price) as max_price FROM MyTable2 GROUP BY TUMBLE(ts, INTERVAL &#x27;10&#x27; MINUTES), item;Flink SQL&gt; DESC MyView4;+----------------+------------------------+------+-----+--------+-----------+| name | type | null | key | extras | watermark |+----------------+------------------------+------+-----+--------+-----------+| window_start | TIMESTAMP(3) | true | | | || window_end | TIMESTAMP(3) | true | | | || window_rowtime | TIMESTAMP(3) *ROWTIME* | true | | | || item | STRING | true | | | || max_price | DOUBLE | true | | | |+----------------+------------------------+------+-----+--------+-----------+ 将数据写入到 MyTable2 中： script1234567&gt; nc -lk 9999A,1.1,2021-04-15 14:01:00B,1.2,2021-04-15 14:02:00A,1.8,2021-04-15 14:03:00 B,2.5,2021-04-15 14:04:00C,3.8,2021-04-15 14:05:00 C,3.8,2021-04-15 14:11:00 最终结果如下： 123456789101112131415161718192021Flink SQL&gt; SET table.local-time-zone=UTC; Flink SQL&gt; SELECT * FROM MyView4;+-------------------------+-------------------------+-------------------------+------+-----------+| window_start | window_end | window_rowtime | item | max_price |+-------------------------+-------------------------+-------------------------+------+-----------+| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | A | 1.8 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | B | 2.5 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | C | 3.8 |+-------------------------+-------------------------+-------------------------+------+-----------+Flink SQL&gt; SET table.local-time-zone=Asia/Shanghai; Flink SQL&gt; SELECT * FROM MyView4;+-------------------------+-------------------------+-------------------------+------+-----------+| window_start | window_end | window_rowtime | item | max_price |+-------------------------+-------------------------+-------------------------+------+-----------+| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | A | 1.8 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | B | 2.5 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | C | 3.8 |+-------------------------+-------------------------+-------------------------+------+-----------+ 通过上述结果可见，使用 TIMESTAMP（不带时区信息的时间） 进开窗，在 UTC 时区下的计算结果与在 Asia/Shanghai 时区下计算的窗口开始时间，窗口结束时间和窗口的时间是相同的。 ⭐ TIMESTAMP_LTZ（带时区信息的时间） 12345678910111213141516171819202122232425262728293031323334Flink SQL&gt; CREATE TABLE MyTable3 ( item STRING, price DOUBLE, ts BIGINT, -- long 类型的时间戳 ts_ltz AS TO_TIMESTAMP_LTZ(ts, 3), -- 转为 TIMESTAMP_LTZ 类型的时间戳 WATERMARK FOR ts_ltz AS ts_ltz - INTERVAL &#x27;10&#x27; SECOND ) WITH ( &#x27;connector&#x27; = &#x27;socket&#x27;, &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, &#x27;port&#x27; = &#x27;9999&#x27;, &#x27;format&#x27; = &#x27;csv&#x27; );Flink SQL&gt; CREATE VIEW MyView5 AS SELECT TUMBLE_START(ts_ltz, INTERVAL &#x27;10&#x27; MINUTES) AS window_start, TUMBLE_END(ts_ltz, INTERVAL &#x27;10&#x27; MINUTES) AS window_end, TUMBLE_ROWTIME(ts_ltz, INTERVAL &#x27;10&#x27; MINUTES) as window_rowtime, item, MAX(price) as max_price FROM MyTable3 GROUP BY TUMBLE(ts_ltz, INTERVAL &#x27;10&#x27; MINUTES), item;Flink SQL&gt; DESC MyView5;+----------------+----------------------------+-------+-----+--------+-----------+| name | type | null | key | extras | watermark |+----------------+----------------------------+-------+-----+--------+-----------+| window_start | TIMESTAMP(3) | false | | | || window_end | TIMESTAMP(3) | false | | | || window_rowtime | TIMESTAMP_LTZ(3) *ROWTIME* | true | | | || item | STRING | true | | | || max_price | DOUBLE | true | | | |+----------------+----------------------------+-------+-----+--------+-----------+ 将数据写入 MyTable3： script123456A,1.1,1618495260000 # 对应到 UTC 时区的时间为 2021-04-15 14:01:00B,1.2,1618495320000 # 对应到 UTC 时区的时间为 2021-04-15 14:02:00A,1.8,1618495380000 # 对应到 UTC 时区的时间为 2021-04-15 14:03:00B,2.5,1618495440000 # 对应到 UTC 时区的时间为 2021-04-15 14:04:00C,3.8,1618495500000 # 对应到 UTC 时区的时间为 2021-04-15 14:05:00 C,3.8,1618495860000 # 对应到 UTC 时区的时间为 2021-04-15 14:11:00 最终结果如下： 123456789101112131415161718192021Flink SQL&gt; SET table.local-time-zone=UTC; Flink SQL&gt; SELECT * FROM MyView5;+-------------------------+-------------------------+-------------------------+------+-----------+| window_start | window_end | window_rowtime | item | max_price |+-------------------------+-------------------------+-------------------------+------+-----------+| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | A | 1.8 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | B | 2.5 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 | C | 3.8 |+-------------------------+-------------------------+-------------------------+------+-----------+Flink SQL&gt; SET table.local-time-zone=Asia/Shanghai; Flink SQL&gt; SELECT * FROM MyView5;+-------------------------+-------------------------+-------------------------+------+-----------+| window_start | window_end | window_rowtime | item | max_price |+-------------------------+-------------------------+-------------------------+------+-----------+| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:09:59.999 | A | 1.8 || 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:09:59.999 | B | 2.5 || 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:09:59.999 | C | 3.8 |+-------------------------+-------------------------+-------------------------+------+-----------+ 通过上述结果可见，使用 TIMESTAMP_LTZ（带时区信息的时间） 进开窗，在 UTC 时区下的计算结果与在 Asia/Shanghai 时区下计算的窗口开始时间，窗口结束时间和窗口的时间是不同的，都是按照时区进行格式化的。 2.6.4.处理时间和时区应用案例Flink SQL 定义处理时间属性列是通过 PROCTIME() 函数来指定的，其返回值类型是 TIMESTAMP_LTZ。 注意： 在 Flink 1.13 之前，PROCTIME() 函数返回类型是 TIMESTAMP，返回值是 UTC 时区的时间戳，例如，上海时间显示为 2021-03-01 12:00:00 时，PROCTIME() 返回值显示 2021-03-01 04:00:00，我们进行使用是错误的。Flink 1.13 修复了这个问题，使用 TIMESTAMP_LTZ 作为 PROCTIME() 的返回类型，这样 Flink 就会自动获取当前时区信息，然后进行处理，不需要用户再进行时区的格式化处理了。 如下案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Flink SQL&gt; SET table.local-time-zone=UTC;Flink SQL&gt; SELECT PROCTIME();+-------------------------+| PROCTIME() |+-------------------------+| 2021-04-15 14:48:31.387 |+-------------------------+Flink SQL&gt; SET table.local-time-zone=Asia/Shanghai;Flink SQL&gt; SELECT PROCTIME();+-------------------------+| PROCTIME() |+-------------------------+| 2021-04-15 22:48:31.387 |+-------------------------+Flink SQL&gt; CREATE TABLE MyTable1 ( item STRING, price DOUBLE, proctime as PROCTIME() ) WITH ( &#x27;connector&#x27; = &#x27;socket&#x27;, &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, &#x27;port&#x27; = &#x27;9999&#x27;, &#x27;format&#x27; = &#x27;csv&#x27; );Flink SQL&gt; CREATE VIEW MyView3 AS SELECT TUMBLE_START(proctime, INTERVAL &#x27;10&#x27; MINUTES) AS window_start, TUMBLE_END(proctime, INTERVAL &#x27;10&#x27; MINUTES) AS window_end, TUMBLE_PROCTIME(proctime, INTERVAL &#x27;10&#x27; MINUTES) as window_proctime, item, MAX(price) as max_price FROM MyTable1 GROUP BY TUMBLE(proctime, INTERVAL &#x27;10&#x27; MINUTES), item;Flink SQL&gt; DESC MyView3;+-----------------+-----------------------------+-------+-----+--------+-----------+| name | type | null | key | extras | watermark |+-----------------+-----------------------------+-------+-----+--------+-----------+| window_start | TIMESTAMP(3) | false | | | || window_end | TIMESTAMP(3) | false | | | || window_proctime | TIMESTAMP_LTZ(3) *PROCTIME* | false | | | || item | STRING | true | | | || max_price | DOUBLE | true | | | |+-----------------+-----------------------------+-------+-----+--------+-----------+ 将数据写入到 MyTable1 中： script123456&gt; nc -lk 9999A,1.1B,1.2A,1.8B,2.5C,3.8 其输出结果如下： 123456789101112131415161718192021Flink SQL&gt; SET table.local-time-zone=UTC;Flink SQL&gt; SELECT * FROM MyView3;+-------------------------+-------------------------+-------------------------+------+-----------+| window_start | window_end | window_procime | item | max_price |+-------------------------+-------------------------+-------------------------+------+-----------+| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:10:00.005 | A | 1.8 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:10:00.007 | B | 2.5 || 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:10:00.007 | C | 3.8 |+-------------------------+-------------------------+-------------------------+------+-----------+Flink SQL&gt; SET table.local-time-zone=Asia/Shanghai;Flink SQL&gt; SELECT * FROM MyView3;+-------------------------+-------------------------+-------------------------+------+-----------+| window_start | window_end | window_procime | item | max_price |+-------------------------+-------------------------+-------------------------+------+-----------+| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:10:00.005 | A | 1.8 || 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:10:00.007 | B | 2.5 || 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:10:00.007 | C | 3.8 |+-------------------------+-------------------------+-------------------------+------+-----------+ 通过上述结果可见，使用处理时间进行开窗，在 UTC 时区下的计算结果与在 Asia/Shanghai 时区下计算的窗口开始时间，窗口结束时间和窗口的时间是不同的，都是按照时区进行格式化的。 2.6.5.SQL 时间函数返回在流批任务中的异同以下函数： ⭐ LOCALTIME ⭐ LOCALTIMESTAMP ⭐ CURRENT_DATE ⭐ CURRENT_TIME ⭐ CURRENT_TIMESTAMP ⭐ NOW() 在 Streaming 模式下这些函数是每条记录都会计算一次，但在 Batch 模式下，只会在 query 开始时计算一次，所有记录都使用相同的时间结果。 以下时间函数无论是在 Streaming 模式还是 Batch 模式下，都会为每条记录计算一次结果： ⭐ CURRENT_ROW_TIMESTAMP() ⭐ PROCTIME() 3.SQL 语法篇在介绍小伙伴萌最关心的 Flink SQL 语法之前，博主先介绍一下本节的思路，希望小伙伴萌能随着博主的思路进行学习、理解。 todo 3.1.DDL：Create 子句CREATE 语句用于向当前或指定的 Catalog 中注册库、表、视图或函数。注册后的库、表、视图和函数可以在 SQL 查询中使用。 目前 Flink SQL 支持下列 CREATE 语句： ⭐ CREATE TABLE ⭐ CREATE DATABASE ⭐ CREATE VIEW ⭐ CREATE FUNCTION 此节重点介绍建表，建数据库、视图和 UDF 会在后面的扩展章节进行介绍。 3.1.1.建表语句下面的 SQL 语句就是建表语句的定义，根据指定的表名创建一个表，如果同名表已经在 catalog 中存在了，则无法注册。 12345678910111213141516171819202122232425262728293031323334353637CREATE TABLE [IF NOT EXISTS] [catalog_name.][db_name.]table_name ( &#123; &lt;physical_column_definition&gt; | &lt;metadata_column_definition&gt; | &lt;computed_column_definition&gt; &#125;[ , ...n] [ &lt;watermark_definition&gt; ] [ &lt;table_constraint&gt; ][ , ...n] ) [COMMENT table_comment] [PARTITIONED BY (partition_column_name1, partition_column_name2, ...)] WITH (key1=val1, key2=val2, ...) [ LIKE source_table [( &lt;like_options&gt; )] ] &lt;physical_column_definition&gt;: column_name column_type [ &lt;column_constraint&gt; ] [COMMENT column_comment] &lt;column_constraint&gt;: [CONSTRAINT constraint_name] PRIMARY KEY NOT ENFORCED&lt;table_constraint&gt;: [CONSTRAINT constraint_name] PRIMARY KEY (column_name, ...) NOT ENFORCED&lt;metadata_column_definition&gt;: column_name column_type METADATA [ FROM metadata_key ] [ VIRTUAL ]&lt;computed_column_definition&gt;: column_name AS computed_column_expression [COMMENT column_comment]&lt;watermark_definition&gt;: WATERMARK FOR rowtime_column_name AS watermark_strategy_expression&lt;source_table&gt;: [catalog_name.][db_name.]table_name&lt;like_options&gt;:&#123; &#123; INCLUDING | EXCLUDING &#125; &#123; ALL | CONSTRAINTS | PARTITIONS &#125; | &#123; INCLUDING | EXCLUDING | OVERWRITING &#125; &#123; GENERATED | OPTIONS | WATERMARKS &#125; &#125;[, ...] 3.1.2.表中的列 ⭐ 常规列（即物理列） 物理列是数据库中所说的常规列。其定义了物理介质中存储的数据中字段的名称、类型和顺序。 其他类型的列可以在物理列之间声明，但不会影响最终的物理列的读取。 举一个仅包含常规列的表的案例： 123456CREATE TABLE MyTable ( `user_id` BIGINT, `name` STRING) WITH ( ...); ⭐ 元数据列 元数据列是 SQL 标准的扩展，允许访问数据源本身具有的一些元数据。元数据列由 METADATA 关键字标识。 例如，我们可以使用元数据列从 Kafka 数据中读取 Kafka 数据自带的时间戳（这个时间戳不是数据中的某个时间戳字段，而是数据写入 Kafka 时，Kafka 引擎给这条数据打上的时间戳标记），然后我们可以在 Flink SQL 中使用这个时间戳，比如进行基于时间的窗口操作。 举例： 123456789CREATE TABLE MyTable ( `user_id` BIGINT, `name` STRING, -- 读取 kafka 本身自带的时间戳 `record_time` TIMESTAMP_LTZ(3) METADATA FROM &#x27;timestamp&#x27;) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27; ...); 元数据列可以用于后续数据的处理，或者写入到目标表中。 举例： 123456INSERT INTO MyTable SELECT user_id , name , record_time + INTERVAL &#x27;1&#x27; SECOND FROM MyTable; 如果自定义的列名称和 Connector 中定义 metadata 字段的名称一样的话，FROM xxx 子句是可以被省略的。 举例： 123456789CREATE TABLE MyTable ( `user_id` BIGINT, `name` STRING, -- 读取 kafka 本身自带的时间戳 `timestamp` TIMESTAMP_LTZ(3) METADATA) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27; ...); 关于 Flink SQL 的每种 Connector 都提供了哪些 metadata 字段，详细可见官网文档 https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/connectors/table/overview/ 如果自定义列的数据类型和 Connector 中定义的 metadata 字段的数据类型不一致的话，程序运行时会自动 cast 强转。但是这要求两种数据类型是可以强转的。举例如下： 123456789CREATE TABLE MyTable ( `user_id` BIGINT, `name` STRING, -- 将时间戳强转为 BIGINT `timestamp` BIGINT METADATA) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27; ...); 默认情况下，Flink SQL planner 认为 metadata 列是可以 读取 也可以 写入 的。但是有些外部存储系统的元数据信息是只能用于读取，不能写入的。 那么在往一个表写入的场景下，我们就可以使用 VIRTUAL 关键字来标识某个元数据列不写入到外部存储中（不持久化）。 以 Kafka 举例： 1234567891011CREATE TABLE MyTable ( -- sink 时会写入 `timestamp` BIGINT METADATA, -- sink 时不写入 `offset` BIGINT METADATA VIRTUAL, `user_id` BIGINT, `name` STRING,) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27; ...); 在上面这个案例中，Kafka 引擎的 offset 是只读的。所以我们在把 MyTable 作为数据源（输入）表时，schema 中是包含 offset 的。在把 MyTable 作为数据汇（输出）表时，schema 中是不包含 offset 的。如下： 12345-- 当做数据源（输入）的 schemaMyTable(&#96;timestamp&#96; BIGINT, &#96;offset&#96; BIGINT, &#96;user_id&#96; BIGINT, &#96;name&#96; STRING)-- 当做数据汇（输出）的 schemaMyTable(&#96;timestamp&#96; BIGINT, &#96;user_id&#96; BIGINT, &#96;name&#96; STRING) 所以这里在写入时需要注意，不要在 SQL 的 INSERT INTO 语句中写入 offset 列，否则 Flink SQL 任务会直接报错。 ⭐ 计算列 计算列其实就是在写建表的 DDL 时，可以拿已有的一些列经过一些自定义的运算生成的新列。这些列本身是没有以物理形式存储到数据源中的。 举例： 12345678910CREATE TABLE MyTable ( `user_id` BIGINT, `price` DOUBLE, `quantity` DOUBLE, -- cost 就是使用 price 和 quanitity 生成的计算列，计算方式为 price * quanitity `cost` AS price * quanitity,) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27; ...); 注意！！！ 计算列可以包含其他列、常量或者函数，但是不能写一个子查询进去。 小伙伴萌这时会问到一个问题，既然只能包含列、常量或者函数计算，我就直接在 DML query 代码中写就完事了呗，为啥还要专门在 DDL 中定义呢？ 结论：没错，如果只是简单的四则运算的话直接写在 DML 中就可以，但是计算列一般是用于定义时间属性的（因为在 SQL 任务中时间属性只能在 DDL 中定义，不能在 DML 语句中定义）。比如要把输入数据的时间格式标准化。处理时间、事件时间分别举例如下： ⭐ 处理时间：使用 PROCTIME() 函数来定义处理时间列 ⭐ 事件时间：事件时间的时间戳可以在声明 Watermark 之前进行预处理。比如如果字段不是 TIMESTAMP(3) 类型或者时间戳是嵌套在 JSON 字符串中的，则可以使用计算列进行预处理。 注意！！!和虚拟 metadata 列是类似的，计算列也是只能读不能写的。 也就是说，我们在把 MyTable 作为数据源（输入）表时，schema 中是包含 cost 的。 在把 MyTable 作为数据汇（输出）表时，schema 中是不包含 cost 的。举例： 12345-- 当做数据源（输入）的 schemaMyTable(`user_id` BIGINT, `price` DOUBLE, `quantity` DOUBLE, `cost` DOUBLE)-- 当做数据汇（输出）的 schemaMyTable(`user_id` BIGINT, `price` DOUBLE, `quantity` DOUBLE) 3.1.3.定义 WatermarkWatermark 是在 Create Table 中进行定义的。具体 SQL 语法标准是 WATERMARK FOR rowtime_column_name AS watermark_strategy_expression。 其中： ⭐ rowtime_column_name：表的事件时间属性字段。该列必须是 TIMESTAMP(3)、TIMESTAMP_LTZ(3) 类，这个时间可以是一个计算列。 ⭐ watermark_strategy_expression：定义 Watermark 的生成策略。Watermark 的一般都是由 rowtime_column_name 列减掉一段固定时间间隔。SQL 中 Watermark 的生产策略是：当前 Watermark 大于上次发出的 Watermark 时发出当前 Watermark。 注意： 如果你使用的是事件时间语义，那么必须要设设置事件时间属性和 WATERMARK 生成策略。 Watermark 的发出频率：Watermark 发出一般是间隔一定时间的，Watermark 的发出间隔时间可以由 pipeline.auto-watermark-interval 进行配置，如果设置为 200ms 则每 200ms 会计算一次 Watermark，然如果比之前发出的 Watermark 大，则发出。如果间隔设为 0ms，则 Watermark 只要满足触发条件就会发出，不会受到间隔时间控制。 Flink SQL 提供了几种 WATERMARK 生产策略： ⭐ 有界无序：设置方式为 WATERMARK FOR rowtime_column AS rowtime_column - INTERVAL &#39;string&#39; timeUnit。此类策略就可以用于设置最大乱序时间，假如设置为 WATERMARK FOR rowtime_column AS rowtime_column - INTERVAL &#39;5&#39; SECOND，则生成的是运行 5s 延迟的 Watermark。。一般都用这种 Watermark 生成策略，此类 Watermark 生成策略通常用于有数据乱序的场景中，而对应到实际的场景中，数据都是会存在乱序的，所以基本都使用此类策略。 ⭐ 严格升序：设置方式为 WATERMARK FOR rowtime_column AS rowtime_column。一般基本不用这种方式。如果你能保证你的数据源的时间戳是严格升序的，那就可以使用这种方式。严格升序代表 Flink 任务认为时间戳只会越来越大，也不存在相等的情况，只要相等或者小于之前的，就认为是迟到的数据。 ⭐ 递增：设置方式为 WATERMARK FOR rowtime_column AS rowtime_column - INTERVAL &#39;0.001&#39; SECOND。一般基本不用这种方式。如果设置此类，则允许有相同的时间戳出现。 3.1.4.Create Table With 子句先看一个案例： 12345678910111213CREATE TABLE KafkaTable ( `user_id` BIGINT, `item_id` BIGINT, `behavior` STRING, `ts` TIMESTAMP(3) METADATA FROM &#x27;timestamp&#x27;) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;topic&#x27; = &#x27;user_behavior&#x27;, &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;, &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;, &#x27;scan.startup.mode&#x27; = &#x27;earliest-offset&#x27;, &#x27;format&#x27; = &#x27;csv&#x27;) 可以看到 DDL 中 With 子句就是在建表时，描述数据源、数据汇的具体外部存储的元数据信息的。 一般 With 中的配置项由 Flink SQL 的 Connector（链接外部存储的连接器） 来定义，每种 Connector 提供的 With 配置项都是不同的。 注意： Flink SQL 中 Connector 其实就是 Flink 用于链接外部数据源的接口。举一个类似的例子，在 Java 中想连接到 MySQL，需要使用 mysql-connector-java 包提供的 Java API 去链接。映射到 Flink SQL 中，在 Flink SQL 中要连接到 Kafka，需要使用 kafka connector Flink SQL 已经提供了一系列的内置 Connector，具体可见 https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/connectors/table/overview/ 回到上述案例中，With 声明了以下几项信息： ⭐ &#39;connector&#39; = &#39;kafka&#39;：声明外部存储是 Kafka ⭐ &#39;topic&#39; = &#39;user_behavior&#39;：声明 Flink SQL 任务要连接的 Kafka 表的 topic 是 user_behavior ⭐ &#39;properties.bootstrap.servers&#39; = &#39;localhost:9092&#39;：声明 Kafka 的 server ip 是 localhost:9092 ⭐ &#39;properties.group.id&#39; = &#39;testGroup&#39;：声明 Flink SQL 任务消费这个 Kafka topic，会使用 testGroup 的 group id 去消费 ⭐ &#39;scan.startup.mode&#39; = &#39;earliest-offset&#39;：声明 Flink SQL 任务消费这个 Kafka topic 会从最早位点开始消费 ⭐ &#39;format&#39; = &#39;csv&#39;：声明 Flink SQL 任务读入或者写出时对于 Kafka 消息的序列化方式是 csv 格式 从这里也可以看出来 With 中具体要配置哪些配置项都是和每种 Connector 决定的。 3.1.4.Create Table Like 子句Like 子句是 Create Table 子句的一个延伸。举例： 下面定义了一张 Orders 表： 12345678CREATE TABLE Orders ( `user` BIGINT, product STRING, order_time TIMESTAMP(3)) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;scan.startup.mode&#x27; = &#x27;earliest-offset&#x27;); 但是忘记定义 Watermark 了，那如果想加上 Watermark，就可以用 Like 子句定义一张带 Watermark 的新表： 123456789CREATE TABLE Orders_with_watermark ( -- 1. 添加了 WATERMARK 定义 WATERMARK FOR order_time AS order_time - INTERVAL &#x27;5&#x27; SECOND ) WITH ( -- 2. 覆盖了原 Orders 表中 scan.startup.mode 参数 &#x27;scan.startup.mode&#x27; = &#x27;latest-offset&#x27;)-- 3. Like 子句声明是在原来的 Orders 表的基础上定义 Orders_with_watermark 表LIKE Orders; 上面这个语句的效果就等同于： 123456789CREATE TABLE Orders_with_watermark ( `user` BIGINT, product STRING, order_time TIMESTAMP(3), WATERMARK FOR order_time AS order_time - INTERVAL &#x27;5&#x27; SECOND ) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;scan.startup.mode&#x27; = &#x27;latest-offset&#x27;); 不过这种不常使用。就不过多介绍了。如果小伙伴萌感兴趣，直接去官网参考具体注意事项： https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/sql/create/#like 3.2.DML：With 子句 ⭐ 应用场景（支持 Batch\\Streaming）：With 语句和离线 Hive SQL With 语句一样的，xdm，语法糖 +1，使用它可以让你的代码逻辑更加清晰。 ⭐ 直接上案例： 12345678910111213-- 语法糖+1WITH orders_with_total AS ( SELECT order_id , price + tax AS total FROM Orders)SELECT order_id , SUM(total)FROM orders_with_totalGROUP BY order_id; 3.3.DML：SELECT &amp; WHERE 子句 ⭐ 应用场景（支持 Batch\\Streaming）：SELECT &amp; WHERE 语句和离线 Hive SQL 语句一样的，xdm，常用作 ETL，过滤，字段清洗标准化 ⭐ 直接上案例： 123456789101112131415161718INSERT INTO target_tableSELECT * FROM OrdersINSERT INTO target_tableSELECT order_id, price + tax FROM OrdersINSERT INTO target_table-- 自定义 Source 的数据SELECT order_id, price FROM (VALUES (1, 2.0), (2, 3.1)) AS t (order_id, price)INSERT INTO target_tableSELECT price + tax FROM Orders WHERE id = 10-- 使用 UDF 做字段标准化处理INSERT INTO target_tableSELECT PRETTY_PRINT(order_id) FROM Orders-- 过滤条件Where id &gt; 3 ⭐ SQL 语义： 其实理解一个 SQL 最后生成的任务是怎样执行的，最好的方式就是理解其语义。 以下面的 SQL 为例，我们来介绍下其在离线中和在实时中执行的区别，对比学习一下，大家就比较清楚了 123INSERT INTO target_tableSELECT PRETTY_PRINT(order_id) FROM OrdersWhere id &gt; 3 这个 SQL 对应的实时任务，假设 Orders 为 kafka，target_table 也为 Kafka，在执行时，会生成三个算子： ⭐ 数据源算子（From Order）：连接到 Kafka topic，数据源算子一直运行，实时的从 Order Kafka 中一条一条的读取数据，然后一条一条发送给下游的 过滤和字段标准化算子 ⭐ 过滤和字段标准化算子（Where id &gt; 3 和 PRETTY_PRINT(order_id)）：接收到上游算子发的一条一条的数据，然后判断 id &gt; 3？将判断结果为 true 的数据执行 PRETTY_PRINT UDF 后，一条一条将计算结果数据发给下游 数据汇算子 ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游发的一条一条的数据，写入到 target_table Kafka 中 可以看到这个实时任务的所有算子是以一种 pipeline 模式运行的，所有的算子在同一时刻都是处于 running 状态的，24 小时一直在运行，实时任务中也没有离线中常见的分区概念。 关于看如何看一段 Flink SQL 最终的执行计划： 最好的方法就如上图，看 Flink web ui 的算子图，算子图上详细的标记清楚了每一个算子做的事情。以上图来说，我们可以看到主要有三个算子： ⭐ Source 算子：Source: TableSourceScan(table=[[default_catalog, default_database, Orders]], fields=[order_id, name]) -&gt; Calc(select=[order_id, name, CAST(CURRENT_TIMESTAMP()) AS row_time]) -&gt; WatermarkAssigner(rowtime=[row_time], watermark=[(row_time - 5000:INTERVAL SECOND)]) ，其中 Source 表名称为 table=[[default_catalog, default_database, Orders]，字段为 select=[order_id, name, CAST(CURRENT_TIMESTAMP()) AS row_time]，Watermark 策略为 rowtime=[row_time], watermark=[(row_time - 5000:INTERVAL SECOND)]。 ⭐ 过滤算子：Calc(select=[order_id, name, row_time], where=[(order_id &gt; 3)]) -&gt; NotNullEnforcer(fields=[order_id])，其中过滤条件为 where=[(order_id &gt; 3)]，结果字段为 select=[order_id, name, row_time] ⭐ Sink 算子：Sink: Sink(table=[default_catalog.default_database.target_table], fields=[order_id, name, row_time])，其中最终产出的表名称为 table=[default_catalog.default_database.target_table]，表字段为 fields=[order_id, name, row_time] 可以看到 Flink SQL 具体执行了哪些操作是非常详细的标记在算子图上。所以小伙伴萌一定要学会看算子图，这是掌握 debug、调优前最基础的一个技巧。 那么如果这个 SQL 放在 Hive 中执行时，假设其中 Orders 为 Hive 表，target_table 也为 Hive 表，其也会生成三个类似的算子（虽然实际可能会被优化为一个算子，这里为了方便对比，划分为三个进行介绍），离线和实时任务的执行方式完全不同： ⭐ 数据源算子（From Order）：数据源从 Order Hive 表（通常都是读一天、一小时的分区数据）中一次性读取所有的数据，然后将读到的数据全部发给下游 过滤和字段标准化算子，然后 数据源算子 就运行结束了，释放资源了 ⭐ 过滤和字段标准化算子（Where id &gt; 3 和 PRETTY_PRINT(order_id)）：接收到上游算子的所有数据，然后遍历所有数据判断 id &gt; 3？将判断结果为 true 的数据执行 PRETTY_PRINT UDF 后，将所有数据发给下游 数据汇算子，然后 过滤和字段标准化算子 就运行结束了，释放资源了 ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游的所有数据，将所有数据都写到 target_table Hive 表中，然后整个任务就运行结束了，整个任务的资源也就都释放了 可以看到离线任务的算子是分阶段（stage）进行运行的，每一个 stage 运行结束之后，然后下一个 stage 开始运行，全部的 stage 运行完成之后，这个离线任务就跑结束了。 注意： 很多小伙伴都是之前做过离线数仓的，熟悉了离线的分区、计算任务定时调度运行这两个概念，所以在最初接触 Flink SQL 时，会以为 Flink SQL 实时任务也会存在这两个概念，这里博主做一下解释 分区概念：离线由于能力限制问题，通常都是进行一批一批的数据计算，每一批数据的数据量都是有限的集合，这一批一批的数据自然的划分方式就是时间，比如按小时、天进行划分分区。但是 在实时任务中，是没有分区的概念的，实时任务的上游、下游都是无限的数据流。 计算任务定时调度概念：同上，离线就是由于计算能力限制，数据要一批一批算，一批一批输入、产出，所以要按照小时、天定时的调度和计算。但是 在实时任务中，是没有定时调度的概念的，实时任务一旦运行起来就是 24 小时不间断，不间断的处理上游无限的数据，不简单的产出数据给到下游。 todo 文章链接 3.4.DML：SELECT DISTINCT 子句 ⭐ 应用场景（支持 Batch\\Streaming）：语句和离线 Hive SQL SELECT DISTINCT 语句一样的，xdm，用作根据 key 进行数据去重 ⭐ 直接上案例： 1234INSERT into target_tableSELECT DISTINCT id FROM Orders ⭐ SQL 语义： 也是拿离线和实时做对比。 这个 SQL 对应的实时任务，假设 Orders 为 kafka，target_table 也为 Kafka，在执行时，会生成三个算子： ⭐ 数据源算子（From Order）：连接到 Kafka topic，数据源算子一直运行，实时的从 Order Kafka 中一条一条的读取数据，然后一条一条发送给下游的 去重算子 ⭐ 去重算子（DISTINCT id）：接收到上游算子发的一条一条的数据，然后判断这个 id 之前是否已经来过了，判断方式就是使用 Flink 中的 state 状态，如果状态中已经有这个 id 了，则说明已经来过了，不往下游算子发，如果状态中没有这个 id，则说明没来过，则往下游算子发，也是一条一条发给下游 数据汇算子 ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游发的一条一条的数据，写入到 target_table Kafka 中 注意： 对于实时任务，计算时的状态可能会无限增长。 状态大小取决于不同 key（上述案例为 id 字段）的数量。为了防止状态无限变大，我们可以设置状态的 TTL。但是这可能会影响查询结果的正确性，比如某个 key 的数据过期从状态中删除了，那么下次再来这么一个 key，由于在状态中找不到，就又会输出一遍。 那么如果这个 SQL 放在 Hive 中执行时，假设其中 Orders 为 Hive 表，target_table 也为 Hive 表，其也会生成三个相同的算子（虽然可能会被优化为一个算子，这里为了方便对比，划分为三个进行介绍），但是其和实时任务的执行方式完全不同： ⭐ 数据源算子（From Order）：数据源从 Order Hive 表（通常都有天、小时分区限制）中一次性读取所有的数据，然后将读到的数据全部发给下游 去重算子，然后 数据源算子 就运行结束了，释放资源了 ⭐ 去重算子（DISTINCT id）：接收到上游算子的所有数据，然后遍历所有数据进行去重，将去重完的所有结果数据发给下游 数据汇算子，然后 去重算子 就运行结束了，释放资源了 ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游的所有数据，将所有数据都写到 target_table Hive 中，然后整个任务就运行结束了，整个任务的资源也就都释放了 3.5.DML：窗口聚合由于窗口涉及到的知识内容比较多，所以博主先为大家说明介绍下面内容时的思路，大家跟着思路走。思路如下： ⭐ 先介绍 Flink SQL 支持的 4 种时间窗口 ⭐ 分别详细介绍上述的 4 种时间窗口的功能及 SQL 语法 ⭐ 结合实际案例介绍 4 种时间窗口 首先来看看 Flink SQL 中支持的 4 种窗口的运算。 ⭐ 滚动窗口（TUMBLE） ⭐ 滑动窗口（HOP） ⭐ Session 窗口（SESSION） ⭐ 渐进式窗口（CUMULATE） 3.5.1.滚动窗口（TUMBLE） ⭐ 滚动窗口定义：滚动窗口将每个元素指定给指定窗口大小的窗口。滚动窗口具有固定大小，且不重叠。例如，指定一个大小为 5 分钟的滚动窗口。在这种情况下，Flink 将每隔 5 分钟开启一个新的窗口，其中每一条数都会划分到唯一一个 5 分钟的窗口中，如下图所示。 ⭐ 应用场景：常见的按照一分钟对数据进行聚合，计算一分钟内 PV，UV 数据。 ⭐ 实际案例：简单且常见的分维度分钟级别同时在线用户数、总销售额 那么上面这个案例的 SQL 要咋写呢？ 关于滚动窗口，在 1.13 版本之前和 1.13 及之后版本有两种 Flink SQL 实现方式，分别是： ⭐ Group Window Aggregation（1.13 之前只有此类方案，此方案在 1.13 及之后版本已经标记为废弃，不推荐小伙伴萌使用） ⭐ Windowing TVF（1.13 及之后建议使用 Windowing TVF） 博主这里两种方法都会介绍： ⭐ Group Window Aggregation 方案（支持 Batch\\Streaming 任务）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- 数据源表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;)-- 数据汇表CREATE TABLE sink_table ( dim STRING, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;)-- 数据处理逻辑insert into sink_tableselect dim, count(*) as pv, sum(price) as sum_price, max(price) as max_price, min(price) as min_price, -- 计算 uv 数 count(distinct user_id) as uv, UNIX_TIMESTAMP(CAST(tumble_start(row_time, interval &#x27;1&#x27; minute) AS STRING)) * 1000 as window_startfrom source_tablegroup by dim, tumble(row_time, interval &#x27;1&#x27; minute) 可以看到 Group Window Aggregation 滚动窗口的 SQL 语法就是把 tumble window 的声明写在了 group by 子句中，即 tumble(row_time, interval &#39;1&#39; minute)，第一个参数为事件时间的时间戳；第二个参数为滚动窗口大小。 ⭐ Window TVF 方案（1.13 只支持 Streaming 任务）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- 数据源表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;)-- 数据汇表CREATE TABLE sink_table ( dim STRING, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;)-- 数据处理逻辑insert into sink_tableSELECT dim, UNIX_TIMESTAMP(CAST(window_start AS STRING)) * 1000 as window_start, count(*) as pv, sum(price) as sum_price, max(price) as max_price, min(price) as min_price, count(distinct user_id) as uvFROM TABLE(TUMBLE( TABLE source_table , DESCRIPTOR(row_time) , INTERVAL &#x27;60&#x27; SECOND))GROUP BY window_start, window_end, dim 可以看到 Windowing TVF 滚动窗口的写法就是把 tumble window 的声明写在了数据源的 Table 子句中，即 TABLE(TUMBLE(TABLE source_table, DESCRIPTOR(row_time), INTERVAL &#39;60&#39; SECOND))，包含三部分参数。 第一个参数 TABLE source_table 声明数据源表；第二个参数 DESCRIPTOR(row_time) 声明数据源的时间戳；第三个参数 INTERVAL &#39;60&#39; SECOND 声明滚动窗口大小为 1 min。 可以直接在公众号后台回复1.13.2 最全 flink sql获取源代码。所有的源码都开源到 github 上面了。里面包含了非常多的案例。可以直接拿来在本地运行的！！！肥肠的方便。 ⭐ SQL 语义： 由于离线没有相同的时间窗口聚合概念，这里就直接说实时场景 SQL 语义，假设 Orders 为 kafka，target_table 也为 Kafka，这个 SQL 生成的实时任务，在执行时，会生成三个算子： ⭐ 数据源算子（From Order）：连接到 Kafka topic，数据源算子一直运行，实时的从 Order Kafka 中一条一条的读取数据，然后一条一条发送给下游的 窗口聚合算子 ⭐ 窗口聚合算子（TUMBLE 算子）：接收到上游算子发的一条一条的数据，然后将每一条数据按照时间戳划分到对应的窗口中（根据事件时间、处理时间的不同语义进行划分），上述案例为事件时间，事件时间中，滚动窗口算子接收到上游的 Watermark 大于窗口的结束时间时，则说明当前这一分钟的滚动窗口已经结束了，将窗口计算完的结果发往下游算子（一条一条发给下游 数据汇算子） ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游发的一条一条的数据，写入到 target_table Kafka 中 这个实时任务也是 24 小时一直在运行的，所有的算子在同一时刻都是处于 running 状态的。 注意： 事件时间中滚动窗口的窗口计算触发是由 Watermark 推动的。 3.5.2.滑动窗口（HOP） ⭐ 滑动窗口定义：滑动窗口也是将元素指定给固定长度的窗口。与滚动窗口功能一样，也有窗口大小的概念。不一样的地方在于，滑动窗口有另一个参数控制窗口计算的频率（滑动窗口滑动的步长）。因此，如果滑动的步长小于窗口大小，则滑动窗口之间每个窗口是可以重叠。在这种情况下，一条数据就会分配到多个窗口当中。举例，有 10 分钟大小的窗口，滑动步长为 5 分钟。这样，每 5 分钟会划分一次窗口，这个窗口包含的数据是过去 10 分钟内的数据，如下图所示。 ⭐ 应用场景：比如计算同时在线的数据，要求结果的输出频率是 1 分钟一次，每次计算的数据是过去 5 分钟的数据（有的场景下用户可能在线，但是可能会 2 分钟不活跃，但是这也要算在同时在线数据中，所以取最近 5 分钟的数据就能计算进去了） ⭐ 实际案例：简单且常见的分维度分钟级别同时在线用户数，1 分钟输出一次，计算最近 5 分钟的数据 依然是 Group Window Aggregation、Windowing TVF 两种方案： ⭐ Group Window Aggregation 方案（支持 Batch\\Streaming 任务）： 12345678910111213141516171819202122232425262728293031323334353637383940-- 数据源表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;);-- 数据汇表CREATE TABLE sink_table ( dim STRING, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 数据处理逻辑insert into sink_tableSELECT dim, UNIX_TIMESTAMP(CAST(hop_start(row_time, interval &#x27;1&#x27; minute, interval &#x27;5&#x27; minute) AS STRING)) * 1000 as window_start, count(distinct user_id) as uvFROM source_tableGROUP BY dim , hop(row_time, interval &#x27;1&#x27; minute, interval &#x27;5&#x27; minute) 可以看到 Group Window Aggregation 滚动窗口的写法就是把 hop window 的声明写在了 group by 子句中，即 hop(row_time, interval &#39;1&#39; minute, interval &#39;5&#39; minute)。其中： 第一个参数为事件时间的时间戳；第二个参数为滑动窗口的滑动步长；第三个参数为滑动窗口大小。 ⭐ Windowing TVF 方案（1.13 只支持 Streaming 任务）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 数据源表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;);-- 数据汇表CREATE TABLE sink_table ( dim STRING, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 数据处理逻辑insert into sink_tableSELECT dim, UNIX_TIMESTAMP(CAST(window_start AS STRING)) * 1000 as window_start, count(distinct user_id) as bucket_uvFROM TABLE(HOP( TABLE source_table , DESCRIPTOR(row_time) , INTERVAL &#x27;1&#x27; MINUTES, INTERVAL &#x27;5&#x27; MINUTES))GROUP BY window_start, window_end, dim 可以看到 Windowing TVF 滚动窗口的写法就是把 hop window 的声明写在了数据源的 Table 子句中，即 TABLE(HOP(TABLE source_table, DESCRIPTOR(row_time), INTERVAL &#39;1&#39; MINUTES, INTERVAL &#39;5&#39; MINUTES))，包含四部分参数： 第一个参数 TABLE source_table 声明数据源表；第二个参数 DESCRIPTOR(row_time) 声明数据源的时间戳；第三个参数 INTERVAL &#39;1&#39; MINUTES 声明滚动窗口滑动步长大小为 1 min。第四个参数 INTERVAL &#39;5&#39; MINUTES 声明滚动窗口大小为 5 min。 ⭐ SQL 语义： todo 滑动窗口语义和滚动窗口类似，这里不再赘述。 3.5.3.Session 窗口（SESSION） ⭐ Session 窗口定义：Session 时间窗口和滚动、滑动窗口不一样，其没有固定的持续时间，如果在定义的间隔期（Session Gap）内没有新的数据出现，则 Session 就会窗口关闭。如下图对比所示： ⭐ 实际案例：计算每个用户在活跃期间（一个 Session）总共购买的商品数量，如果用户 5 分钟没有活动则视为 Session 断开 目前 1.13 版本中 Flink SQL 不支持 Session 窗口的 Window TVF，所以这里就只介绍 Group Window Aggregation 方案： ⭐ Group Window Aggregation 方案（支持 Batch\\Streaming 任务）： 12345678910111213141516171819202122232425262728293031323334353637383940-- 数据源表，用户购买行为记录表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;);-- 数据汇表CREATE TABLE sink_table ( dim STRING, pv BIGINT, -- 购买商品数量 window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 数据处理逻辑insert into sink_tableSELECT dim, UNIX_TIMESTAMP(CAST(session_start(row_time, interval &#x27;5&#x27; minute) AS STRING)) * 1000 as window_start, count(1) as pvFROM source_tableGROUP BY dim , session(row_time, interval &#x27;5&#x27; minute) 注意： 上述 SQL 任务是在整个 Session 窗口结束之后才会把数据输出。Session 窗口即支持 处理时间 也支持 事件时间。但是处理时间只支持在 Streaming 任务中运行，Batch 任务不支持。 可以看到 Group Window Aggregation 中 Session 窗口的写法就是把 session window 的声明写在了 group by 子句中，即 session(row_time, interval &#39;5&#39; minute)。其中： 第一个参数为事件时间的时间戳；第二个参数为 Session gap 间隔。 ⭐ SQL 语义： Session 窗口语义和滚动窗口类似，这里不再赘述。 可以直接在公众号后台回复1.13.2 最全 flink sql获取源代码。所有的源码都开源到 github 上面了。里面包含了非常多的案例。可以直接拿来在本地运行的！！！肥肠的方便。 3.5.4.渐进式窗口（CUMULATE） ⭐ 渐进式窗口定义（1.13 只支持 Streaming 任务）：渐进式窗口在其实就是 固定窗口间隔内提前触发的的滚动窗口，其实就是 Tumble Window + early-fire 的一个事件时间的版本。例如，从每日零点到当前这一分钟绘制累积 UV，其中 10:00 时的 UV 表示从 00:00 到 10:00 的 UV 总数。渐进式窗口可以认为是首先开一个最大窗口大小的滚动窗口，然后根据用户设置的触发的时间间隔将这个滚动窗口拆分为多个窗口，这些窗口具有相同的窗口起点和不同的窗口终点。如下图所示： ⭐ 应用场景：周期内累计 PV，UV 指标（如每天累计到当前这一分钟的 PV，UV）。这类指标是一段周期内的累计状态，对分析师来说更具统计分析价值，而且几乎所有的复合指标都是基于此类指标的统计（不然离线为啥都要累计一天的数据，而不要一分钟累计的数据呢）。 ⭐ 实际案例：每天的截止当前分钟的累计 money（sum(money)），去重 id 数（count(distinct id)）。每天代表渐进式窗口大小为 1 天，分钟代表渐进式窗口移动步长为分钟级别。举例如下： 明细输入数据： time id money 2021-11-01 00:01:00 A 3 2021-11-01 00:01:00 B 5 2021-11-01 00:01:00 A 7 2021-11-01 00:02:00 C 3 2021-11-01 00:03:00 C 10 预期经过渐进式窗口计算的输出数据： time count distinct id sum money 2021-11-01 00:01:00 2 15 2021-11-01 00:02:00 3 18 2021-11-01 00:03:00 3 28 转化为折线图长这样： 可以看到，其特点就在于，每一分钟的输出结果都是当天零点累计到当前的结果。 渐进式窗口目前只有 Windowing TVF 方案支持： ⭐ Windowing TVF 方案（1.13 只支持 Streaming 任务）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 数据源表CREATE TABLE source_table ( -- 用户 id user_id BIGINT, -- 用户 money BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;);-- 数据汇表CREATE TABLE sink_table ( window_end bigint, window_start bigint, sum_money BIGINT, count_distinct_id bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 数据处理逻辑insert into sink_tableSELECT UNIX_TIMESTAMP(CAST(window_end AS STRING)) * 1000 as window_end, window_start, sum(money) as sum_money, count(distinct id) as count_distinct_idFROM TABLE(CUMULATE( TABLE source_table , DESCRIPTOR(row_time) , INTERVAL &#x27;60&#x27; SECOND , INTERVAL &#x27;1&#x27; DAY))GROUP BY window_start, window_end 可以看到 Windowing TVF 滚动窗口的写法就是把 cumulate window 的声明写在了数据源的 Table 子句中，即 TABLE(CUMULATE(TABLE source_table, DESCRIPTOR(row_time), INTERVAL &#39;60&#39; SECOND, INTERVAL &#39;1&#39; DAY))，其中包含四部分参数： 第一个参数 TABLE source_table 声明数据源表；第二个参数 DESCRIPTOR(row_time) 声明数据源的时间戳；第三个参数 INTERVAL &#39;60&#39; SECOND 声明渐进式窗口触发的渐进步长为 1 min。第四个参数 INTERVAL &#39;1&#39; DAY 声明整个渐进式窗口的大小为 1 天，到了第二天新开一个窗口重新累计。 ⭐ SQL 语义： todo 渐进式窗口语义和滚动窗口类似，这里不再赘述。 3.5.5.Window TVF 支持 Grouping Sets、Rollup、Cube具体应用场景：实际的案例场景中，经常会有多个维度进行组合（cube）计算指标的场景。如果把每个维度组合的代码写一遍，然后 union all 起来，这样写起来非常麻烦，而且会导致一个数据源读取多遍。 这时，有离线 Hive SQL 使用经验的小伙伴萌就会想到，如果有了 Grouping Sets，我们就可以直接用 Grouping Sets 将维度组合写在一条 SQL 中，写起来方便并且执行效率也高。当然，Flink 支持这个功能。 但是目前 Grouping Sets 只在 Window TVF 中支持，不支持 Group Window Aggregation。 来一个实际案例感受一下，计算每日零点累计到当前这一分钟的分汇总、age、sex、age+sex 维度的用户数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546-- 用户访问明细表CREATE TABLE source_table ( age STRING, sex STRING, user_id BIGINT, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.age.length&#x27; = &#x27;1&#x27;, &#x27;fields.sex.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;);CREATE TABLE sink_table ( age STRING, sex STRING, uv BIGINT, window_end bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);insert into sink_tableSELECT UNIX_TIMESTAMP(CAST(window_end AS STRING)) * 1000 as window_end, if (age is null, &#x27;ALL&#x27;, age) as age, if (sex is null, &#x27;ALL&#x27;, sex) as sex, count(distinct user_id) as bucket_uvFROM TABLE(CUMULATE( TABLE source_table , DESCRIPTOR(row_time) , INTERVAL &#x27;5&#x27; SECOND , INTERVAL &#x27;1&#x27; DAY))GROUP BY window_start, window_end, -- grouping sets 写法 GROUPING SETS ( () , (age) , (sex) , (age, sex) ) 小伙伴萌这里需要注意下！！！ Flink SQL 中 Grouping Sets 的语法和 Hive SQL 的语法有一些不同，如果我们使用 Hive SQL 实现上述 SQL 的语义，其实现如下： 1234567891011121314151617insert into sink_tableSELECT UNIX_TIMESTAMP(CAST(window_end AS STRING)) * 1000 as window_end, if (age is null, &#x27;ALL&#x27;, age) as age, if (sex is null, &#x27;ALL&#x27;, sex) as sex, count(distinct user_id) as bucket_uvFROM source_tableGROUP BY age , sex-- hive sql grouping sets 写法GROUPING SETS ( () , (age) , (sex) , (age, sex)) 3.6.DML：Group 聚合 ⭐ Group 聚合定义（支持 Batch\\Streaming 任务）：Flink 也支持 Group 聚合。Group 聚合和上面介绍到的窗口聚合的不同之处，就在于 Group 聚合是按照数据的类别进行分组，比如年龄、性别，是横向的；而窗口聚合是在时间粒度上对数据进行分组，是纵向的。如下图所示，就展示出了其区别。其中 按颜色分 key（横向） 就是 Group 聚合，按窗口划分（纵向） 就是窗口聚合。 ⭐ 应用场景：一般用于对数据进行分组，然后后续使用聚合函数进行 count、sum 等聚合操作。 那么这时候，小伙伴萌就会问到，我其实可以把窗口聚合的写法也转换为 Group 聚合，只需要把 Group 聚合的 Group By key 换成时间就行，那这两个聚合的区别到底在哪？ 首先来举一个例子看看怎么将窗口聚合转换为 Group 聚合。假如一个窗口聚合是按照 1 分钟的粒度进行聚合，如下 SQL： ⭐ 滚动窗口（TUMBLE） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- 数据源表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;)-- 数据汇表CREATE TABLE sink_table ( dim STRING, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;)-- 数据处理逻辑insert into sink_tableselect dim, count(*) as pv, sum(price) as sum_price, max(price) as max_price, min(price) as min_price, -- 计算 uv 数 count(distinct user_id) as uv, UNIX_TIMESTAMP(CAST(tumble_start(row_time, interval &#x27;1&#x27; minute) AS STRING)) * 1000 as window_startfrom source_tablegroup by dim, -- 按照 Flink SQL tumble 窗口写法划分窗口 tumble(row_time, interval &#x27;1&#x27; minute) 转换为 Group 聚合的写法如下： ⭐ Group 聚合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- 数据源表CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;);-- 数据汇表CREATE TABLE sink_table ( dim STRING, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 数据处理逻辑insert into sink_tableselect dim, count(*) as pv, sum(price) as sum_price, max(price) as max_price, min(price) as min_price, -- 计算 uv 数 count(distinct user_id) as uv, cast((UNIX_TIMESTAMP(CAST(row_time AS STRING))) / 60 as bigint) as window_startfrom source_tablegroup by dim, -- 将秒级别时间戳 / 60 转化为 1min cast((UNIX_TIMESTAMP(CAST(row_time AS STRING))) / 60 as bigint) 确实没错，上面这个转换是一点问题都没有的。 但是窗口聚合和 Group by 聚合的差异在于： ⭐ 本质区别：窗口聚合是具有时间语义的，其本质是想实现窗口结束输出结果之后，后续有迟到的数据也不会对原有的结果发生更改了，即输出结果值是定值（不考虑 allowLateness）。而 Group by 聚合是没有时间语义的，不管数据迟到多长时间，只要数据来了，就把上一次的输出的结果数据撤回，然后把计算好的新的结果数据发出 ⭐ 运行层面：窗口聚合是和 时间 绑定的，窗口聚合其中窗口的计算结果触发都是由时间（Watermark）推动的。Group by 聚合完全由数据推动触发计算，新来一条数据去根据这条数据进行计算出结果发出；由此可见两者的实现方式也大为不同。 ⭐ SQL 语义 也是拿离线和实时做对比，Orders 为 kafka，target_table 为 Kafka，这个 SQL 生成的实时任务，在执行时，会生成三个算子： ⭐ 数据源算子（From Order）：数据源算子一直运行，实时的从 Order Kafka 中一条一条的读取数据，然后一条一条发送给下游的 Group 聚合算子，向下游发送数据的 shuffle 策略是根据 group by 中的 key 进行发送，相同的 key 发到同一个 SubTask（并发） 中 ⭐ Group 聚合算子（group by key + sum\\count\\max\\min）：接收到上游算子发的一条一条的数据，去状态 state 中找这个 key 之前的 sum\\count\\max\\min 结果。如果有结果 oldResult，拿出来和当前的数据进行 sum\\count\\max\\min 计算出这个 key 的新结果 newResult，并将新结果 [key, newResult] 更新到 state 中，在向下游发送新计算的结果之前，先发一条撤回上次结果的消息 -[key, oldResult]，然后再将新结果发往下游 +[key, newResult]；如果 state 中没有当前 key 的结果，则直接使用当前这条数据计算 sum\\max\\min 结果 newResult，并将新结果 [key, newResult] 更新到 state 中，当前是第一次往下游发，则不需要先发回撤消息，直接发送 +[key, newResult]。 ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游发的一条一条的数据，写入到 target_table Kafka 中 这个实时任务也是 24 小时一直在运行的，所有的算子在同一时刻都是处于 running 状态的。 特别注意： Group by 聚合涉及到了回撤流（也叫 retract 流），会产生回撤流是因为从整个 SQL 的语义来看，上游的 Kafka 数据是源源不断的，无穷无尽的，那么每次这个 SQL 任务产出的结果都是一个中间结果，所以每次结果发生更新时，都需要将上一次发出的中间结果给撤回，然后将最新的结果发下去。 Group by 聚合涉及到了状态：状态大小也取决于不同 key 的数量。为了防止状态无限变大，我们可以设置状态的 TTL。以上面的 SQL 为例，上面 SQL 是按照分钟进行聚合的，理论上到了今天，通常我们就可以不用关心昨天的数据了，那么我们可以设置状态过期时间为一天。关于状态过期时间的设置参数可以参考下文 运行时参数 小节。 如果这个 SQL 放在 Hive 中执行时，其中 Orders 为 Hive，target_table 也为 Hive，其也会生成三个相同的算子，但是其和实时任务的执行方式完全不同： ⭐ 数据源算子（From Order）：数据源算子从 Order Hive 中读取到所有的数据，然后所有数据发送给下游的 Group 聚合算子，向下游发送数据的 shuffle 策略是根据 group by 中的 key 进行发送，相同的 key 发到同一个算子中，然后这个算子就运行结束了，释放资源了 ⭐ Group 聚合算子（group by + sum\\count\\max\\min）：接收到上游算子发的所有数据，然后遍历计算 sum\\count\\max\\min 结果，批量发给下游 数据汇算子，这个算子也就运行结束了，释放资源了 ⭐ 数据汇算子（INSERT INTO target_table）：接收到上游发的一条一条的数据，写入到 target_table Hive 中，整个任务也就运行结束了，整个任务的资源也就都释放了 3.6.1.Group 聚合支持 Grouping sets、Rollup、CubeGroup 聚合也支持 Grouping sets、Rollup、Cube 举一个 Grouping sets 的案例： 123456789101112131415161718192021SELECT supplier_id , rating , product_id , COUNT(*)FROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY GROUPING SET ( ( supplier_id, product_id, rating ), ( supplier_id, product_id ), ( supplier_id, rating ), ( supplier_id ), ( product_id, rating ), ( product_id ), ( rating ), ( )) 3.7.DML：Over 聚合 ⭐ Over 聚合定义（支持 Batch\\Streaming）：可以理解为是一种特殊的滑动窗口聚合函数。 那这里我们拿 Over 聚合 与 窗口聚合 做一个对比，其之间的最大不同之处在于： ⭐ 窗口聚合：不在 group by 中的字段，不能直接在 select 中拿到 ⭐ Over 聚合：能够保留原始字段 注意： 其实在生产环境中，Over 聚合的使用场景还是比较少的。在 Hive 中也有相同的聚合，但是小伙伴萌可以想想你在离线数仓经常使用嘛？ ⭐ 应用场景：计算最近一段滑动窗口的聚合结果数据。 ⭐ 实际案例：查询每个产品最近一小时订单的金额总和： 1234567SELECT order_id, order_time, amount, SUM(amount) OVER ( PARTITION BY product ORDER BY order_time RANGE BETWEEN INTERVAL &#x27;1&#x27; HOUR PRECEDING AND CURRENT ROW ) AS one_hour_prod_amount_sumFROM Orders Over 聚合的语法总结如下： 1234567SELECT agg_func(agg_col) OVER ( [PARTITION BY col1[, col2, ...]] ORDER BY time_col range_definition), ...FROM ... 其中： ⭐ ORDER BY：必须是时间戳列（事件时间、处理时间） ⭐ PARTITION BY：标识了聚合窗口的聚合粒度，如上述案例是按照 product 进行聚合 ⭐ range_definition：这个标识聚合窗口的聚合数据范围，在 Flink 中有两种指定数据范围的方式。第一种为 按照行数聚合，第二种为 按照时间区间聚合。如下案例所示： a. ⭐ 时间区间聚合： 按照时间区间聚合就是时间区间的一个滑动窗口，比如下面案例 1 小时的区间，最新输出的一条数据的 sum 聚合结果就是最近一小时数据的 amount 之和。 1234567891011121314151617181920212223242526272829303132333435CREATE TABLE source_table ( order_id BIGINT, product BIGINT, amount BIGINT, order_time as cast(CURRENT_TIMESTAMP as TIMESTAMP(3)), WATERMARK FOR order_time AS order_time - INTERVAL &#x27;0.001&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.order_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.order_id.max&#x27; = &#x27;2&#x27;, &#x27;fields.amount.min&#x27; = &#x27;1&#x27;, &#x27;fields.amount.max&#x27; = &#x27;10&#x27;, &#x27;fields.product.min&#x27; = &#x27;1&#x27;, &#x27;fields.product.max&#x27; = &#x27;2&#x27;);CREATE TABLE sink_table ( product BIGINT, order_time TIMESTAMP(3), amount BIGINT, one_hour_prod_amount_sum BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT product, order_time, amount, SUM(amount) OVER ( PARTITION BY product ORDER BY order_time -- 标识统计范围是一个 product 的最近 1 小时的数据 RANGE BETWEEN INTERVAL &#x27;1&#x27; HOUR PRECEDING AND CURRENT ROW ) AS one_hour_prod_amount_sumFROM source_table 结果如下： script12345678+I[2, 2021-12-24T22:08:26.583, 7, 73]+I[2, 2021-12-24T22:08:27.583, 7, 80]+I[2, 2021-12-24T22:08:28.583, 4, 84]+I[2, 2021-12-24T22:08:29.584, 7, 91]+I[2, 2021-12-24T22:08:30.583, 8, 99]+I[1, 2021-12-24T22:08:31.583, 9, 138]+I[2, 2021-12-24T22:08:32.584, 6, 105]+I[1, 2021-12-24T22:08:33.584, 7, 145] b. ⭐ 行数聚合： 按照行数聚合就是数据行数的一个滑动窗口，比如下面案例，最新输出的一条数据的 sum 聚合结果就是最近 5 行数据的 amount 之和。 1234567891011121314151617181920212223242526272829303132333435CREATE TABLE source_table ( order_id BIGINT, product BIGINT, amount BIGINT, order_time as cast(CURRENT_TIMESTAMP as TIMESTAMP(3)), WATERMARK FOR order_time AS order_time - INTERVAL &#x27;0.001&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.order_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.order_id.max&#x27; = &#x27;2&#x27;, &#x27;fields.amount.min&#x27; = &#x27;1&#x27;, &#x27;fields.amount.max&#x27; = &#x27;2&#x27;, &#x27;fields.product.min&#x27; = &#x27;1&#x27;, &#x27;fields.product.max&#x27; = &#x27;2&#x27;);CREATE TABLE sink_table ( product BIGINT, order_time TIMESTAMP(3), amount BIGINT, one_hour_prod_amount_sum BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT product, order_time, amount, SUM(amount) OVER ( PARTITION BY product ORDER BY order_time -- 标识统计范围是一个 product 的最近 5 行数据 ROWS BETWEEN 5 PRECEDING AND CURRENT ROW ) AS one_hour_prod_amount_sumFROM source_table 预跑结果如下： script1234567891011+I[2, 2021-12-24T22:18:19.147, 1, 9]+I[1, 2021-12-24T22:18:20.147, 2, 11]+I[1, 2021-12-24T22:18:21.147, 2, 12]+I[1, 2021-12-24T22:18:22.147, 2, 12]+I[1, 2021-12-24T22:18:23.148, 2, 12]+I[1, 2021-12-24T22:18:24.147, 1, 11]+I[1, 2021-12-24T22:18:25.146, 1, 10]+I[1, 2021-12-24T22:18:26.147, 1, 9]+I[2, 2021-12-24T22:18:27.145, 2, 11]+I[2, 2021-12-24T22:18:28.148, 1, 10]+I[2, 2021-12-24T22:18:29.145, 2, 10] 当然，如果你在一个 SELECT 中有多个聚合窗口的聚合方式，Flink SQL 支持了一种简化写法，如下案例： 123456789SELECT order_id, order_time, amount, SUM(amount) OVER w AS sum_amount, AVG(amount) OVER w AS avg_amountFROM Orders-- 使用下面子句，定义 Over WindowWINDOW w AS ( PARTITION BY product ORDER BY order_time RANGE BETWEEN INTERVAL &#x27;1&#x27; HOUR PRECEDING AND CURRENT ROW) 3.8.DML：JoinsFlink 也支持了非常多的数据 Join 方式，主要包括以下三种： ⭐ 动态表（流）与动态表（流）的 Join ⭐ 动态表（流）与外部维表（比如 Redis）的 Join ⭐ 动态表字段的列转行（一种特殊的 Join） 细分 Flink SQL 支持的 Join： ⭐ Regular Join：流与流的 Join，包括 Inner Equal Join、Outer Equal Join ⭐ Interval Join：流与流的 Join，两条流一段时间区间内的 Join ⭐ Temporal Join：流与流的 Join，包括事件时间，处理时间的 Temporal Join，类似于离线中的快照 Join ⭐ Lookup Join：流与外部维表的 Join ⭐ Array Expansion：表字段的列转行，类似于 Hive 的 explode 数据炸开的列转行 ⭐ Table Function：自定义函数的表字段的列转行，支持 Inner Join 和 Left Outer Join 3.8.1.Regular Join ⭐ Regular Join 定义（支持 Batch\\Streaming）：Regular Join 其实就是和离线 Hive SQL 一样的 Regular Join，通过条件关联两条流数据输出。 ⭐ 应用场景：Join 其实在我们的数仓建设过程中应用是非常广泛的。离线数仓可以说基本上是离不开 Join 的。那么实时数仓的建设也必然离不开 Join，比如日志关联扩充维度数据，构建宽表；日志通过 ID 关联计算 CTR。 ⭐ Regular Join 包含以下几种（以 L 作为左流中的数据标识，R 作为右流中的数据标识）： ⭐ Inner Join（Inner Equal Join）：流任务中，只有两条流 Join 到才输出，输出 +[L, R] ⭐ Left Join（Outer Equal Join）：流任务中，左流数据到达之后，无论有没有 Join 到右流的数据，都会输出（Join 到输出 +[L, R]，没 Join 到输出 +[L, null]），如果右流之后数据到达之后，发现左流之前输出过没有 Join 到的数据，则会发起回撤流，先输出 -[L, null]，然后输出 +[L, R] ⭐ Right Join（Outer Equal Join）：有 Left Join 一样，左表和右表的执行逻辑完全相反 ⭐ Full Join（Outer Equal Join）：流任务中，左流或者右流的数据到达之后，无论有没有 Join 到另外一条流的数据，都会输出（对右流来说：Join 到输出 +[L, R]，没 Join 到输出 +[null, R]；对左流来说：Join 到输出 +[L, R]，没 Join 到输出 +[L, null]）。如果一条流的数据到达之后，发现之前另一条流之前输出过没有 Join 到的数据，则会发起回撤流（左流数据到达为例：回撤 -[null, R]，输出 +[L, R]，右流数据到达为例：回撤 -[L, null]，输出 +[L, R]）。 ⭐ 实际案例：案例为曝光日志关联点击日志筛选既有曝光又有点击的数据，并且补充点击的扩展参数（show inner click）： 下面这个案例为 Inner Join 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243-- 曝光日志数据CREATE TABLE show_log_table ( log_id BIGINT, show_params STRING) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;2&#x27;, &#x27;fields.show_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;100&#x27;);-- 点击日志数据CREATE TABLE click_log_table ( log_id BIGINT, click_params STRING)WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;2&#x27;, &#x27;fields.click_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( s_id BIGINT, s_params STRING, c_id BIGINT, c_params STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 流的 INNER JOIN，条件为 log_idINSERT INTO sink_tableSELECT show_log_table.log_id as s_id, show_log_table.show_params as s_params, click_log_table.log_id as c_id, click_log_table.click_params as c_paramsFROM show_log_tableINNER JOIN click_log_table ON show_log_table.log_id = click_log_table.log_id; 输出结果如下： script123456+I[5, d, 5, f]+I[5, d, 5, 8]+I[5, d, 5, 2]+I[3, 4, 3, 0]+I[3, 4, 3, 3]... 如果为 Left Join 案例： 12345678910111213141516171819202122232425262728293031323334353637383940CREATE TABLE show_log_table ( log_id BIGINT, show_params STRING) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.show_params.length&#x27; = &#x27;3&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE click_log_table ( log_id BIGINT, click_params STRING)WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.click_params.length&#x27; = &#x27;3&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( s_id BIGINT, s_params STRING, c_id BIGINT, c_params STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT show_log_table.log_id as s_id, show_log_table.show_params as s_params, click_log_table.log_id as c_id, click_log_table.click_params as c_paramsFROM show_log_tableLEFT JOIN click_log_table ON show_log_table.log_id = click_log_table.log_id; 输出结果如下： script12345678910111213+I[5, f3c, 5, c05]+I[5, 6e2, 5, 1f6]+I[5, 86b, 5, 1f6]+I[5, f3c, 5, 1f6]-D[3, 4ab, null, null]-D[3, 6f2, null, null]+I[3, 4ab, 3, 765]+I[3, 6f2, 3, 765]+I[2, 3c4, null, null]+I[3, 4ab, 3, a8b]+I[3, 6f2, 3, a8b]+I[2, c03, null, null]... 如果为 Full Join 案例： 12345678910111213141516171819202122232425262728293031323334353637383940CREATE TABLE show_log_table ( log_id BIGINT, show_params STRING) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;2&#x27;, &#x27;fields.show_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE click_log_table ( log_id BIGINT, click_params STRING)WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;2&#x27;, &#x27;fields.click_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( s_id BIGINT, s_params STRING, c_id BIGINT, c_params STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT show_log_table.log_id as s_id, show_log_table.show_params as s_params, click_log_table.log_id as c_id, click_log_table.click_params as c_paramsFROM show_log_tableFULL JOIN click_log_table ON show_log_table.log_id = click_log_table.log_id; 输出结果如下： script1234567891011+I[null, null, 7, 6]+I[6, 5, null, null]-D[1, c, null, null]+I[1, c, 1, 2]+I[3, 1, null, null]+I[null, null, 7, d]+I[10, 0, null, null]+I[null, null, 2, 6]-D[null, null, 7, 6]-D[null, null, 7, d]... 关于 Regular Join 的注意事项： ⭐ 实时 Regular Join 可以不是 等值 join。等值 join 和 非等值 join 区别在于，等值 join 数据 shuffle 策略是 Hash，会按照 Join on 中的等值条件作为 id 发往对应的下游；非等值 join 数据 shuffle 策略是 Global，所有数据发往一个并发，按照非等值条件进行关联 ⭐ Join 的流程是左流新来一条数据之后，会和右流中符合条件的所有数据做 Join，然后输出。 ⭐ 流的上游是无限的数据，所以要做到关联的话，Flink 会将两条流的所有数据都存储在 State 中，所以 Flink 任务的 State 会无限增大，因此你需要为 State 配置合适的 TTL，以防止 State 过大。 ⭐ SQL 语义： 详细的 SQL 语义案例可以参考： todo 把之前写的所有的系列文章都粘贴进来 todo https://mp.weixin.qq.com/s/Z8QfKfhrX5KEnR-s7gRtsA 3.8.2.Interval Join（时间区间 Join） ⭐ Interval Join 定义（支持 Batch\\Streaming）：Interval Join 在离线的概念中是没有的。Interval Join 可以让一条流去 Join 另一条流中前后一段时间内的数据。 ⭐ 应用场景：为什么有 Regular Join 还要 Interval Join 呢？刚刚的案例也讲了，Regular Join 会产生回撤流，但是在实时数仓中一般写入的 sink 都是类似于 Kafka 这样的消息队列，然后后面接 clickhouse 等引擎，这些引擎又不具备处理回撤流的能力。所以博主理解 Interval Join 就是用于消灭回撤流的。 ⭐ Interval Join 包含以下几种（以 L 作为左流中的数据标识，R 作为右流中的数据标识）： ⭐ Inner Interval Join：流任务中，只有两条流 Join 到（满足 Join on 中的条件：两条流的数据在时间区间 + 满足其他等值条件）才输出，输出 +[L, R] ⭐ Left Interval Join：流任务中，左流数据到达之后，如果没有 Join 到右流的数据，就会等待（放在 State 中等），如果之后右流之后数据到达之后，发现能和刚刚那条左流数据 Join 到，则会输出 +[L, R]。事件时间中随着 Watermark 的推进（也支持处理时间）。如果发现发现左流 State 中的数据过期了，就把左流中过期的数据从 State 中删除，然后输出 +[L, null]，如果右流 State 中的数据过期了，就直接从 State 中删除。 ⭐ Right Interval Join：和 Left Interval Join 执行逻辑一样，只不过左表和右表的执行逻辑完全相反 ⭐ Full Interval Join：流任务中，左流或者右流的数据到达之后，如果没有 Join 到另外一条流的数据，就会等待（左流放在左流对应的 State 中等，右流放在右流对应的 State 中等），如果之后另一条流数据到达之后，发现能和刚刚那条数据 Join 到，则会输出 +[L, R]。事件时间中随着 Watermark 的推进（也支持处理时间），发现 State 中的数据能够过期了，就将这些数据从 State 中删除并且输出（左流过期输出 +[L, null]，右流过期输出 -[null, R]） 可以发现 Inner Interval Join 和其他三种 Outer Interval Join 的区别在于，Outer 在随着时间推移的过程中，如果有数据过期了之后，会根据是否是 Outer 将没有 Join 到的数据也给输出。 ⭐ 实际案例：还是刚刚的案例，曝光日志关联点击日志筛选既有曝光又有点击的数据，条件是曝光关联之后发生 4 小时之内的点击，并且补充点击的扩展参数（show inner interval click）： 下面为 Inner Interval Join： 1234567891011121314151617181920212223242526272829303132333435363738394041424344CREATE TABLE show_log_table ( log_id BIGINT, show_params STRING, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.show_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE click_log_table ( log_id BIGINT, click_params STRING, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time)WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.click_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( s_id BIGINT, s_params STRING, c_id BIGINT, c_params STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT show_log_table.log_id as s_id, show_log_table.show_params as s_params, click_log_table.log_id as c_id, click_log_table.click_params as c_paramsFROM show_log_table INNER JOIN click_log_table ON show_log_table.log_id = click_log_table.log_idAND show_log_table.row_time BETWEEN click_log_table.row_time - INTERVAL &#x27;4&#x27; HOUR AND click_log_table.row_time; 输出结果如下： script123456786&gt; +I[2, a, 2, 6]6&gt; +I[2, 6, 2, 6]2&gt; +I[4, 1, 4, 5]2&gt; +I[10, 8, 10, d]2&gt; +I[10, 7, 10, d]2&gt; +I[10, d, 10, d]2&gt; +I[5, b, 5, d]6&gt; +I[1, a, 1, 7] 如果是 Left Interval Join： 1234567891011121314151617181920212223242526272829303132333435363738394041424344CREATE TABLE show_log ( log_id BIGINT, show_params STRING, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.show_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE click_log ( log_id BIGINT, click_params STRING, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time)WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.click_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( s_id BIGINT, s_params STRING, c_id BIGINT, c_params STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT show_log.log_id as s_id, show_log.show_params as s_params, click_log.log_id as c_id, click_log.click_params as c_paramsFROM show_log LEFT JOIN click_log ON show_log.log_id = click_log.log_idAND show_log.row_time BETWEEN click_log.row_time - INTERVAL &#x27;5&#x27; SECOND AND click_log.row_time + INTERVAL &#x27;5&#x27; SECOND; 输出结果如下： script12345+I[6, e, 6, 7]+I[11, d, null, null]+I[7, b, null, null]+I[8, 0, 8, 3]+I[13, 6, null, null] 如果是 Full Interval Join： 1234567891011121314151617181920212223242526272829303132333435363738394041424344CREATE TABLE show_log ( log_id BIGINT, show_params STRING, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.show_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;5&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;15&#x27;);CREATE TABLE click_log ( log_id BIGINT, click_params STRING, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time)WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.click_params.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( s_id BIGINT, s_params STRING, c_id BIGINT, c_params STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT show_log.log_id as s_id, show_log.show_params as s_params, click_log.log_id as c_id, click_log.click_params as c_paramsFROM show_log LEFT JOIN click_log ON show_log.log_id = click_log.log_idAND show_log.row_time BETWEEN click_log.row_time - INTERVAL &#x27;5&#x27; SECOND AND click_log.row_time + INTERVAL &#x27;5&#x27; SECOND; 输出结果如下： script123456+I[6, 1, null, null]+I[7, 3, 7, 8]+I[null, null, 6, 6]+I[null, null, 4, d]+I[8, d, null, null]+I[null, null, 3, b] 关于 Interval Join 的注意事项： ⭐ 实时 Interval Join 可以不是 等值 join。等值 join 和 非等值 join 区别在于，等值 join 数据 shuffle 策略是 Hash，会按照 Join on 中的等值条件作为 id 发往对应的下游；非等值 join 数据 shuffle 策略是 Global，所有数据发往一个并发，然后将满足条件的数据进行关联输出 ⭐ SQL 语义： 关于详细的 SQL 语义可以参考。 todo https://mp.weixin.qq.com/s/p9Y9qzqMgd8DTs9Fw_25kA 3.8.3.Temporal Join（快照 Join） ⭐ Temporal Join 定义（支持 Batch\\Streaming）：Temporal Join 在离线的概念中其实是没有类似的 Join 概念的，但是离线中常常会维护一种表叫做 拉链快照表，使用一个明细表去 join 这个 拉链快照表 的 join 方式就叫做 Temporal Join。而 Flink SQL 中也有对应的概念，表叫做 Versioned Table，使用一个明细表去 join 这个 Versioned Table 的 join 操作就叫做 Temporal Join。Temporal Join 中，Versioned Table 其实就是对同一条 key（在 DDL 中以 primary key 标记同一个 key）的历史版本（根据时间划分版本）做一个维护，当有明细表 Join 这个表时，可以根据明细表中的时间版本选择 Versioned Table 对应时间区间内的快照数据进行 join。 ⭐ 应用场景：比如常见的汇率数据（实时的根据汇率计算总金额），在 12:00 之前（事件时间），人民币和美元汇率是 7:1，在 12:00 之后变为 6:1，那么在 12:00 之前数据就要按照 7:1 进行计算，12:00 之后就要按照 6:1 计算。在事件时间语义的任务中，事件时间 12:00 之前的数据，要按照 7:1 进行计算，12:00 之后的数据，要按照 6:1 进行计算。这其实就是离线中快照的概念，维护具体汇率的表在 Flink SQL 体系中就叫做 Versioned Table。 ⭐ Verisoned Table：Verisoned Table 中存储的数据通常是来源于 CDC 或者会发生更新的数据。Flink SQL 会为 Versioned Table 维护 Primary Key 下的所有历史时间版本的数据。举一个汇率的场景的案例来看一下一个 Versioned Table 的两种定义方式。 ⭐ PRIMARY KEY 定义方式： 12345678910111213-- 定义一个汇率 versioned 表，其中 versioned 表的概念下文会介绍到CREATE TABLE currency_rates ( currency STRING, conversion_rate DECIMAL(32, 2), update_time TIMESTAMP(3) METADATA FROM `values.source.timestamp` VIRTUAL, WATERMARK FOR update_time AS update_time, -- PRIMARY KEY 定义方式 PRIMARY KEY(currency) NOT ENFORCED) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;value.format&#x27; = &#x27;debezium-json&#x27;, /* ... */); ⭐ Deduplicate 定义方式： 12345678910111213141516171819202122-- 定义一个 append-only 的数据源表CREATE TABLE currency_rates ( currency STRING, conversion_rate DECIMAL(32, 2), update_time TIMESTAMP(3) METADATA FROM `values.source.timestamp` VIRTUAL, WATERMARK FOR update_time AS update_time) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;value.format&#x27; = &#x27;debezium-json&#x27;, /* ... */);-- 将数据源表按照 Deduplicate 方式定义为 Versioned TableCREATE VIEW versioned_rates ASSELECT currency, conversion_rate, update_time -- 1. 定义 `update_time` 为时间字段 FROM ( SELECT *, ROW_NUMBER() OVER (PARTITION BY currency -- 2. 定义 `currency` 为主键 ORDER BY update_time DESC -- 3. ORDER BY 中必须是时间戳列 ) AS rownum FROM currency_rates)WHERE rownum = 1; ⭐ Temporal Join 支持的时间语义：事件时间、处理时间 ⭐ 实际案例：就是上文提到的汇率计算。 以 事件时间 任务举例： 123456789101112131415161718192021222324252627282930313233-- 1. 定义一个输入订单表CREATE TABLE orders ( order_id STRING, price DECIMAL(32,2), currency STRING, order_time TIMESTAMP(3), WATERMARK FOR order_time AS order_time) WITH (/* ... */);-- 2. 定义一个汇率 versioned 表，其中 versioned 表的概念下文会介绍到CREATE TABLE currency_rates ( currency STRING, conversion_rate DECIMAL(32, 2), update_time TIMESTAMP(3) METADATA FROM `values.source.timestamp` VIRTUAL, WATERMARK FOR update_time AS update_time, PRIMARY KEY(currency) NOT ENFORCED) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;value.format&#x27; = &#x27;debezium-json&#x27;, /* ... */);SELECT order_id, price, currency, conversion_rate, order_time,FROM orders-- 3. Temporal Join 逻辑-- SQL 语法为：FOR SYSTEM_TIME AS OFLEFT JOIN currency_rates FOR SYSTEM_TIME AS OF orders.order_timeON orders.currency = currency_rates.currency; 结果如下，可以看到相同的货币汇率会根据具体数据的事件时间不同 Join 到对应时间的汇率： script1234order_id price 货币 汇率 order_time======== ===== ======== =============== =========o_001 11.11 EUR 1.14 12:00:00o_002 12.51 EUR 1.10 12:06:00 注意： ⭐ 事件时间的 Temporal Join 一定要给左右两张表都设置 Watermark。 ⭐ 事件时间的 Temporal Join 一定要把 Versioned Table 的主键包含在 Join on 的条件中。 还是相同的案例，如果是 处理时间 语义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474810:15&gt; SELECT * FROM LatestRates;currency rate======== ======US Dollar 102Euro 114Yen 110:30&gt; SELECT * FROM LatestRates;currency rate======== ======US Dollar 102Euro 114Yen 1-- 10:42 时，Euro 的汇率从 114 变为 11610:52&gt; SELECT * FROM LatestRates;currency rate======== ======US Dollar 102Euro 116 &lt;==== 从 114 变为 116Yen 1-- 从 Orders 表查询数据SELECT * FROM Orders;amount currency====== ========= 2 Euro &lt;== 在处理时间 10:15 到达的一条数据 1 US Dollar &lt;== 在处理时间 10:30 到达的一条数据 2 Euro &lt;== 在处理时间 10:52 到达的一条数据-- 执行关联查询SELECT o.amount, o.currency, r.rate, o.amount * r.rateFROM Orders AS o JOIN LatestRates FOR SYSTEM_TIME AS OF o.proctime AS r ON r.currency = o.currency-- 结果如下：amount currency rate amount*rate====== ========= ======= ============ 2 Euro 114 228 &lt;== 在处理时间 10:15 到达的一条数据 1 US Dollar 102 102 &lt;== 在处理时间 10:30 到达的一条数据 2 Euro 116 232 &lt;== 在处理时间 10:52 到达的一条数据 可以发现处理时间就比较好理解了，因为处理时间语义中是根据左流数据到达的时间决定拿到的汇率值。Flink 就只为 LatestRates 维护了最新的状态数据，不需要关心历史版本的数据。 3.8.4.Lookup Join（维表 Join） ⭐ Lookup Join 定义（支持 Batch\\Streaming）：Lookup Join 其实就是维表 Join，比如拿离线数仓来说，常常会有用户画像，设备画像等数据，而对应到实时数仓场景中，这种实时获取外部缓存的 Join 就叫做维表 Join。 ⭐ 应用场景：小伙伴萌会问，我们既然已经有了上面介绍的 Regular Join，Interval Join 等，为啥还需要一种 Lookup Join？因为上面说的这几种 Join 都是流与流之间的 Join，而 Lookup Join 是流与 Redis，Mysql，HBase 这种存储介质的 Join。Lookup 的意思就是实时查找，而实时的画像数据一般都是存储在 Redis，Mysql，HBase 中，这就是 Lookup Join 的由来 ⭐ 实际案例：使用曝光用户日志流（show_log）关联用户画像维表（user_profile）关联到用户的维度之后，提供给下游计算分性别，年龄段的曝光用户数使用。 来一波输入数据： 曝光用户日志流（show_log）数据（数据存储在 kafka 中）： script123456log_id timestamp user_id1 2021-11-01 00:01:03 a2 2021-11-01 00:03:00 b3 2021-11-01 00:05:00 c4 2021-11-01 00:06:00 b5 2021-11-01 00:07:00 c 用户画像维表（user_profile）数据（数据存储在 redis 中）： script1234user_id(主键) age sexa 12-18 男b 18-24 女c 18-24 男 注意： redis 中的数据结构存储是按照 key，value 去存储的。其中 key 为 user_id，value 为 age，sex 的 json。 具体 SQL： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CREATE TABLE show_log ( log_id BIGINT, `timestamp` as cast(CURRENT_TIMESTAMP as timestamp(3)), user_id STRING, proctime AS PROCTIME())WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.user_id.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE user_profile ( user_id STRING, age STRING, sex STRING ) WITH ( &#x27;connector&#x27; = &#x27;redis&#x27;, &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, &#x27;port&#x27; = &#x27;6379&#x27;, &#x27;format&#x27; = &#x27;json&#x27;, &#x27;lookup.cache.max-rows&#x27; = &#x27;500&#x27;, &#x27;lookup.cache.ttl&#x27; = &#x27;3600&#x27;, &#x27;lookup.max-retries&#x27; = &#x27;1&#x27;);CREATE TABLE sink_table ( log_id BIGINT, `timestamp` TIMESTAMP(3), user_id STRING, proctime TIMESTAMP(3), age STRING, sex STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- lookup join 的 query 逻辑INSERT INTO sink_tableSELECT s.log_id as log_id , s.`timestamp` as `timestamp` , s.user_id as user_id , s.proctime as proctime , u.sex as sex , u.age as ageFROM show_log AS sLEFT JOIN user_profile FOR SYSTEM_TIME AS OF s.proctime AS uON s.user_id = u.user_id 输出数据如下： script123456log_id timestamp user_id age sex1 2021-11-01 00:01:03 a 12-18 男2 2021-11-01 00:03:00 b 18-24 女3 2021-11-01 00:05:00 c 18-24 男4 2021-11-01 00:06:00 b 18-24 女5 2021-11-01 00:07:00 c 18-24 男 注意： 实时的 lookup 维表关联能使用 处理时间 去做关联。 ⭐ SQL 语义： 详细 SQL 语义及案例可见： todo https://mp.weixin.qq.com/s/ku11tCZp7CAFzpkqd4J1cQ 其实，Flink 官方并没有提供 redis 的维表 connector 实现。 没错，博主自己实现了一套。关于 redis 维表的 connector 实现，直接参考下面的文章。都是可以从 github 上找到源码拿来用的！ 注意： ⭐ 同一条数据关联到的维度数据可能不同：实时数仓中常用的实时维表都是在不断的变化中的，当前流表数据关联完维表数据后，如果同一个 key 的维表的数据发生了变化，已关联到的维表的结果数据不会再同步更新。举个例子，维表中 user_id 为 1 的数据在 08：00 时 age 由 12-18 变为了 18-24，那么当我们的任务在 08：01 failover 之后从 07：59 开始回溯数据时，原本应该关联到 12-18 的数据会关联到 18-24 的 age 数据。这是有可能会影响数据质量的。所以小伙伴萌在评估你们的实时任务时要考虑到这一点。 ⭐ 会发生实时的新建及更新的维表博主建议小伙伴萌应该建立起数据延迟的监控机制，防止出现流表数据先于维表数据到达，导致关联不到维表数据 再说说维表常见的性能问题及优化思路。 所有的维表性能问题都可以总结为：高 qps 下访问维表存储引擎产生的任务背压，数据产出延迟问题。 举个例子： ⭐ 在没有使用维表的情况下：一条数据从输入 Flink 任务到输出 Flink 任务的时延假如为 0.1 ms，那么并行度为 1 的任务的吞吐可以达到 1 query / 0.1 ms = 1w qps。 ⭐ 在使用维表之后：每条数据访问维表的外部存储的时长为 2 ms，那么一条数据从输入 Flink 任务到输出 Flink 任务的时延就会变成 2.1 ms，那么同样并行度为 1 的任务的吞吐只能达到1 query / 2.1 ms = 476 qps。两者的吞吐量相差 21 倍。 这就是为什么维表 join 的算子会产生背压，任务产出会延迟。 那么当然，解决方案也是有很多的。抛开 Flink SQL 想一下，如果我们使用 DataStream API，甚至是在做一个后端应用，需要访问外部存储时，常用的优化方案有哪些？这里列举一下： ⭐ 按照 redis 维表的 key 分桶 + local cache：通过按照 key 分桶的方式，让大多数据的维表关联的数据访问走之前访问过得 local cache 即可。这样就可以把访问外部存储 2.1 ms 处理一个 query 变为访问内存的 0.1 ms 处理一个 query 的时长。 ⭐ 异步访问外存：DataStream api 有异步算子，可以利用线程池去同时多次请求维表外部存储。这样就可以把 2.1 ms 处理 1 个 query 变为 2.1 ms 处理 10 个 query。吞吐可变优化到 10 / 2.1 ms = 4761 qps。 ⭐ 批量访问外存：除了异步访问之外，我们还可以批量访问外部存储。举一个例子：在访问 redis 维表的 1 query 占用 2.1 ms 时长中，其中可能有 2 ms 都是在网络请求上面的耗时 ，其中只有 0.1 ms 是 redis server 处理请求的时长。那么我们就可以使用 redis 提供的 pipeline 能力，在客户端（也就是 flink 任务 lookup join 算子中），攒一批数据，使用 pipeline 去同时访问 redis sever。这样就可以把 2.1 ms 处理 1 个 query 变为 7ms（2ms + 50 * 0.1ms） 处理 50 个 query。吞吐可变为 50 query / 7 ms = 7143 qps。博主这里测试了下使用 redis pipeline 和未使用的时长消耗对比。如下图所示。 博主认为上述优化效果中，最好用的是 1 + 3，2 相比 3 还是一条一条发请求，性能会差一些。 既然 DataStream 可以这样做，Flink SQL 必须必的也可以借鉴上面的这些优化方案。具体怎么操作呢？看下文骚操作 ⭐ 按照 redis 维表的 key 分桶 + local cache：sql 中如果要做分桶，得先做 group by，但是如果做了 group by 的聚合，就只能在 udaf 中做访问 redis 处理，并且 udaf 产出的结果只能是一条，所以这种实现起来非常复杂。我们选择不做 keyby 分桶。但是我们可以直接使用 local cache 去做本地缓存，虽然【直接缓存】的效果比【先按照 key 分桶再做缓存】的效果差，但是也能一定程度上减少访问 redis 压力。在博主实现的 redis connector 中，内置了 local cache 的实现，小伙伴萌可以参考下面这部篇文章进行配置。 ⭐ 异步访问外存：目前博主实现的 redis connector 不支持异步访问，但是官方实现的 hbase connector 支持这个功能，参考下面链接文章的，点开之后搜索 lookup.async。https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/connectors/table/hbase/ ⭐ 批量访问外存：这玩意官方必然没有实现啊，但是，但是，但是，经过博主周末两天的疯狂 debug，改了改源码，搞定了基于 redis 的批量访问外存优化的功能。具体可以参考下文。 todo https://mp.weixin.qq.com/s/ku11tCZp7CAFzpkqd4J1cQ 3.8.5.Array Expansion（数组列转行） ⭐ 应用场景（支持 Batch\\Streaming）：将表中 ARRAY 类型字段（列）拍平，转为多行 ⭐ 实际案例：比如某些场景下，日志是合并、攒批上报的，就可以使用这种方式将一个 Array 转为多行。 123456789101112131415161718192021222324CREATE TABLE show_log_table ( log_id BIGINT, show_params ARRAY&lt;STRING&gt;) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( log_id BIGINT, show_param STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT log_id, t.show_param as show_paramFROM show_log_table-- array 炸开语法CROSS JOIN UNNEST(show_params) AS t (show_param) show_log_table 原始数据： 12+I[7, [a, b, c]]+I[5, [d, e, f]] 输出结果如下所示： script12345678-- +I[7, [a, b, c]] 一行转为 3 行+I[7, a]+I[7, b]+I[7, b]-- +I[5, [d, e, f]] 一行转为 3 行+I[5, d]+I[5, e]+I[5, f] 3.8.6.Table Function（自定义列转行） ⭐ 应用场景（支持 Batch\\Streaming）：这个其实和 Array Expansion 功能类似，但是 Table Function 本质上是个 UDTF 函数，和离线 Hive SQL 一样，我们可以自定义 UDTF 去决定列转行的逻辑 ⭐ Table Function 使用分类： ⭐ Inner Join Table Function：如果 UDTF 返回结果为空，则相当于 1 行转为 0 行，这行数据直接被丢弃 ⭐ Left Join Table Function：如果 UDTF 返回结果为空，折行数据不会被丢弃，只会在结果中填充 null 值 ⭐ 实际案例：直接上 SQL 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class TableFunctionInnerJoin_Test &#123; public static void main(String[] args) throws Exception &#123; FlinkEnv flinkEnv = FlinkEnvUtils.getStreamTableEnv(args); String sql = &quot;CREATE FUNCTION user_profile_table_func AS &#x27;flink.examples.sql._07.query._06_joins._06_table_function&quot; + &quot;._01_inner_join.TableFunctionInnerJoin_Test$UserProfileTableFunction&#x27;;\\n&quot; + &quot;\\n&quot; + &quot;CREATE TABLE source_table (\\n&quot; + &quot; user_id BIGINT NOT NULL,\\n&quot; + &quot; name STRING,\\n&quot; + &quot; row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)),\\n&quot; + &quot; WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;datagen&#x27;,\\n&quot; + &quot; &#x27;rows-per-second&#x27; = &#x27;10&#x27;,\\n&quot; + &quot; &#x27;fields.name.length&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.user_id.max&#x27; = &#x27;10&#x27;\\n&quot; + &quot;);\\n&quot; + &quot;\\n&quot; + &quot;CREATE TABLE sink_table (\\n&quot; + &quot; user_id BIGINT,\\n&quot; + &quot; name STRING,\\n&quot; + &quot; age INT,\\n&quot; + &quot; row_time TIMESTAMP(3)\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;print&#x27;\\n&quot; + &quot;);\\n&quot; + &quot;\\n&quot; + &quot;INSERT INTO sink_table\\n&quot; + &quot;SELECT user_id,\\n&quot; + &quot; name,\\n&quot; + &quot; age,\\n&quot; + &quot; row_time\\n&quot; + &quot;FROM source_table,\\n&quot; // Table Function Join 语法对应 LATERAL TABLE + &quot;LATERAL TABLE(user_profile_table_func(user_id)) t(age)&quot;; Arrays.stream(sql.split(&quot;;&quot;)) .forEach(flinkEnv.streamTEnv()::executeSql); &#125; public static class UserProfileTableFunction extends TableFunction&lt;Integer&gt; &#123; public void eval(long userId) &#123; // 自定义输出逻辑 if (userId &lt;= 5) &#123; // 一行转 1 行 collect(1); &#125; else &#123; // 一行转 3 行 collect(1); collect(2); collect(3); &#125; &#125; &#125;&#125; 执行结果如下： 123456789101112-- &lt;= 5，则只有 1 行结果+I[3, 7, 1, 2021-05-01T18:23:42.560]-- &gt; 5，则有行 3 结果+I[8, e, 1, 2021-05-01T18:23:42.560]+I[8, e, 2, 2021-05-01T18:23:42.560]+I[8, e, 3, 2021-05-01T18:23:42.560]-- &lt;= 5，则只有 1 行结果+I[4, 9, 1, 2021-05-01T18:23:42.561]-- &gt; 5，则有行 3 结果+I[8, c, 1, 2021-05-01T18:23:42.561]+I[8, c, 2, 2021-05-01T18:23:42.561]+I[8, c, 3, 2021-05-01T18:23:42.561] 3.9 DML：集合操作集合操作支持 Batch\\Streaming 任务。 ⭐ UNION：将集合合并并且去重。 ⭐ UNION ALL：将集合合并，不做去重。 1234567891011121314151617181920212223242526272829Flink SQL&gt; create view t1(s) as values (&#x27;c&#x27;), (&#x27;a&#x27;), (&#x27;b&#x27;), (&#x27;b&#x27;), (&#x27;c&#x27;);Flink SQL&gt; create view t2(s) as values (&#x27;d&#x27;), (&#x27;e&#x27;), (&#x27;a&#x27;), (&#x27;b&#x27;), (&#x27;b&#x27;);Flink SQL&gt; (SELECT s FROM t1) UNION (SELECT s FROM t2);+---+| s|+---+| c|| a|| b|| d|| e|+---+Flink SQL&gt; (SELECT s FROM t1) UNION ALL (SELECT s FROM t2);+---+| c|+---+| c|| a|| b|| b|| c|| d|| e|| a|| b|| b|+---+ ⭐ Intersect：交集并且去重 ⭐ Intersect ALL：交集不做去重 123456789101112131415161718Flink SQL&gt; create view t1(s) as values (&#x27;c&#x27;), (&#x27;a&#x27;), (&#x27;b&#x27;), (&#x27;b&#x27;), (&#x27;c&#x27;);Flink SQL&gt; create view t2(s) as values (&#x27;d&#x27;), (&#x27;e&#x27;), (&#x27;a&#x27;), (&#x27;b&#x27;), (&#x27;b&#x27;);Flink SQL&gt; (SELECT s FROM t1) INTERSECT (SELECT s FROM t2);+---+| s|+---+| a|| b|+---+Flink SQL&gt; (SELECT s FROM t1) INTERSECT ALL (SELECT s FROM t2);+---+| s|+---+| a|| b|| b|+---+ ⭐ Except：差集并且去重 ⭐ Except ALL：差集不做去重 1234567891011121314Flink SQL&gt; (SELECT s FROM t1) EXCEPT (SELECT s FROM t2);+---+| s |+---+| c |+---+Flink SQL&gt; (SELECT s FROM t1) EXCEPT ALL (SELECT s FROM t2);+---+| s |+---+| c || c |+---+ 上述 SQL 在流式任务中，如果一条左流数据先来了，没有从右流集合数据中找到对应的数据时会直接输出，当右流对应数据后续来了之后，会下发回撤流将之前的数据給撤回。这也是一个回撤流。 ⭐ In 子查询：这个大家比较熟悉了，但是注意，In 子查询的结果集只能有一列 12345SELECT user, amountFROM OrdersWHERE product IN ( SELECT product FROM NewProducts) 上述 SQL 的 In 子句其实就和之前介绍到的 Inner Join 类似。并且 In 子查询也会涉及到大状态问题，大家注意设置 State 的 TTL。 3.10.DML：Order By、Limit 子句3.10.1.Order By 子句支持 Batch\\Streaming，但在实时任务中一般用的非常少。 实时任务中，Order By 子句中必须要有时间属性字段，并且时间属性必须为升序时间属性，即 WATERMARK FOR rowtime_column AS rowtime_column - INTERVAL &#39;0.001&#39; SECOND 或者 WATERMARK FOR rowtime_column AS rowtime_column。 举例： 123456789101112131415161718192021CREATE TABLE source_table_1 ( user_id BIGINT NOT NULL, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( user_id BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT user_idFROM source_table_1Order By row_time, user_id desc 3.10.2.Limit 子句支持 Batch\\Streaming，但实时场景一般不使用，但是此处依然举一个例子： 123456789101112131415161718192021CREATE TABLE source_table_1 ( user_id BIGINT NOT NULL, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE sink_table ( user_id BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);INSERT INTO sink_tableSELECT user_idFROM source_table_1Limit 3 结果如下，只有 3 条输出： script123+I[5]+I[9]+I[4] 3.11.DML：TopN 子句 ⭐ TopN 定义（支持 Batch\\Streaming）：TopN 其实就是对应到离线数仓中的 row_number()，可以使用 row_number() 对某一个分组的数据进行排序 ⭐ 应用场景：根据 某个排序 条件，计算某个分组下的排行榜数据 ⭐ SQL 语法标准： 1234567SELECT [column_list]FROM ( SELECT [column_list], ROW_NUMBER() OVER ([PARTITION BY col1[, col2...]] ORDER BY col1 [asc|desc][, col2 [asc|desc]...]) AS rownum FROM table_name)WHERE rownum &lt;= N [AND conditions] ⭐ ROW_NUMBER()：标识 TopN 排序子句 ⭐ PARTITION BY col1[, col2...]：标识分区字段，代表按照这个 col 字段作为分区粒度对数据进行排序取 topN，比如下述案例中的 partition by key，就是根据需求中的搜索关键词（key）做为分区 ⭐ ORDER BY col1 [asc|desc][, col2 [asc|desc]...]：标识 TopN 的排序规则，是按照哪些字段、顺序或逆序进行排序 ⭐ WHERE rownum &lt;= N：这个子句是一定需要的，只有加上了这个子句，Flink 才能将其识别为一个 TopN 的查询，其中 N 代表 TopN 的条目数 ⭐ [AND conditions]：其他的限制条件也可以加上 ⭐ 实际案例：取某个搜索关键词下的搜索热度前 10 名的词条数据。 输入数据为搜索词条数据的搜索热度数据，当搜索热度发生变化时，会将变化后的数据写入到数据源的 Kafka 中： 数据源 schema： 123456789101112131415161718192021222324252627282930313233343536373839404142-- 字段名 备注-- key 搜索关键词-- name 搜索热度名称-- search_cnt 热搜消费热度（比如 3000）-- timestamp 消费词条时间戳CREATE TABLE source_table ( name BIGINT NOT NULL, search_cnt BIGINT NOT NULL, key BIGINT NOT NULL, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( ...);-- 数据汇 schema：-- key 搜索关键词-- name 搜索热度名称-- search_cnt 热搜消费热度（比如 3000）-- timestamp 消费词条时间戳CREATE TABLE sink_table ( key BIGINT, name BIGINT, search_cnt BIGINT, `timestamp` TIMESTAMP(3)) WITH ( ...);-- DML 逻辑INSERT INTO sink_tableSELECT key, name, search_cnt, row_time as `timestamp`FROM ( SELECT key, name, search_cnt, row_time, -- 根据热搜关键词 key 作为 partition key，然后按照 search_cnt 倒排取前 100 名 ROW_NUMBER() OVER (PARTITION BY key ORDER BY search_cnt desc) AS rownum FROM source_table)WHERE rownum &lt;= 100 输出结果： script1234567-D[关键词1, 词条1, 4944]+I[关键词1, 词条1, 8670]+I[关键词1, 词条2, 1735]-D[关键词1, 词条3, 6641]+I[关键词1, 词条3, 6928]-D[关键词1, 词条4, 6312]+I[关键词1, 词条4, 7287] 可以看到输出数据是有回撤数据的，为什么会出现回撤，我们来看看 SQL 语义。 ⭐ SQL 语义 上面的 SQL 会翻译成以下三个算子： ⭐ 数据源：数据源即最新的词条下面的搜索词的搜索热度数据，消费到 Kafka 中数据后，按照 partition key 将数据进行 hash 分发到下游排序算子，相同的 key 数据将会发送到一个并发中 ⭐ 排序算子：为每个 Key 维护了一个 TopN 的榜单数据，接受到上游的一条数据后，如果 TopN 榜单还没有到达 N 条，则将这条数据加入 TopN 榜单后，直接下发数据，如果到达 N 条之后，经过 TopN 计算，发现这条数据比原有的数据排序靠前，那么新的 TopN 排名就会有变化，就变化了的这部分数据之前下发的排名数据撤回（即回撤数据），然后下发新的排名数据 ⭐ 数据汇：接收到上游的数据之后，然后输出到外部存储引擎中 上面三个算子也是会 24 小时一直运行的。 3.12.DML：Window TopN ⭐ Window TopN 定义（支持 Streaming）：Window TopN 是一种特殊的 TopN，它的返回结果是每一个窗口内的 N 个最小值或者最大值。 ⭐ 应用场景：小伙伴萌会问了，我有了 TopN 为啥还需要 Window TopN 呢？还记得上文介绍 TopN 说道的 TopN 时会出现中间结果，从而出现回撤数据的嘛？Window TopN 不会出现回撤数据，因为 Window TopN 实现是在窗口结束时输出最终结果，不会产生中间结果。而且注意，因为是窗口上面的操作，Window TopN 在窗口结束时，会自动把 State 给清除。 ⭐ SQL 语法标准： 1234567SELECT [column_list]FROM ( SELECT [column_list], ROW_NUMBER() OVER (PARTITION BY window_start, window_end [, col_key1...] ORDER BY col1 [asc|desc][, col2 [asc|desc]...]) AS rownum FROM table_name) -- windowing TVFWHERE rownum &lt;= N [AND conditions] ⭐ 实际案例：取当前这一分钟的搜索关键词下的搜索热度前 10 名的词条数据 输入表字段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- 字段名 备注-- key 搜索关键词-- name 搜索热度名称-- search_cnt 热搜消费热度（比如 3000）-- timestamp 消费词条时间戳CREATE TABLE source_table ( name BIGINT NOT NULL, search_cnt BIGINT NOT NULL, key BIGINT NOT NULL, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time) WITH ( ...);-- 输出表字段：-- 字段名 备注-- key 搜索关键词-- name 搜索热度名称-- search_cnt 热搜消费热度（比如 3000）-- window_start 窗口开始时间戳-- window_end 窗口结束时间戳CREATE TABLE sink_table ( key BIGINT, name BIGINT, search_cnt BIGINT, window_start TIMESTAMP(3), window_end TIMESTAMP(3)) WITH ( ...);-- 处理 sql：INSERT INTO sink_tableSELECT key, name, search_cnt, window_start, window_endFROM ( SELECT key, name, search_cnt, window_start, window_end, ROW_NUMBER() OVER (PARTITION BY window_start, window_end, key ORDER BY search_cnt desc) AS rownum FROM ( SELECT window_start, window_end, key, name, max(search_cnt) as search_cnt -- window tvf 写法 FROM TABLE(TUMBLE(TABLE source_table, DESCRIPTOR(row_time), INTERVAL &#x27;1&#x27; MINUTES)) GROUP BY window_start, window_end, key, name ))WHERE rownum &lt;= 100 输出结果： script12345+I[关键词1, 词条1, 8670, 2021-1-28T22:34, 2021-1-28T22:35]+I[关键词1, 词条2, 6928, 2021-1-28T22:34, 2021-1-28T22:35]+I[关键词1, 词条3, 1735, 2021-1-28T22:34, 2021-1-28T22:35]+I[关键词1, 词条4, 7287, 2021-1-28T22:34, 2021-1-28T22:35]... 可以看到结果是符合预期的，其中没有回撤数据。 ⭐ SQL 语义 ⭐ 数据源：数据源即最新的词条下面的搜索词的搜索热度数据，消费到 Kafka 中数据后，将数据按照窗口聚合的 key 通过 hash 分发策略发送到下游窗口聚合算子 ⭐ 窗口聚合算子：进行窗口聚合计算，随着时间的推进，将窗口聚合结果计算完成发往下游窗口排序算子 ⭐ 窗口排序算子：这个算子其实也是一个窗口算子，只不过这个窗口算子为每个 Key 维护了一个 TopN 的榜单数据，接受到上游发送的窗口结果数据进行排序，随着时间的推进，窗口的结束，将排序的结果输出到下游数据汇算子。 ⭐ 数据汇：接收到上游的数据之后，然后输出到外部存储引擎中 3.13.DML：Deduplication ⭐ Deduplication 定义（支持 Batch\\Streaming）：Deduplication 其实就是去重，也即上文介绍到的 TopN 中 row_number = 1 的场景，但是这里有一点不一样在于其排序字段一定是时间属性列，不能是其他非时间属性的普通列。在 row_number = 1 时，如果排序字段是普通列 planner 会翻译成 TopN 算子，如果是时间属性列 planner 会翻译成 Deduplication，这两者最终的执行算子是不一样的，Deduplication 相比 TopN 算子专门做了对应的优化，性能会有很大提升。 ⭐ 应用场景：比如上游数据发重了，或者计算 DAU 明细数据等场景，都可以使用 Deduplication 语法去做去重。 ⭐ SQL 语法标准： 1234567SELECT [column_list]FROM ( SELECT [column_list], ROW_NUMBER() OVER ([PARTITION BY col1[, col2...]] ORDER BY time_attr [asc|desc]) AS rownum FROM table_name)WHERE rownum = 1 其中： ⭐ ROW_NUMBER()：标识当前数据的排序值 ⭐ PARTITION BY col1[, col2...]：标识分区字段，代表按照这个 col 字段作为分区粒度对数据进行排序 ⭐ ORDER BY time_attr [asc|desc]：标识排序规则，必须为时间戳列，当前 Flink SQL 支持处理时间、事件时间，ASC 代表保留第一行，DESC 代表保留最后一行 ⭐ WHERE rownum = 1：这个子句是一定需要的，而且必须为 rownum = 1 ⭐ 实际案例： 博主这里举两个案例： ⭐ 案例 1（事件时间）：是腾讯 QQ 用户等级的场景，每一个 QQ 用户都有一个 QQ 用户等级，需要求出当前用户等级在 星星，月亮，太阳 的用户数分别有多少。 12345678910111213141516171819202122232425262728293031323334353637383940-- 数据源：当每一个用户的等级初始化及后续变化的时候的数据，即用户等级变化明细数据。CREATE TABLE source_table ( user_id BIGINT COMMENT &#x27;用户 id&#x27;, level STRING COMMENT &#x27;用户等级&#x27;, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)) COMMENT &#x27;事件时间戳&#x27;, WATERMARK FOR row_time AS row_time) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.level.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;1000000&#x27;);-- 数据汇：输出即每一个等级的用户数CREATE TABLE sink_table ( level STRING COMMENT &#x27;等级&#x27;, uv BIGINT COMMENT &#x27;当前等级用户数&#x27;, row_time timestamp(3) COMMENT &#x27;时间戳&#x27;) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 处理逻辑：INSERT INTO sink_tableselect level , count(1) as uv , max(row_time) as row_timefrom ( SELECT user_id, level, row_time, row_number() over(partition by user_id order by row_time) as rn FROM source_table)where rn = 1group by level 输出结果： script123456+I[等级 1, 6928, 2021-1-28T22:34]-I[等级 1, 6928, 2021-1-28T22:34]+I[等级 1, 8670, 2021-1-28T22:34]-I[等级 1, 8670, 2021-1-28T22:34]+I[等级 1, 77287, 2021-1-28T22:34]... 可以看到其有回撤数据。 其对应的 SQL 语义如下： ⭐ 数据源：消费到 Kafka 中数据后，将数据按照 partition by 的 key 通过 hash 分发策略发送到下游去重算子 ⭐ Deduplication 去重算子：接受到上游数据之后，根据 order by 中的条件判断当前的这条数据和之前数据时间戳大小，以上面案例来说，如果当前数据时间戳大于之前数据时间戳，则撤回之前向下游发的中间结果，然后将最新的结果发向下游（发送策略也为 hash，具体的 hash 策略为按照 group by 中 key 进行发送），如果当前数据时间戳小于之前数据时间戳，则不做操作。次算子产出的结果就是每一个用户的对应的最新等级信息。 ⭐ Group by 聚合算子：接受到上游数据之后，根据 Group by 聚合粒度对数据进行聚合计算结果（每一个等级的用户数），发往下游数据汇算子 ⭐ 数据汇：接收到上游的数据之后，然后输出到外部存储引擎中 ⭐ 案例 2（处理时间）：最原始的日志是明细数据，需要我们根据用户 id 筛选出这个用户当天的第一条数据，发往下游，下游可以据此计算分各种维度的 DAU 123456789101112131415161718192021222324252627282930313233343536373839-- 数据源：原始日志明细数据CREATE TABLE source_table ( user_id BIGINT COMMENT &#x27;用户 id&#x27;, name STRING COMMENT &#x27;用户姓名&#x27;, server_timestamp BIGINT COMMENT &#x27;用户访问时间戳&#x27;, proctime AS PROCTIME()) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.name.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;10&#x27;, &#x27;fields.server_timestamp.min&#x27; = &#x27;1&#x27;, &#x27;fields.server_timestamp.max&#x27; = &#x27;100000&#x27;);-- 数据汇：根据 user_id 去重的第一条数据CREATE TABLE sink_table ( user_id BIGINT, name STRING, server_timestamp BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- 处理逻辑：INSERT INTO sink_tableselect user_id, name, server_timestampfrom ( SELECT user_id, name, server_timestamp, row_number() over(partition by user_id order by proctime) as rn FROM source_table)where rn = 1 输出结果： script1234+I[1, 用户 1, 2021-1-28T22:34]+I[2, 用户 2, 2021-1-28T22:34]+I[3, 用户 3, 2021-1-28T22:34]... 可以看到这个处理逻辑是没有回撤数据的。其对应的 SQL 语义如下： ⭐ 数据源：消费到 Kafka 中数据后，将数据按照 partition by 的 key 通过 hash 分发策略发送到下游去重算子 ⭐ Deduplication 去重算子：处理时间语义下，如果是当前 key 的第一条数据，则直接发往下游，如果判断（根据 state 中是否存储过改 key）不是第一条，则直接丢弃 ⭐ 数据汇：接收到上游的数据之后，然后输出到外部存储引擎中 注意： 在 Deduplication 关于是否会出现回撤流，博主总结如下： ⭐ Order by 事件时间 DESC：会出现回撤流，因为当前 key 下 可能会有 比当前事件时间还大的数据 ⭐ Order by 事件时间 ASC：会出现回撤流，因为当前 key 下 可能会有 比当前事件时间还小的数据 ⭐ Order by 处理时间 DESC：会出现回撤流，因为当前 key 下 可能会有 比当前处理时间还大的数据 ⭐ Order by 处理时间 ASC：不会出现回撤流，因为当前 key 下 不可能会有 比当前处理时间还小的数据 3.14.EXPLAIN 子句 ⭐ 应用场景：EXPLAIN 子句其实就是用于查看当前这个 sql 查询的逻辑计划以及优化的执行计划。 ⭐ SQL 语法标准： 1EXPLAIN PLAN FOR &lt;query_statement_or_insert_statement&gt; ⭐ 实际案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Explain_Test &#123; public static void main(String[] args) throws Exception &#123; FlinkEnv flinkEnv = FlinkEnvUtils.getStreamTableEnv(args); flinkEnv.env().setParallelism(1); String sql = &quot;CREATE TABLE source_table (\\n&quot; + &quot; user_id BIGINT COMMENT &#x27;用户 id&#x27;,\\n&quot; + &quot; name STRING COMMENT &#x27;用户姓名&#x27;,\\n&quot; + &quot; server_timestamp BIGINT COMMENT &#x27;用户访问时间戳&#x27;,\\n&quot; + &quot; proctime AS PROCTIME()\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;datagen&#x27;,\\n&quot; + &quot; &#x27;rows-per-second&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.name.length&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.user_id.max&#x27; = &#x27;10&#x27;,\\n&quot; + &quot; &#x27;fields.server_timestamp.min&#x27; = &#x27;1&#x27;,\\n&quot; + &quot; &#x27;fields.server_timestamp.max&#x27; = &#x27;100000&#x27;\\n&quot; + &quot;);\\n&quot; + &quot;\\n&quot; + &quot;CREATE TABLE sink_table (\\n&quot; + &quot; user_id BIGINT,\\n&quot; + &quot; name STRING,\\n&quot; + &quot; server_timestamp BIGINT\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;print&#x27;\\n&quot; + &quot;);\\n&quot; + &quot;\\n&quot; + &quot;EXPLAIN PLAN FOR\\n&quot; + &quot;INSERT INTO sink_table\\n&quot; + &quot;select user_id,\\n&quot; + &quot; name,\\n&quot; + &quot; server_timestamp\\n&quot; + &quot;from (\\n&quot; + &quot; SELECT\\n&quot; + &quot; user_id,\\n&quot; + &quot; name,\\n&quot; + &quot; server_timestamp,\\n&quot; + &quot; row_number() over(partition by user_id order by proctime) as rn\\n&quot; + &quot; FROM source_table\\n&quot; + &quot;)\\n&quot; + &quot;where rn = 1&quot;; /** * 算子 &#123;@link org.apache.flink.streaming.api.operators.KeyedProcessOperator&#125; * -- &#123;@link org.apache.flink.table.runtime.operators.deduplicate.ProcTimeDeduplicateKeepFirstRowFunction&#125; */ for (String innerSql : sql.split(&quot;;&quot;)) &#123; TableResult tableResult = flinkEnv.streamTEnv().executeSql(innerSql); tableResult.print(); &#125; &#125;&#125; 上述代码执行结果如下： script123456789101112131415161718192021222324251. 抽象语法树== Abstract Syntax Tree ==LogicalSink(table=[default_catalog.default_database.sink_table], fields=[user_id, name, server_timestamp])+- LogicalProject(user_id=[$0], name=[$1], server_timestamp=[$2]) +- LogicalFilter(condition=[=($3, 1)]) +- LogicalProject(user_id=[$0], name=[$1], server_timestamp=[$2], rn=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY PROCTIME() NULLS FIRST)]) +- LogicalTableScan(table=[[default_catalog, default_database, source_table]])2. 优化后的物理计划== Optimized Physical Plan ==Sink(table=[default_catalog.default_database.sink_table], fields=[user_id, name, server_timestamp])+- Calc(select=[user_id, name, server_timestamp]) +- Deduplicate(keep=[FirstRow], key=[user_id], order=[PROCTIME]) +- Exchange(distribution=[hash[user_id]]) +- Calc(select=[user_id, name, server_timestamp, PROCTIME() AS $3]) +- TableSourceScan(table=[[default_catalog, default_database, source_table]], fields=[user_id, name, server_timestamp])3. 优化后的执行计划== Optimized Execution Plan ==Sink(table=[default_catalog.default_database.sink_table], fields=[user_id, name, server_timestamp])+- Calc(select=[user_id, name, server_timestamp]) +- Deduplicate(keep=[FirstRow], key=[user_id], order=[PROCTIME]) +- Exchange(distribution=[hash[user_id]]) +- Calc(select=[user_id, name, server_timestamp, PROCTIME() AS $3]) +- TableSourceScan(table=[[default_catalog, default_database, source_table]], fields=[user_id, name, server_timestamp]) 3.15.USE 子句 ⭐ 应用场景：如果熟悉 MySQL 的同学会非常熟悉这个子句，在 MySQL 中，USE 子句通常被用于切换库，那么在 Flink SQL 体系中，它的作用也是和 MySQL 中 USE 子句的功能基本一致，用于切换 Catalog，DataBase，使用 Module ⭐ SQL 语法标准： ⭐ 切换 Catalog 1USE CATALOG catalog_name ⭐ 使用 Module 1USE MODULES module_name1[, module_name2, ...] ⭐ 切换 Database 1USE db名称 ⭐ 实际案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);// create a catalogtEnv.executeSql(&quot;CREATE CATALOG cat1 WITH (...)&quot;);tEnv.executeSql(&quot;SHOW CATALOGS&quot;).print();// +-----------------+// | catalog name |// +-----------------+// | default_catalog |// | cat1 |// +-----------------+// change default catalogtEnv.executeSql(&quot;USE CATALOG cat1&quot;);tEnv.executeSql(&quot;SHOW DATABASES&quot;).print();// databases are empty// +---------------+// | database name |// +---------------+// +---------------+// create a databasetEnv.executeSql(&quot;CREATE DATABASE db1 WITH (...)&quot;);tEnv.executeSql(&quot;SHOW DATABASES&quot;).print();// +---------------+// | database name |// +---------------+// | db1 |// +---------------+// change default databasetEnv.executeSql(&quot;USE db1&quot;);// change module resolution order and enabled statustEnv.executeSql(&quot;USE MODULES hive&quot;);tEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+-------+// | module name | used |// +-------------+-------+// | hive | true |// | core | false |// +-------------+-------+ 3.16.SHOW 子句 ⭐ 应用场景：如果熟悉 MySQL 的同学会非常熟悉这个子句，在 MySQL 中，SHOW 子句常常用于查询库、表、函数等，在 Flink SQL 体系中也类似。Flink SQL 支持 SHOW 以下内容。 ⭐ SQL 语法标准： 12345678SHOW CATALOGS：展示所有 CatalogSHOW CURRENT CATALOG：展示当前的 CatalogSHOW DATABASES：展示当前 Catalog 下所有 DatabaseSHOW CURRENT DATABASE：展示当前的 DatabaseSHOW TABLES：展示当前 Database 下所有表SHOW VIEWS：展示所有视图SHOW FUNCTIONS：展示所有的函数SHOW MODULES：展示所有的 Module（Module 是用于 UDF 扩展） ⭐ 实际案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);// show catalogstEnv.executeSql(&quot;SHOW CATALOGS&quot;).print();// +-----------------+// | catalog name |// +-----------------+// | default_catalog |// +-----------------+// show current catalogtEnv.executeSql(&quot;SHOW CURRENT CATALOG&quot;).print();// +----------------------+// | current catalog name |// +----------------------+// | default_catalog |// +----------------------+// show databasestEnv.executeSql(&quot;SHOW DATABASES&quot;).print();// +------------------+// | database name |// +------------------+// | default_database |// +------------------+// show current databasetEnv.executeSql(&quot;SHOW CURRENT DATABASE&quot;).print();// +-----------------------+// | current database name |// +-----------------------+// | default_database |// +-----------------------+// create a tabletEnv.executeSql(&quot;CREATE TABLE my_table (...) WITH (...)&quot;);// show tablestEnv.executeSql(&quot;SHOW TABLES&quot;).print();// +------------+// | table name |// +------------+// | my_table |// +------------+// create a viewtEnv.executeSql(&quot;CREATE VIEW my_view AS ...&quot;);// show viewstEnv.executeSql(&quot;SHOW VIEWS&quot;).print();// +-----------+// | view name |// +-----------+// | my_view |// +-----------+// show functionstEnv.executeSql(&quot;SHOW FUNCTIONS&quot;).print();// +---------------+// | function name |// +---------------+// | mod |// | sha256 |// | ... |// +---------------+// create a user defined functiontEnv.executeSql(&quot;CREATE FUNCTION f1 AS ...&quot;);// show user defined functionstEnv.executeSql(&quot;SHOW USER FUNCTIONS&quot;).print();// +---------------+// | function name |// +---------------+// | f1 |// | ... |// +---------------+// show modulestEnv.executeSql(&quot;SHOW MODULES&quot;).print();// +-------------+// | module name |// +-------------+// | core |// +-------------+// show full modulestEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+-------+// | module name | used |// +-------------+-------+// | core | true |// | hive | false |// +-------------+-------+ 3.17.LOAD、UNLOAD 子句 ⭐ 应用场景：我们可以使用 LOAD 子句去加载 Flink SQL 体系内置的或者用户自定义的 Module，UNLOAD 子句去卸载 Flink SQL 体系内置的或者用户自定义的 Module ⭐ SQL 语法标准： 12345-- 加载LOAD MODULE module_name [WITH (&#x27;key1&#x27; = &#x27;val1&#x27;, &#x27;key2&#x27; = &#x27;val2&#x27;, ...)]-- 卸载UNLOAD MODULE module_name ⭐ 实际案例： ⭐ LOAD 案例： 123456789101112StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);// 加载 Flink SQL 体系内置的 Hive moduletEnv.executeSql(&quot;LOAD MODULE hive WITH (&#x27;hive-version&#x27; = &#x27;3.1.2&#x27;)&quot;);tEnv.executeSql(&quot;SHOW MODULES&quot;).print();// +-------------+// | module name |// +-------------+// | core |// | hive |// +-------------+ ⭐ UNLOAD 案例： 1234567StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);// 卸载唯一的一个 CoreModuletEnv.executeSql(&quot;UNLOAD MODULE core&quot;);tEnv.executeSql(&quot;SHOW MODULES&quot;).print();// 结果啥 Moudle 都没有了 3.18.SET、RESET 子句 ⭐ 应用场景：SET 子句可以用于修改一些 Flink SQL 的环境配置，RESET 子句是可以将所有的环境配置恢复成默认配置，但只能在 SQL CLI 中进行使用，主要是为了让用户更纯粹的使用 SQL 而不必使用其他方式或者切换系统环境。 ⭐ SQL 语法标准： 123SET (key = value)?RESET (key)? ⭐ 实际案例： 启动一个 SQL CLI 之后，在 SQL CLI 中可以进行以下 SET 设置： 1234567891011Flink SQL&gt; SET table.planner = blink;[INFO] Session property has been set.Flink SQL&gt; SET;table.planner=blink;Flink SQL&gt; RESET table.planner;[INFO] Session property has been reset.Flink SQL&gt; RESET;[INFO] All session properties have been set to their default values. 3.19.SQL Hints ⭐ 应用场景：比如有一个 kafka 数据源表 kafka_table1，用户想直接从 latest-offset select 一些数据出来预览，其元数据已经存储在 Hive MetaStore 中，但是 Hive MetaStore 中存储的配置中的 scan.startup.mode 是 earliest-offset，通过 SQL Hints，用户可以在 DML 语句中将 scan.startup.mode 改为 latest-offset 查询，因此可以看出 SQL Hints 常用语这种比较临时的参数修改，比如 Ad-hoc 这种临时查询中，方便用户使用自定义的新的表参数而不是 Catalog 中已有的表参数。 ⭐ SQL 语法标准： 以下 DML SQL 中的 /*+ OPTIONS(key=val [, key=val]*) */ 就是 SQL Hints。 12SELECT *FROM table_path /*+ OPTIONS(key=val [, key=val]*) */ ⭐ 实际案例： 启动一个 SQL CLI 之后，在 SQL CLI 中可以进行以下 SET 设置： 123456789101112131415CREATE TABLE kafka_table1 (id BIGINT, name STRING, age INT) WITH (...);CREATE TABLE kafka_table2 (id BIGINT, name STRING, age INT) WITH (...);-- 1. 使用 &#x27;scan.startup.mode&#x27;=&#x27;earliest-offset&#x27; 覆盖原来的 scan.startup.modeselect id, name from kafka_table1 /*+ OPTIONS(&#x27;scan.startup.mode&#x27;=&#x27;earliest-offset&#x27;) */;-- 2. 使用 &#x27;scan.startup.mode&#x27;=&#x27;earliest-offset&#x27; 覆盖原来的 scan.startup.modeselect * from kafka_table1 /*+ OPTIONS(&#x27;scan.startup.mode&#x27;=&#x27;earliest-offset&#x27;) */ t1 join kafka_table2 /*+ OPTIONS(&#x27;scan.startup.mode&#x27;=&#x27;earliest-offset&#x27;) */ t2 on t1.id = t2.id;-- 3. 使用 &#x27;sink.partitioner&#x27;=&#x27;round-robin&#x27; 覆盖原来的 Sink 表的 sink.partitionerinsert into kafka_table1 /*+ OPTIONS(&#x27;sink.partitioner&#x27;=&#x27;round-robin&#x27;) */ select * from kafka_table2; 4.SQL UDF 篇Flink Table\\SQL API 允许用户使用函数进行数据处理、字段标准化等处理。 4.1.SQL 函数的归类Flink 中的函数有两个维度的归类标准。 ⭐ 一个归类标准是：系统（内置）函数和 Catalog 函数。系统函数没有命名空间，只能通过其名称来进行引用。Catalog 函数属于 Catalog 和数据库，因此它们拥有 Catalog 和数据库的命名空间。用户可以通过全/部分限定名（catalog.db.func 或 db.func）或者函数来对 Catalog 函数进行引用。 ⭐ 另一个归类标准是：临时函数和持久化函数。临时函数由用户创建，它仅在会话的生命周期（也就是一个 Flink 任务的一次运行生命周期内）内有效。持久化函数不是由系统提供的，是存储在 Catalog 中，它在不同会话的生命周期内都有效。 这两个维度归类标准组合下，Flink SQL 总共提供了 4 种函数： ⭐ 临时性系统内置函数 ⭐ 系统内置函数 ⭐ 临时性 Catalog 函数（例如：Create Temporary Function） ⭐ Catalog 函数（例如：Create Function） 请注意，在用户使用函数时，系统函数始终优先于 Catalog 函数解析，临时函数始终优先于持久化函数解析。 4.2.SQL 函数的引用方式用户在 Flink 中可以通过精确、模糊两种引用方式引用函数。 4.2.1.精确函数精确函数引用是让用户限定 Catalog，数据库名称进行精准定位一个 UDF 然后调用。 例如：select mycatalog.mydb.myfunc(x) from mytable 或者 select mydb.myfunc(x) from mytable。 4.2.2.模糊函数在模糊函数引用中，用户只需在 SQL 查询中指定函数名就可以引用 UDF，例如： select myfunc(x) from mytable。 当然小伙伴萌问到，如果系统函数和 Catalog 函数的名称是重复的，Flink 体系是会使用哪一个函数呢？这就是下文要介绍的 UDF 解析顺序 4.3.SQL 函数的解析顺序4.3.1.精确函数由于精确函数应用一定会带上 Catalog 或者数据库名称，所以 Flink 中的精确函数引用一定是指向临时性 Catalog 函数或 Catalog 函数的。 比如：select mycatalog.mydb.myfunc(x) from mytable。 那么 Flink 对其解析顺序以及使用顺序如下： ⭐ 临时性 catalog 函数 ⭐ Catalog 函数 4.3.2.模糊函数比如 select myfunc(x) from mytable。 解析顺序以及使用顺序如下： ⭐ 临时性系统内置函数 ⭐ 系统内置函数 ⭐ 临时性 Catalog 函数, 只会在当前会话的当前 Catalog 和当前数据库中查找函数及解析函数 ⭐ Catalog 函数, 在当前 Catalog 和当前数据库中查找函数及解析函数 4.4.系统内置函数系统内置函数小伙伴萌可以直接在 Flink 官网进行查询，博主这里就不多进行介绍。 https://nightlies.apache.org/flink/flink-docs-release-1.13/zh/docs/dev/table/functions/systemfunctions/#hash-functions 注意： 在目前 1.13 版本的 Flink 体系中，内置的系统函数没有像 Hive 内置的函数那么丰富，比如 Hive 中常见的 get_json_object 之类的，Flink 都是没有的，但是 Flink 提供了插件化 Module 的能力，能扩充一些 UDF，下文会进行介绍。 4.5.SQL 自定义函数（UDF）！！！Flink 体系也提供了类似于其他大数据引擎的 UDF 体系。 自定义函数（UDF）是一种扩展开发机制，可以用来在查询语句里调用难以用 SQL 进行 直接 表达的频繁使用或自定义的逻辑。 目前 Flink 自定义函数可以基于 JVM 语言（例如 Java 或 Scala）或 Python 实现，实现者可以在 UDF 中使用任意第三方库，本章聚焦于使用 Java 语言开发自定义函数。 当前 Flink 提供了一下几种 UDF 能力： 标量函数（Scalar functions 或 UDAF）：输入一条输出一条，将标量值转换成一个新标量值，对标 Hive 中的 UDF； 表值函数（Table functions 或 UDTF）：输入一条条输出多条，对标 Hive 中的 UDTF； 聚合函数（Aggregate functions 或 UDAF）：输入多条输出一条，对标 Hive 中的 UDAF； 表值聚合函数（Table aggregate functions 或 UDTAF）：仅仅支持 Table API，不支持 SQL API，其可以将多行转为多行； 异步表值函数（Async table functions）：这是一种特殊的 UDF，支持异步查询外部数据系统，用在前文介绍到的 lookup join 中作为查询外部系统的函数。 先直接给一个案例看看，怎么创建并在 Flink SQL 中使用一个 UDF： 123456789101112131415161718192021222324import org.apache.flink.table.api.*;import org.apache.flink.table.functions.ScalarFunction;import static org.apache.flink.table.api.Expressions.*;// 定义一个标量函数public static class SubstringFunction extends ScalarFunction &#123; public String eval(String s, Integer begin, Integer end) &#123; return s.substring(begin, end); &#125;&#125;TableEnvironment env = TableEnvironment.create(...);// 在 Table API 可以直接以引用 class 方式使用 UDFenv.from(&quot;MyTable&quot;).select(call(SubstringFunction.class, $(&quot;myField&quot;), 5, 12));// 注册 UDFenv.createTemporarySystemFunction(&quot;SubstringFunction&quot;, SubstringFunction.class);// Table API 调用 UDFenv.from(&quot;MyTable&quot;).select(call(&quot;SubstringFunction&quot;, $(&quot;myField&quot;), 5, 12));// SQL API 调用 UDFenv.sqlQuery(&quot;SELECT SubstringFunction(myField, 5, 12) FROM MyTable&quot;); 注意：如果你的函数在初始化时，是有入参的，那么需要你的入参是 Serializable 的。即 Java 中需要继承 Serializable 接口。 案例如下： 1234567891011121314151617181920212223242526import org.apache.flink.table.api.*;import org.apache.flink.table.functions.ScalarFunction;import static org.apache.flink.table.api.Expressions.*;// 定义一个带有输入参数的标量函数public static class SubstringFunction extends ScalarFunction &#123; -- boolean 默认就是 Serializable 的 private boolean endInclusive; public SubstringFunction(boolean endInclusive) &#123; this.endInclusive = endInclusive; &#125; public String eval(String s, Integer begin, Integer end) &#123; return s.substring(begin, endInclusive ? end + 1 : end); &#125;&#125;TableEnvironment env = TableEnvironment.create(...);// Table API 调用 UDFenv.from(&quot;MyTable&quot;).select(call(new SubstringFunction(true), $(&quot;myField&quot;), 5, 12));// 注册 UDFenv.createTemporarySystemFunction(&quot;SubstringFunction&quot;, new SubstringFunction(true)); 4.6.开发 UDF 之前的需知事项总结这几个事项主要包含以下步骤： 首先需要继承 Flink SQL UDF 体系提供的基类，每种 UDF 实现都有不同的基类 实现 UDF 执行逻辑函数，不同类型的 UDF 需要实现不同的执行逻辑函数 注意 UDF 入参、出参类型推导，Flink 在一些基础类型上的是可以直接推导出类型信息的，但是一些复杂类型就无能为力了，这里需要用户主动介入 明确 UDF 输出结果是否是定值，如果是定值则 Flink 会在生成计划时就执行一遍，得出结果，然后使用这个定值的结果作为后续的执行逻辑的参数，这样可以做到不用在 Flink SQL 任务运行时每次都执行一次，会有性能优化 巧妙运用运行时上下文，可以在任务运行前加载到一些外部资源、上下文配置信息，扩展 UDF 能力 4.6.1.继承 UDF 基类和 Hive UDF 实现思路类似，在 Flink UDF 体系中，需要注意一下事项： ⭐ Flink UDF 要继承一个基类（比如标量 UDF 要继承 org.apache.flink.table.functions.ScalarFunction）。 ⭐ 类必须声明为 public，不能是 abstract 类，不能使用非静态内部类或匿名类。 ⭐ 为了在 Catalog 中存储此类，该类必须要有默认构造函数并且在运行时可以进行实例化。 4.6.2.实现 UDF 执行逻辑函数基类提供了一组可以被重写的方法，来给用户进行使用，这些可被重写的方法就是主要承担 UDF 自定义执行逻辑的地方。 举例在 ScalarFunction 中： ⭐ open()：用于初始化资源（比如连接外部资源），程序初始化时进行调用 ⭐ close()：用于关闭资源，程序结束时进行调用 ⭐ isDeterministic()：用于判断返回结果是否是确定的，如果是确定的，结果会被直接执行 ⭐ eval(xxx)：Flink 用于处理每一条数据的主要处理逻辑函数 你可以自定义 eval 的入参，比如： eval(Integer) 和 eval(LocalDateTime)； 使用变长参数，例如 eval(Integer…); 使用对象，例如 eval(Object) 可接受 LocalDateTime、Integer 作为参数，只要是 Object 都可以； 也可组合使用，例如 eval(Object…) 可接受所有类型的参数。 并且你可以在一个 UDF 中重载 eval 函数来实现不同的逻辑，比如： 1234567891011121314151617181920212223import org.apache.flink.table.functions.ScalarFunction;// 有多个重载求和方法的函数public static class SumFunction extends ScalarFunction &#123; // 入参为 Integer public Integer eval(Integer a, Integer b) &#123; return a + b; &#125; // 入参为 String public Integer eval(String a, String b) &#123; return Integer.valueOf(a) + Integer.valueOf(b); &#125; // 入参为多个 Double public Integer eval(Double... d) &#123; double result = 0; for (double value : d) result += value; return (int) result; &#125;&#125; 注意：由于 Flink 在运行时会调用这些方法，所以这些方法必须声明为 public，并且包含明确的输入和输出参数。 4.6.3.注意 UDF 入参、出参类型推导从两个角度来说，为什么函数的入参、出参类型会对 UDF 这么重要。 ⭐ 从开发人员角度讲，在设计 UDF 的时候，肯定会涉及到 UDF 预期的入参、出参类型信息、也包括一些数据的精度、小数位数等信息 ⭐ 从程序运行角度讲，Flink SQL 程序运行时，肯定也需要知道怎么将 SQL 中的类型数据与 UDF 的入参、出参类型，这样才能做数据序列化等操作 而 Flink 也提供了三种方式帮助 Flink 程序获取参数类型信息。 ⭐ 自动类型推导功能：Flink 具备 UDF 自动类型推导功能，该功能可以通过反射从函数的类及其求值方法派生数据类型。比如如果你的 UDF 的方法或者类的签名中已经有了对应的入参、出参的类型，Flink 一般都可以推导并获取到这些类型信息。 ⭐ 添加类型注解：当 1 中的隐式反射提取方法不成功，则可以通过使用 Flink 提供的 @DataTypeHint 和 @FunctionHint 注解对应的参数、类或方法来显示的支持 Flink 参数类型提取。 ⭐ 重写 getTypeInference()：你可以使用 Flink 提供的更高级的类型推导方法，你可以在 UDF 实现类中重写 getTypeInference() 方法去显示声明函数的参数类型信息 接下来介绍几个例子。 ⭐ 自动类型推导案例： 自动类型推导会检查函数的 类 签名和 eval 方法签名，从而推导出函数入参和出参的数据类型，@DataTypeHint 和 @FunctionHint 注解也可以辅助支持自动类型推导。 关于自动类型推导具体将 Java 的对象会映射成 SQL 的具体哪个数据类型，可以参考 https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/types/#data-type-extraction 案例如下： 123456789101112131415161718192021222324252627282930import org.apache.flink.table.annotation.DataTypeHint;import org.apache.flink.table.annotation.InputGroup;import org.apache.flink.table.functions.ScalarFunction;import org.apache.flink.types.Row;// 有多个重载求值方法的函数public static class OverloadedFunction extends ScalarFunction &#123; // 不需要任何声明，可以直接推导出类型信息，即入参和出参对应到 SQL 中的 bigint 类型 public Long eval(long a, long b) &#123; return a + b; &#125; // 使用 @DataTypeHint(&quot;DECIMAL(12, 3)&quot;) 定义 decimal 的精度和小数位 public @DataTypeHint(&quot;DECIMAL(12, 3)&quot;) BigDecimal eval(double a, double b) &#123; return BigDecimal.valueOf(a + b); &#125; // 使用注解定义嵌套数据类型 @DataTypeHint(&quot;ROW&lt;s STRING, t TIMESTAMP_LTZ(3)&gt;&quot;) public Row eval(int i) &#123; return Row.of(String.valueOf(i), Instant.ofEpochSecond(i)); &#125; // 允许任意类型的输入，并输出序列化定制后的值 @DataTypeHint(value = &quot;RAW&quot;, bridgedTo = ByteBuffer.class) public ByteBuffer eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object o) &#123; return MyUtils.serializeToByteBuffer(o); &#125;&#125; ⭐ 根据 @FunctionHint 注解自动推导类型案例： 使用 @DataTypeHint 注解虽好，但是有些场景下，使用起来比较复杂，比如： ⭐ 我们不希望 eval 函数的入参和出参都是一个非常具体的类型，比如 long，int，double 等。我们希望它是一个通用的类型，比如 Object。这样的话就不用重载那么多的函数，可以直接使用一个 eval 函数实现不同的处理逻辑，返回不同类型的结果 ⭐ 多个 eval 方法的返回结果类型都是相同的，我们懒得写多次 @DataTypeHint 那么就可以使用 @FunctionHint 实现，@FunctionHint 是声明在类上面的，举例如下： 12345678910111213141516171819202122232425262728293031323334353637383940import org.apache.flink.table.annotation.DataTypeHint;import org.apache.flink.table.annotation.FunctionHint;import org.apache.flink.table.functions.TableFunction;import org.apache.flink.types.Row;// 1. 解耦类型推导与 eval 方法，类型推导根据 FunctionHint 注解中的信息来，下面的案例说明当前这个 UDF 有三种输入输出类型信息组合@FunctionHint( input = &#123;@DataTypeHint(&quot;INT&quot;), @DataTypeHint(&quot;INT&quot;)&#125;, output = @DataTypeHint(&quot;INT&quot;))@FunctionHint( input = &#123;@DataTypeHint(&quot;BIGINT&quot;), @DataTypeHint(&quot;BIGINT&quot;)&#125;, output = @DataTypeHint(&quot;BIGINT&quot;))@FunctionHint( input = &#123;&#125;, output = @DataTypeHint(&quot;BOOLEAN&quot;))public static class OverloadedFunction extends TableFunction&lt;Object&gt; &#123; public void eval(Object... o) &#123; if (o.length == 0) &#123; collect(false); &#125; collect(o[0]); &#125;&#125;// 2. 为函数类的所有 eval 方法指定同一个输出类型@FunctionHint(output = @DataTypeHint(&quot;ROW&lt;s STRING, i INT&gt;&quot;))public static class OverloadedFunction extends TableFunction&lt;Row&gt; &#123; public void eval(int a, int b) &#123; collect(Row.of(&quot;Sum&quot;, a + b)); &#125; public void eval() &#123; collect(Row.of(&quot;Empty args&quot;, -1)); &#125;&#125; ⭐ getTypeInference() getTypeInference() 可以做到根据小伙伴萌自定义的方式去定义类型推导过程及结果，具有高度自定义的能力。举例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.apache.flink.table.api.DataTypes;import org.apache.flink.table.catalog.DataTypeFactory;import org.apache.flink.table.functions.ScalarFunction;import org.apache.flink.table.types.inference.TypeInference;import org.apache.flink.types.Row;public static class LiteralFunction extends ScalarFunction &#123; public Object eval(String s, String type) &#123; switch (type) &#123; case &quot;INT&quot;: return Integer.valueOf(s); case &quot;DOUBLE&quot;: return Double.valueOf(s); case &quot;STRING&quot;: default: return s; &#125; &#125; // 如果实现了 getTypeInference，则会禁用自动的反射式类型推导，使用如下逻辑进行类型推导 @Override public TypeInference getTypeInference(DataTypeFactory typeFactory) &#123; return TypeInference.newBuilder() // 指定输入参数的类型，必要时参数会被隐式转换 .typedArguments(DataTypes.STRING(), DataTypes.STRING()) // 用户高度自定义的类型推导逻辑 .outputTypeStrategy(callContext -&gt; &#123; if (!callContext.isArgumentLiteral(1) || callContext.isArgumentNull(1)) &#123; throw callContext.newValidationError(&quot;Literal expected for second argument.&quot;); &#125; // 基于第一个入参决定具体的返回数据类型 final String literal = callContext.getArgumentValue(1, String.class).orElse(&quot;STRING&quot;); switch (literal) &#123; case &quot;INT&quot;: return Optional.of(DataTypes.INT().notNull()); case &quot;DOUBLE&quot;: return Optional.of(DataTypes.DOUBLE().notNull()); case &quot;STRING&quot;: default: return Optional.of(DataTypes.STRING()); &#125; &#125;) .build(); &#125;&#125; todo 如果你还想了解更多的案例，可以到博主的 git `` 上查看更多的案例。 4.6.4.明确 UDF 输出结果是否是定值用户可以通过重写 isDeterministic() 函数来声明这个 UDF 产出的结果是否是一个定值。 对于纯函数（即没有入参的函数，比如 random(), date(), or now() 等）来说，默认情况下 isDeterministic() 返回 true，小伙伴萌可以自定义返回 false。 如果函数不是一个纯函数（即没有入参的函数，比如 random(), date(), or now() 等），这个方法必须返回 false。 那么 isDeterministic() 方法的返回值到底影响什么呢？ 答案：影响 Flink 任务在什么时候就直接执行这个 UDF。主要在以下两个方面体现： ⭐ Flink 在生成计划期间直接执行 UDF 获得结果：如果使用常量表达式调用函数，或者使用常量作为函数的入参，则 Flink 任务可能不会在任务正式运行时执行该函数。举个例子，SELECT ABS(-1) FROM t，SELECT ABS(field) FROM t WHERE field = -1，这两种都会被 Flink 进行优化，直接把 ABS(-1) 的结果在客户端生成执行计划时就将结果运行出来。如果不想在生成执行计划阶段直接将结果运行出来，可以实现 isDeterministic() 返回 false。 ⭐ Flink 在程序运行期间执行 UDF 获得结果：如果 UDF 的入参不是常量表达式，或者 isDeterministic() 返回 false，则 Flink 会在程序运行期间执行 UDF。 那么小伙伴会问到，有些场景下 Flink SQL 是做了各种优化之后然后推断出表达式是否是常量，我怎么判断能够更加方便的判断出这个 Flink 是否将这个 UDF 的优化为固定结果了呢？ 结论：这些都是可以在 Flink SQL 生成的算子图中看到，在 Flink web ui 中，每一个算子上面都可以详细看到 Flink 最终生成的算子执行逻辑。 4.6.5.巧妙运用运行时上下文有时候我们想在 UDF 需要获取一些 Flink 任务运行的全局信息，或者在 UDF 真正处理数据之前做一些配置（setup）/清理（clean-up）的工作。UDF 为我们提供了 open() 和 close() 方法，你可以重写这两个方法做到类似于 DataStream API 中 RichFunction 的功能。 ⭐ open() 方法：在任务初始化时被调用，常常用于加载一些外部资源； ⭐ close() 方法：在任务结束时被调用，常常用于关闭一些外部资源； 其中 open() 方法提供了一个 FunctionContext，它包含了一些 UDF 被执行时的上下文信息，比如 metric group、分布式文件缓存，或者是全局的作业参数等。 比如可以获取到下面的信息： ⭐ getMetricGroup()：执行该函数的 subtask 的 Metric Group ⭐ getCachedFile(name)：分布式文件缓存的本地临时文件副本 ⭐ getJobParameter(name, defaultValue)：获取 Flink 任务的全局作业参数 ⭐ getExternalResourceInfos(resourceName)：获取一些外部资源 下面的例子展示了如何在一个标量函数中通过 FunctionContext 来获取一个全局的任务参数： 1234567891011121314151617181920212223242526272829303132import org.apache.flink.table.api.*;import org.apache.flink.table.functions.FunctionContext;import org.apache.flink.table.functions.ScalarFunction;public static class HashCodeFunction extends ScalarFunction &#123; private int factor = 0; @Override public void open(FunctionContext context) throws Exception &#123; // 4. 在 UDF 中获取全局参数 hashcode_factor // 用户可以配置全局作业参数 &quot;hashcode_factor&quot; // 获取参数 &quot;hashcode_factor&quot; // 如果不存在，则使用默认值 &quot;12&quot; factor = Integer.parseInt(context.getJobParameter(&quot;hashcode_factor&quot;, &quot;12&quot;)); &#125; public int eval(String s) &#123; return s.hashCode() * factor; &#125;&#125;TableEnvironment env = TableEnvironment.create(...);// 1. 设置任务参数env.getConfig().addJobParameter(&quot;hashcode_factor&quot;, &quot;31&quot;);// 2. 注册函数env.createTemporarySystemFunction(&quot;hashCode&quot;, HashCodeFunction.class);// 3. 调用函数env.sqlQuery(&quot;SELECT myField, hashCode(myField) FROM MyTable&quot;); 以上就是关于开发一个 UDF 之前，你需要注意的一些事项，这些内容不但包含了一些基础必备知识，也包含了一些扩展知识，帮助我们开发更强大的 UDF。 4.7.SQL 标量函数（Scalar Function）标量函数即 UDF，常常用于进一条数据出一条数据的场景。 使用 Java\\Scala 开发一个 Scalar Function 必须包含以下几点： ⭐ 实现 org.apache.flink.table.functions.ScalarFunction 接口 ⭐ 实现一个或者多个自定义的 eval 函数，名称必须叫做 eval，eval 方法签名必须是 public 的 ⭐ eval 方法的入参、出参都是直接体现在 eval 函数的签名中 举例： 1234567891011121314151617181920212223242526import org.apache.flink.table.annotation.InputGroup;import org.apache.flink.table.api.*;import org.apache.flink.table.functions.ScalarFunction;import static org.apache.flink.table.api.Expressions.*;public static class HashFunction extends ScalarFunction &#123; // 接受任意类型输入，返回 INT 型输出 public int eval(@DataTypeHint(inputGroup = InputGroup.ANY) Object o) &#123; return o.hashCode(); &#125;&#125;TableEnvironment env = TableEnvironment.create(...);// 在 Table API 里不经注册直接调用函数env.from(&quot;MyTable&quot;).select(call(HashFunction.class, $(&quot;myField&quot;)));// 注册函数env.createTemporarySystemFunction(&quot;HashFunction&quot;, HashFunction.class);// 在 Table API 里调用注册好的函数env.from(&quot;MyTable&quot;).select(call(&quot;HashFunction&quot;, $(&quot;myField&quot;)));// 在 SQL 里调用注册好的函数env.sqlQuery(&quot;SELECT HashFunction(myField) FROM MyTable&quot;); 4.8.SQL 表值函数（Table Function）表值函数即 UDTF，常用于进一条数据，出多条数据的场景。 使用 Java\\Scala 开发一个 Table Function 必须包含以下几点： ⭐ 实现 org.apache.flink.table.functions.TableFunction 接口 ⭐ 实现一个或者多个自定义的 eval 函数，名称必须叫做 eval，eval 方法签名必须是 public 的 ⭐ eval 方法的入参是直接体现在 eval 函数签名中，出参是体现在 TableFunction 类的泛型参数 T 中，eval 是没有返回值的，这一点是和标量函数不同的，Flink TableFunction 接口提供了 collect(T) 来发送输出的数据。这一点也比较好理解，如果都体现在函数签名上，那就成了标量函数了，而使用 collect(T) 才能体现出 进一条数据 出多条数据 在 SQL 中是用 SQL 中的 LATERAL TABLE(&lt;TableFunction&gt;) 配合 JOIN、LEFT JOIN xxx ON TRUE 使用。 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import org.apache.flink.table.annotation.DataTypeHint;import org.apache.flink.table.annotation.FunctionHint;import org.apache.flink.table.api.*;import org.apache.flink.table.functions.TableFunction;import org.apache.flink.types.Row;import static org.apache.flink.table.api.Expressions.*;@FunctionHint(output = @DataTypeHint(&quot;ROW&lt;word STRING, length INT&gt;&quot;))public static class SplitFunction extends TableFunction&lt;Row&gt; &#123; public void eval(String str) &#123; for (String s : str.split(&quot; &quot;)) &#123; // 输出结果 collect(Row.of(s, s.length())); &#125; &#125;&#125;TableEnvironment env = TableEnvironment.create(...);// 在 Table API 里可以直接调用 UDFenv .from(&quot;MyTable&quot;) .joinLateral(call(SplitFunction.class, $(&quot;myField&quot;))) .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));env .from(&quot;MyTable&quot;) .leftOuterJoinLateral(call(SplitFunction.class, $(&quot;myField&quot;))) .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));// 在 Table API 里重命名 UDF 的结果字段env .from(&quot;MyTable&quot;) .leftOuterJoinLateral(call(SplitFunction.class, $(&quot;myField&quot;)).as(&quot;newWord&quot;, &quot;newLength&quot;)) .select($(&quot;myField&quot;), $(&quot;newWord&quot;), $(&quot;newLength&quot;));// 注册函数env.createTemporarySystemFunction(&quot;SplitFunction&quot;, SplitFunction.class);// 在 Table API 里调用注册好的 UDFenv .from(&quot;MyTable&quot;) .joinLateral(call(&quot;SplitFunction&quot;, $(&quot;myField&quot;))) .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));env .from(&quot;MyTable&quot;) .leftOuterJoinLateral(call(&quot;SplitFunction&quot;, $(&quot;myField&quot;))) .select($(&quot;myField&quot;), $(&quot;word&quot;), $(&quot;length&quot;));// 在 SQL 里调用注册好的 UDFenv.sqlQuery( &quot;SELECT myField, word, length &quot; + &quot;FROM MyTable, LATERAL TABLE(SplitFunction(myField))&quot;);env.sqlQuery( &quot;SELECT myField, word, length &quot; + &quot;FROM MyTable &quot; + &quot;LEFT JOIN LATERAL TABLE(SplitFunction(myField)) ON TRUE&quot;);// 在 SQL 里重命名 UDF 字段env.sqlQuery( &quot;SELECT myField, newWord, newLength &quot; + &quot;FROM MyTable &quot; + &quot;LEFT JOIN LATERAL TABLE(SplitFunction(myField)) AS T(newWord, newLength) ON TRUE&quot;); 注意： 如果你是使用 Scala 实现函数，不要使用 Scala 中 object 实现 UDF，Scala object 是单例的，有可能会导致并发问题。 4.9.SQL 聚合函数（Aggregate Function）聚合函数即 UDAF，常用于进多条数据，出一条数据的场景。 上面的图片展示了一个聚合函数的例子以及聚合函数包含的几个重要方法。 假设你有一个关于饮料的表。表里面有三个字段，分别是 id、name、price，表里有 5 行数据。 假设你需要找到所有饮料里最贵的饮料的价格，即执行一个 max() 聚合就能拿到结果。那么 max() 聚合的执行旧需要遍历所有 5 行数据，最终结果就只有一个数值。 使用 Java\\Scala 开发一个 Aggregate Function 必须包含以下几点： ⭐ 实现 AggregateFunction 接口，其中所有的方法必须是 public 的、非 static 的 ⭐ 必须实现以下几个方法： ⭐ Acc聚合中间结果 createAccumulator()：为当前 Key 初始化一个空的 accumulator，其存储了聚合的中间结果，比如在执行 max() 时会存储当前的 max 值 ⭐ accumulate(Acc accumulator, Input输入参数)：对于每一行数据，都会调用 accumulate() 方法来更新 accumulator，这个方法就是用于处理每一条输入数据；这个方法必须声明为 public 和非 static 的。accumulate 方法可以重载，每个方法的参数类型可以不同，并且支持变长参数。 ⭐ Output输出参数 getValue(Acc accumulator)：通过调用 getValue 方法来计算和返回最终的结果 ⭐ 还有几个方法是在某些场景下才必须实现的： ⭐ retract(Acc accumulator, Input输入参数)：在回撤流的场景下必须要实现，Flink 在计算回撤数据时需要进行调用，如果没有实现则会直接报错 ⭐ merge(Acc accumulator, Iterable&lt;Acc&gt; it)：在许多批式聚合以及流式聚合中的 Session、Hop 窗口聚合场景下都是必须要实现的。除此之外，这个方法对于优化也很多帮助。例如，如果你打开了两阶段聚合优化，就需要 AggregateFunction 实现 merge 方法，从而可以做到在数据进行 shuffle 前先进行一次聚合计算。 ⭐ resetAccumulator()：在批式聚合中是必须实现的。 ⭐ 还有几个关于入参、出参数据类型信息的方法，默认情况下，用户的 Input输入参数（accumulate(Acc accumulator, Input输入参数) 的入参 Input输入参数）、accumulator（Acc聚合中间结果 createAccumulator() 的返回结果）、Output输出参数 数据类型（Output输出参数 getValue(Acc accumulator) 的 Output输出参数）都会被 Flink 使用反射获取到。但是对于 accumulator 和 Output输出参数 类型来说，Flink SQL 的类型推导在遇到复杂类型的时候可能会推导出错误的结果（注意：Input输入参数 因为是上游算子传入的，所以类型信息是确认的，不会出现推导错误的情况），比如那些非基本类型 POJO 的复杂类型。所以跟 ScalarFunction 和 TableFunction 一样，AggregateFunction 提供了 AggregateFunction#getResultType() 和 AggregateFunction#getAccumulatorType() 来分别指定最终返回值类型和 accumulator 的类型，两个函数的返回值类型都是 TypeInformation，所以熟悉 DataStream 的小伙伴很容易上手。 ⭐ getResultType()：即 Output输出参数 getValue(Acc accumulator) 的输出结果数据类型 ⭐ getAccumulatorType()：即 Acc聚合中间结果 createAccumulator() 的返回结果数据类型 这个时候，我们直接来举一个加权平均值的例子看下，总共 3 个步骤： ⭐ 定义一个聚合函数来计算某一列的加权平均 ⭐ 在 TableEnvironment 中注册函数 ⭐ 在查询中使用函数 为了计算加权平均值，accumulator 需要存储加权总和以及数据的条数。在我们的例子里，我们定义了一个类 WeightedAvgAccumulator 来作为 accumulator。 Flink 的 checkpoint 机制会自动保存 accumulator，在失败时进行恢复，以此来保证精确一次的语义。 我们的 WeightedAvg（聚合函数）的 accumulate 方法有三个输入参数。第一个是 WeightedAvgAccum accumulator，另外两个是用户自定义的输入：输入的值 ivalue 和 输入的权重 iweight。 尽管 retract()、merge()、resetAccumulator() 这几个方法在大多数聚合类型中都不是必须实现的，博主也在样例中提供了他们的实现。并且定义了 getResultType() 和 getAccumulatorType()。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import org.apache.flink.table.api.*;import org.apache.flink.table.functions.AggregateFunction;import static org.apache.flink.table.api.Expressions.*;// 自定义一个计算权重 avg 的 accmulatorpublic static class WeightedAvgAccumulator &#123; public long sum = 0; public int count = 0;&#125;// 输入：Long iValue, Integer iWeightpublic static class WeightedAvg extends AggregateFunction&lt;Long, WeightedAvgAccumulator&gt; &#123; @Override // 创建一个 accumulator public WeightedAvgAccumulator createAccumulator() &#123; return new WeightedAvgAccumulator(); &#125; public void accumulate(WeightedAvgAccumulator acc, Long iValue, Integer iWeight) &#123; acc.sum += iValue * iWeight; acc.count += iWeight; &#125; public void retract(WeightedAvgAccumulator acc, Long iValue, Integer iWeight) &#123; acc.sum -= iValue * iWeight; acc.count -= iWeight; &#125; @Override // 获取返回结果 public Long getValue(WeightedAvgAccumulator acc) &#123; if (acc.count == 0) &#123; return null; &#125; else &#123; return acc.sum / acc.count; &#125; &#125; // Session window 可以使用这个方法将几个单独窗口的结果合并 public void merge(WeightedAvgAccumulator acc, Iterable&lt;WeightedAvgAccumulator&gt; it) &#123; for (WeightedAvgAccumulator a : it) &#123; acc.count += a.count; acc.sum += a.sum; &#125; &#125; public void resetAccumulator(WeightedAvgAccumulator acc) &#123; acc.count = 0; acc.sum = 0L; &#125;&#125;TableEnvironment env = TableEnvironment.create(...);env .from(&quot;MyTable&quot;) .groupBy($(&quot;myField&quot;)) .select($(&quot;myField&quot;), call(WeightedAvg.class, $(&quot;value&quot;), $(&quot;weight&quot;)));// 注册函数env.createTemporarySystemFunction(&quot;WeightedAvg&quot;, WeightedAvg.class);// Table API 调用函数env .from(&quot;MyTable&quot;) .groupBy($(&quot;myField&quot;)) .select($(&quot;myField&quot;), call(&quot;WeightedAvg&quot;, $(&quot;value&quot;), $(&quot;weight&quot;)));// SQL API 调用函数env.sqlQuery( &quot;SELECT myField, WeightedAvg(`value`, weight) FROM MyTable GROUP BY myField&quot;); 4.10.SQL 表值聚合函数（Table Aggregate Function）表值聚合函数即 UDTAF。首先说明这个函数目前只能在 Table API 中进行使用，不能在 SQL API 中使用。那么这个函数有什么作用呢，为什么被创建出来？ 因为在 SQL 表达式中，如果我们想对数据先分组再进行聚合取值，能选择的就是 select max(xxx) from source_table group by key1, key2。但是上面这个 SQL 的 max 语义最后产出的结果只有一条最终结果，如果我想取聚合结果最大的 n 条数据，并且 n 条数据，每一条都要输出一次结果数据，上面的 SQL 就没有办法实现了（因为在聚合的情况下还输出多条，从上述 SQL 语义上来说就是不正确的）。 所以 UDTAF 就是为了处理这种场景，他可以让我们自定义 怎么去，取多少条 最终的聚合结果。所以可以看到 UDTAF 和 UDAF 是类似的。如下图所示： 上图展示了一个表值聚合函数的例子。 假设你有一个饮料的表，这个表有 3 列，分别是 id、name 和 price，一共有 5 行。 假设你需要找到价格最高的两个饮料，类似于 top2() 表值聚合函数。你需要遍历所有 5 行数据，输出结果为 2 行数据的一个表。 使用 Java\\Scala 开发一个 Table Aggregate Function 必须包含以下几点： ⭐ 实现 TableAggregateFunction 接口，其中所有的方法必须是 public 的、非 static 的 ⭐ 必须实现以下几个方法： ⭐ Acc聚合中间结果 createAccumulator()：为当前 Key 初始化一个空的 accumulator，其存储了聚合的中间结果，比如在执行 max() 时会存储每一条中间结果的 max 值 ⭐ accumulate(Acc accumulator, Input输入参数)：对于每一行数据，都会调用 accumulate() 方法来更新 accumulator，这个方法就是对每一条输入数据进行执行，比如执行 max() 时，遍历每一条数据执行；在实现这个方法是必须声明为 public 和非 static 的。accumulate 方法可以重载，每个方法的参数类型不同，并且支持变长参数。 ⭐ emitValue(Acc accumulator, Collector&lt;OutPut&gt; collector) 或者 emitUpdateWithRetract(Acc accumulator, RetractableCollector&lt;OutPut&gt; collector)：当遍历所有的数据，当所有的数据都处理完了之后，通过调用 emit 方法来计算和输出最终的结果，在这里你就可以自定义到底输出多条少以及怎么样去输出结果。那么对于 emitValue 以及 emitUpdateWithRetract 的区别来说，拿 TopN 实现来说，emitValue 每次都会发送所有的最大的 n 个值，而这在流式任务中可能会有一些性能问题。为了提升性能，用户可以实现 emitUpdateWithRetract 方法。这个方法在 retract 模式下会增量的输出结果，比如只在有数据更新时，可以做到撤回老的数据，然后再发送新的数据，而不需要每次都发出全量的最新数据。如果我们同时定义了 emitUpdateWithRetract、emitValue 方法，那 emitUpdateWithRetract 会优先于 emitValue 方法被使用，因为引擎会认为 emitUpdateWithRetract 会更加高效，因为它的输出是增量的。 ⭐ 还有几个方法是在某些场景下才必须实现的： ⭐ retract(Acc accumulator, Input输入参数)：在回撤流的场景下必须要实现，Flink 在计算回撤数据时需要进行调用，如果没有实现则会直接报错 ⭐ merge(Acc accumulator, Iterable&lt;Acc&gt; it)：在许多批式聚合以及流式聚合中的 Session、Hop 窗口聚合场景下都是必须要实现的。除此之外，这个方法对于优化也很多帮助。例如，如果你打开了两阶段聚合优化，就需要 AggregateFunction 实现 merge 方法，从而在第一阶段先进行数据聚合。 ⭐ resetAccumulator()：在批式聚合中是必须实现的。 ⭐ 还有几个关于入参、出参数据类型信息的方法，默认情况下，用户的 Input输入参数（accumulate(Acc accumulator, Input输入参数) 的入参 Input输入参数）、accumulator（Acc聚合中间结果 createAccumulator() 的返回结果）、Output输出参数 数据类型（emitValue(Acc acc, Collector&lt;Output输出参数&gt; out) 的 Output输出参数）都会被 Flink 使用反射获取到。但是对于 accumulator 和 Output输出参数 类型来说，Flink SQL 的类型推导在遇到复杂类型的时候可能会推导出错误的结果（注意：Input输入参数 因为是上游算子传入的，所以类型信息是确认的，不会出现推导错误的情况），比如那些非基本类型 POJO 的复杂类型。所以跟 ScalarFunction 和 TableFunction 一样，AggregateFunction 提供了 TableAggregateFunction#getResultType() 和 TableAggregateFunction#getAccumulatorType() 来分别指定最终返回值类型和 accumulator 的类型，两个函数的返回值类型都是 TypeInformation，所以熟悉 DataStream 的小伙伴很容易上手。 ⭐ getResultType()：即 emitValue(Acc acc, Collector&lt;Output输出参数&gt; out) 的输出结果数据类型 ⭐ getAccumulatorType()：即 Acc聚合中间结果 createAccumulator() 的返回结果数据类型 这个时候，我们直接来举一个 Top2 的例子看下吧： ⭐ 定义一个 TableAggregateFunction 来计算给定列的最大的 2 个值 ⭐ 在 TableEnvironment 中注册函数 ⭐ 在 Table API 查询中使用函数（当前只在 Table API 中支持 TableAggregateFunction） 为了计算最大的 2 个值，accumulator 需要保存当前看到的最大的 2 个值。 在我们的例子中，我们定义了类 Top2Accum 来作为 accumulator。 Flink 的 checkpoint 机制会自动保存 accumulator，并且在失败时进行恢复，来保证精确一次的语义。 我们的 Top2 表值聚合函数（TableAggregateFunction）的 accumulate() 方法有两个输入，第一个是 Top2Accum accumulator，另一个是用户定义的输入：输入的值 v。尽管 merge() 方法在大多数聚合类型中不是必须的，我们也在样例中提供了它的实现。并且定义了 getResultType() 和 getAccumulatorType() 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Accumulator for Top2. */public class Top2Accum &#123; public Integer first; public Integer second;&#125;public static class Top2 extends TableAggregateFunction&lt;Tuple2&lt;Integer, Integer&gt;, Top2Accum&gt; &#123; @Override public Top2Accum createAccumulator() &#123; Top2Accum acc = new Top2Accum(); acc.first = Integer.MIN_VALUE; acc.second = Integer.MIN_VALUE; return acc; &#125; public void accumulate(Top2Accum acc, Integer v) &#123; if (v &gt; acc.first) &#123; acc.second = acc.first; acc.first = v; &#125; else if (v &gt; acc.second) &#123; acc.second = v; &#125; &#125; public void merge(Top2Accum acc, java.lang.Iterable&lt;Top2Accum&gt; iterable) &#123; for (Top2Accum otherAcc : iterable) &#123; accumulate(acc, otherAcc.first); accumulate(acc, otherAcc.second); &#125; &#125; public void emitValue(Top2Accum acc, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out) &#123; // emit the value and rank if (acc.first != Integer.MIN_VALUE) &#123; out.collect(Tuple2.of(acc.first, 1)); &#125; if (acc.second != Integer.MIN_VALUE) &#123; out.collect(Tuple2.of(acc.second, 2)); &#125; &#125;&#125;// 注册函数StreamTableEnvironment tEnv = ...tEnv.registerFunction(&quot;top2&quot;, new Top2());// 初始化表Table tab = ...;// 使用函数tab.groupBy(&quot;key&quot;) .flatAggregate(&quot;top2(a) as (v, rank)&quot;) .select(&quot;key, v, rank&quot;); 下面的例子展示了如何使用 emitUpdateWithRetract 方法来只发送更新的数据。 为了只发送更新的结果，accumulator 保存了上一次的最大的 2 个值，也保存了当前最大的 2 个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Accumulator for Top2. */public class Top2Accum &#123; public Integer first; public Integer second; public Integer oldFirst; public Integer oldSecond;&#125;public static class Top2 extends TableAggregateFunction&lt;Tuple2&lt;Integer, Integer&gt;, Top2Accum&gt; &#123; @Override public Top2Accum createAccumulator() &#123; Top2Accum acc = new Top2Accum(); acc.first = Integer.MIN_VALUE; acc.second = Integer.MIN_VALUE; acc.oldFirst = Integer.MIN_VALUE; acc.oldSecond = Integer.MIN_VALUE; return acc; &#125; public void accumulate(Top2Accum acc, Integer v) &#123; if (v &gt; acc.first) &#123; acc.second = acc.first; acc.first = v; &#125; else if (v &gt; acc.second) &#123; acc.second = v; &#125; &#125; public void emitUpdateWithRetract(Top2Accum acc, RetractableCollector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out) &#123; if (!acc.first.equals(acc.oldFirst)) &#123; // if there is an update, retract old value then emit new value. if (acc.oldFirst != Integer.MIN_VALUE) &#123; out.retract(Tuple2.of(acc.oldFirst, 1)); &#125; out.collect(Tuple2.of(acc.first, 1)); acc.oldFirst = acc.first; &#125; if (!acc.second.equals(acc.oldSecond)) &#123; // if there is an update, retract old value then emit new value. if (acc.oldSecond != Integer.MIN_VALUE) &#123; out.retract(Tuple2.of(acc.oldSecond, 2)); &#125; out.collect(Tuple2.of(acc.second, 2)); acc.oldSecond = acc.second; &#125; &#125;&#125;// 注册函数StreamTableEnvironment tEnv = ...tEnv.registerFunction(&quot;top2&quot;, new Top2());// 初始化表Table tab = ...;// 使用函数tab.groupBy(&quot;key&quot;) .flatAggregate(&quot;top2(a) as (v, rank)&quot;) .select(&quot;key, v, rank&quot;); 5.SQL 能力扩展篇5.1.SQL UDF 扩展 - Module在介绍 Flink Module 具体能力之前，我们先来聊聊博主讲述的思路： ⭐ 背景及应用场景介绍 ⭐ Flink Module 功能介绍 ⭐ 应用案例：Flink SQL 支持 Hive UDF 5.1.1.Flink SQL Module 应用场景兄弟们，想想其实大多数公司都是从离线数仓开始建设的。相信大家必然在自己的生产环境中开发了非常多的 Hive UDF。随着需求对于时效性要求的增高，越来越多的公司也开始建设起实时数仓。很多场景下实时数仓的建设都是随着离线数仓而建设的。实时数据使用 Flink 产出，离线数据使用 Hive/Spark 产出。 那么回到我们的问题：为什么需要给 Flink UDF 做扩展呢？可能这个问题比较大，那么博主分析的具体一些，如果 Flink 扩展支持 Hive UDF 对我们有哪些好处呢？ 博主分析了下，结论如下： 站在数据需求的角度来说，一般会有以下两种情况： ⭐ 以前已经有了离线数据链路，需求方也想要实时数据。如果直接能用已经开发好的 hive udf，则不用将相同的逻辑迁移到 flink udf 中，并且后续无需费时费力维护两个 udf 的逻辑一致性。 ⭐ 实时和离线的需求都是新的，需要新开发。如果只开发一套 UDF，则事半功倍。 因此在 Flink 中支持 Hive UDF（也即扩展 Flink 的 UDF 能力）这件事对开发人员提效来说是非常有好处的。 5.1.2.Flink SQL Module 功能介绍Module 允许 Flink 扩展函数能力。它是可插拔的，Flink 官方本身已经提供了一些 Module，用户也可以编写自己的 Module。 例如，用户可以定义自己的函数，并将其作为加载进入 Flink，以在 Flink SQL 和 Table API 中使用。 再举一个例子，用户可以加载官方已经提供的的 Hive Module，将 Hive 已有的内置函数作为 Flink 的内置函数。 目前 Flink 包含了以下三种 Module： ⭐ CoreModule：CoreModule 是 Flink 内置的 Module，其包含了目前 Flink 内置的所有 UDF，Flink 默认开启的 Module 就是 CoreModule，我们可以直接使用其中的 UDF ⭐ HiveModule：HiveModule 可以将 Hive 内置函数作为 Flink 的系统函数提供给 SQL\\Table API 用户进行使用，比如 get_json_object 这类 Hive 内置函数（Flink 默认的 CoreModule 是没有的） ⭐ 用户自定义 Module：用户可以实现 Module 接口实现自己的 UDF 扩展 Module 在 Flink 中，Module 可以被 加载、启用、禁用、卸载 Module，当 TableEnvironment 加载（见 SQL 语法篇的 Load Module） Module 之后，默认就是开启的。 Flink 是同时支持多个 Module 的，并且根据加载 Module 的顺序去按顺序查找和解析 UDF，先查到的先解析使用。 此外，Flink 只会解析已经启用了的 Module。那么当两个 Module 中出现两个同名的函数时，会有以下三种情况： ⭐ 如果两个 Module 都启用的话，Flink 会根据加载 Module 的顺序进行解析，结果就是会使用顺序为第一个的 Module 的 UDF ⭐ 如果只有一个 Module 启用的话，Flink 就只会从启用的 Module 解析 UDF ⭐ 如果两个 Module 都没有启用，Flink 就无法解析这个 UDF 当然如果出现第一种情况时，用户也可以改变使用 Module 的顺序。比如用户可以使用 USE MODULE hive, core 语句去将 Hive Module 设为第一个使用及解析的 Module。 另外，用户可以使用 USE MODULES hive 去禁用默认的 core Module，注意，禁用不是卸载 Module，用户之后还可以再次启用 Module，并且使用 USE MODULES core 去将 core Module 设置为启用的。如果使用未加载的 Module，则会直接抛出异常。 禁用和卸载 Module 的区别在于禁用依然会在 TableEnvironment 保留 Module，用户依然可以使用使用 list 命令看到禁用的 Module。 注意： 由于 Module 的 UDF 是被 Flink 认为是 Flink 系统内置的，它不和任何 Catalog，数据库绑定，所以这部分 UDF 没有对应的命名空间，即没有 Catalog，数据库命名空间。 ⭐ 使用 SQL API 加载、卸载、使用、列出 Module 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081EnvironmentSettings settings = EnvironmentSettings.newInstance().useBlinkPlanner().build();TableEnvironment tableEnv = TableEnvironment.create(settings);// 展示加载和启用的 ModuletableEnv.executeSql(&quot;SHOW MODULES&quot;).print();// +-------------+// | module name |// +-------------+// | core |// +-------------+tableEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+------+// | module name | used |// +-------------+------+// | core | true |// +-------------+------+// 加载 hive moduletableEnv.executeSql(&quot;LOAD MODULE hive WITH (&#x27;hive-version&#x27; = &#x27;...&#x27;)&quot;);// 展示所有启用的 moduletableEnv.executeSql(&quot;SHOW MODULES&quot;).print();// +-------------+// | module name |// +-------------+// | core |// | hive |// +-------------+// 展示所有加载的 module 以及它们的启用状态tableEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+------+// | module name | used |// +-------------+------+// | core | true |// | hive | true |// +-------------+------+// 改变 module 解析顺序tableEnv.executeSql(&quot;USE MODULES hive, core&quot;);tableEnv.executeSql(&quot;SHOW MODULES&quot;).print();// +-------------+// | module name |// +-------------+// | hive |// | core |// +-------------+tableEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+------+// | module name | used |// +-------------+------+// | hive | true |// | core | true |// +-------------+------+// 禁用 core moduletableEnv.executeSql(&quot;USE MODULES hive&quot;);tableEnv.executeSql(&quot;SHOW MODULES&quot;).print();// +-------------+// | module name |// +-------------+// | hive |// +-------------+tableEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+-------+// | module name | used |// +-------------+-------+// | hive | true |// | core | false |// +-------------+-------+// 卸载 hive moduletableEnv.executeSql(&quot;UNLOAD MODULE hive&quot;);tableEnv.executeSql(&quot;SHOW MODULES&quot;).print();// Empty settableEnv.executeSql(&quot;SHOW FULL MODULES&quot;).print();// +-------------+-------+// | module name | used |// +-------------+-------+// | hive | false |// +-------------+-------+ ⭐ 使用 Java API 加载、卸载、使用、列出 Module 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081EnvironmentSettings settings = EnvironmentSettings.newInstance().useBlinkPlanner().build();TableEnvironment tableEnv = TableEnvironment.create(settings);// Show initially loaded and enabled modulestableEnv.listModules();// +-------------+// | module name |// +-------------+// | core |// +-------------+tableEnv.listFullModules();// +-------------+------+// | module name | used |// +-------------+------+// | core | true |// +-------------+------+// Load a hive moduletableEnv.loadModule(&quot;hive&quot;, new HiveModule());// Show all enabled modulestableEnv.listModules();// +-------------+// | module name |// +-------------+// | core |// | hive |// +-------------+// Show all loaded modules with both name and use statustableEnv.listFullModules();// +-------------+------+// | module name | used |// +-------------+------+// | core | true |// | hive | true |// +-------------+------+// Change resolution ordertableEnv.useModules(&quot;hive&quot;, &quot;core&quot;);tableEnv.listModules();// +-------------+// | module name |// +-------------+// | hive |// | core |// +-------------+tableEnv.listFullModules();// +-------------+------+// | module name | used |// +-------------+------+// | hive | true |// | core | true |// +-------------+------+// Disable core moduletableEnv.useModules(&quot;hive&quot;);tableEnv.listModules();// +-------------+// | module name |// +-------------+// | hive |// +-------------+tableEnv.listFullModules();// +-------------+-------+// | module name | used |// +-------------+-------+// | hive | true |// | core | false |// +-------------+-------+// Unload hive moduletableEnv.unloadModule(&quot;hive&quot;);tableEnv.listModules();// Empty settableEnv.listFullModules();// +-------------+-------+// | module name | used |// +-------------+-------+// | hive | false |// +-------------+-------+ 5.1.3.应用案例：Flink SQL 支持 Hive UDFFlink 支持 hive UDF 这件事分为两个部分。 ⭐ Flink 扩展支持 hive 内置 UDF ⭐ Flink 扩展支持用户自定义 hive UDF 第一部分：Flink 扩展支持 Hive 内置 UDF，比如 get_json_object，rlike 等等。 有同学问了，这么基本的 UDF，Flink 都没有吗？ 确实没有。关于 Flink SQL 内置的 UDF 见如下链接，大家可以看看 Flink 支持了哪些 UDF：https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/functions/systemfunctions/ 那么如果我如果强行使用 get_json_object 这个 UDF，会发生啥呢？结果如下图。 直接报错找不到 UDF。 第二部分：Flink 扩展支持用户自定义 Hive UDF。 内置函数解决不了用户的复杂需求，用户就需要自己写 Hive UDF，并且这部分自定义 UDF 也想在 flink sql 中使用。 下面看看怎么在 Flink SQL 中进行这两种扩展。 ⭐ flink 扩展支持 hive 内置 udf 步骤如下： ⭐ 引入 hive 的 connector。其中包含了 flink 官方提供的一个 HiveModule。在 HiveModule 中包含了 hive 内置的 udf。 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-hive_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;&lt;/dependency&gt; ⭐ 在 StreamTableEnvironment 中加载 HiveModule。 123String name = &quot;default&quot;;String version = &quot;3.1.2&quot;;tEnv.loadModule(name, new HiveModule(version)); 然后在控制台打印一下目前有的 module。 12String[] modules = tEnv.listModules();Arrays.stream(modules).forEach(System.out::println); 然后可以看到除了 core module，还有我们刚刚加载进去的 default module。 12defaultcore ⭐ 查看所有 module 的所有 udf。在控制台打印一下。 12String[] functions = tEnv.listFunctions();Arrays.stream(functions).forEach(System.out::println); 就会将 default 和 core module 中的所有包含的 udf 给列举出来，当然也就包含了 hive module 中的 get_json_object。 然后我们再去在 Flink SQL 中使用 get_json_object 这个 UDF，就没有报错，能正常输出结果了。 使用 Flink Hive connector 自带的 HiveModule，已经能够解决很大一部分常见 UDF 使用的问题了。 ⭐ Flink 扩展支持用户自定义 Hive UDF 原本博主是直接想要使用 Flink SQL 中的 create temporary function 去执行引入自定义 Hive UDF 的。 举例如下： 1CREATE TEMPORARY FUNCTION test_hive_udf as &#x27;flink.examples.sql._09.udf._02_stream_hive_udf.TestGenericUDF&#x27;; 发现在执行这句 SQL 时，是可以执行成功，将 UDF 注册进去的。 但是在后续 UDF 初始化时就报错了。具体错误如下图。直接报错 ClassCastException。 看了下源码，Flink 流任务模式下（未连接 Hive MetaStore 时）在创建 UDF 时会认为这个 UDF 是 Flink 生态体系中的 UDF。 所以在初始化我们引入的 TestGenericUDF 时，默认会按照 Flink 的 UserDefinedFunction 强转，因此才会报强转错误。 那么我们就不能使用 Hive UDF 了吗？ 错误，小伙伴萌岂敢有这种想法。博主都把这个标题列出来了（牛逼都吹出去了），还能给不出解决方案嘛。 思路见下一节。 ⭐ Flink 扩展支持用户自定义 Hive UDF 的增强 module 其实思路很简单。 使用 Flink SQL 中的 create temporary function 虽然不能执行，但是 Flink 提供了插件化的自定义 module。 我们可以扩展一个支持用户自定义 Hive UDF 的 module，使用这个 module 来支持自定义的 Hive UDF。 实现的代码也非常简单。简单的把 Flink Hive connector 提供的 HiveModule 做一个增强即可，即下图中的 HiveModuleV2。使用方式如下图所示： 源码公众号后台回复1.13.2 sql hive udf获取。 然后程序就正常跑起来了。 肥肠滴好用！ 5.2.SQL 元数据扩展 - Catalog5.2.1.Flink Catalog 功能介绍数据处理最关键的方面之一是管理元数据。元数据可以是临时的，例如临时表、UDF。 元数据也可以是持久化的，例如 Hive MetaStore 中的元数据。 Flink SQL 中是由 Catalog 提供了元数据信息，例如数据库、表、分区、视图以及数据库或其他外部系统中存储的函数和信息。对标 Hive 去理解就是 Hive 的 MetaStore，都是用于存储计算引擎涉及到的元数据信息。 Catalog 允许用户引用其数据存储系统中现有的元数据，并自动将其映射到 Flink 的相应元数据。例如，Flink 可以直接使用 Hive MetaStore 中的表的元数据，也可以将 Flink SQL 中的元数据存储到 Hive MetaStore 中。Catalog 极大地简化了用户开始使用 Flink 的步骤，提升了用户体验。 目前 Flink 包含了以下四种 Catalog： ⭐ GenericInMemoryCatalog：GenericInMemoryCatalog 是基于内存实现的 Catalog，所有元数据只在 session 的生命周期（即一个 Flink 任务一次运行生命周期内）内可用。 ⭐ JdbcCatalog：JdbcCatalog 使得用户可以将 Flink 通过 JDBC 协议连接到关系数据库。PostgresCatalog 是当前实现的唯一一种 JDBC Catalog，即可以将 Flink SQL 的预案数据存储在 Postgres 中。 1234567// PostgresCatalog 方法支持的方法PostgresCatalog.databaseExists(String databaseName)PostgresCatalog.listDatabases()PostgresCatalog.getDatabase(String databaseName)PostgresCatalog.listTables(String databaseName)PostgresCatalog.getTable(ObjectPath tablePath)PostgresCatalog.tableExists(ObjectPath tablePath) ⭐ HiveCatalog：HiveCatalog 有两个用途，作为 Flink 元数据的持久化存储，以及作为读写现有 Hive 元数据的接口。注意：Hive MetaStore 以小写形式存储所有元数据对象名称。而 GenericInMemoryCatalog 会区分大小写。 1234567891011TableEnvironment tableEnv = TableEnvironment.create(settings);String name = &quot;myhive&quot;;String defaultDatabase = &quot;mydatabase&quot;;String hiveConfDir = &quot;/opt/hive-conf&quot;;HiveCatalog hive = new HiveCatalog(name, defaultDatabase, hiveConfDir);tableEnv.registerCatalog(&quot;myhive&quot;, hive);// set the HiveCatalog as the current catalog of the sessiontableEnv.useCatalog(&quot;myhive&quot;); ⭐ 用户自定义 Catalog：用户可以实现 Catalog 接口实现自定义 Catalog 下面看看 Flink Catalog 提供了什么 API，以及对应 API 的使用案例： ⭐ 使用 SQL API 将表创建注册进 Catalog 123456789101112131415TableEnvironment tableEnv = ...// 创建 HiveCatalog Catalog catalog = new HiveCatalog(&quot;myhive&quot;, null, &quot;&lt;path_of_hive_conf&gt;&quot;);// 注册 catalogtableEnv.registerCatalog(&quot;myhive&quot;, catalog);// 在 catalog 中创建 databasetableEnv.executeSql(&quot;CREATE DATABASE mydb WITH (...)&quot;);// 在 catalog 中创建表tableEnv.executeSql(&quot;CREATE TABLE mytable (name STRING, age INT) WITH (...)&quot;);tableEnv.listTables(); // 列出当前 myhive.mydb 中的所有表 ⭐ 使用 Java API 将表创建注册进 Catalog 12345678910111213141516171819202122232425262728293031323334353637import org.apache.flink.table.api.*;import org.apache.flink.table.catalog.*;import org.apache.flink.table.catalog.hive.HiveCatalog;import org.apache.flink.table.descriptors.Kafka;TableEnvironment tableEnv = TableEnvironment.create(EnvironmentSettings.newInstance().build());// 创建 HiveCatalog Catalog catalog = new HiveCatalog(&quot;myhive&quot;, null, &quot;&lt;path_of_hive_conf&gt;&quot;);// 注册 catalogtableEnv.registerCatalog(&quot;myhive&quot;, catalog);// 在 catalog 中创建 databasecatalog.createDatabase(&quot;mydb&quot;, new CatalogDatabaseImpl(...));// 在 catalog 中创建表TableSchema schema = TableSchema.builder() .field(&quot;name&quot;, DataTypes.STRING()) .field(&quot;age&quot;, DataTypes.INT()) .build();catalog.createTable( new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogTableImpl( schema, new Kafka() .version(&quot;0.11&quot;) .... .startFromEarlist() .toProperties(), &quot;my comment&quot; ), false ); List&lt;String&gt; tables = catalog.listTables(&quot;mydb&quot;); // 列出当前 myhive.mydb 中的所有表 5.2.2.操作 Catalog 的 API这里只列出了 Java 的 Catalog API，用户也可以使用 SQL DDL API 实现相同的功能。关于 DDL 的详细信息请参考之前介绍到的 SQL CREATE DDL 章节。 ⭐ Catalog 操作 12345678// 注册 CatalogtableEnv.registerCatalog(new CustomCatalog(&quot;myCatalog&quot;));// 切换 Catalog 和 DatabasetableEnv.useCatalog(&quot;myCatalog&quot;);tableEnv.useDatabase(&quot;myDb&quot;);// 也可以通过以下方式访问对应的表tableEnv.from(&quot;not_the_current_catalog.not_the_current_db.my_table&quot;); ⭐ 数据库操作 1234567891011121314151617// create databasecatalog.createDatabase(&quot;mydb&quot;, new CatalogDatabaseImpl(...), false);// drop databasecatalog.dropDatabase(&quot;mydb&quot;, false);// alter databasecatalog.alterDatabase(&quot;mydb&quot;, new CatalogDatabaseImpl(...), false);// get databsecatalog.getDatabase(&quot;mydb&quot;);// check if a database existcatalog.databaseExists(&quot;mydb&quot;);// list databases in a catalogcatalog.listDatabases(&quot;mycatalog&quot;); ⭐ 表操作 1234567891011121314151617181920// create tablecatalog.createTable(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogTableImpl(...), false);// drop tablecatalog.dropTable(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), false);// alter tablecatalog.alterTable(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogTableImpl(...), false);// rename tablecatalog.renameTable(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), &quot;my_new_table&quot;);// get tablecatalog.getTable(&quot;mytable&quot;);// check if a table exist or notcatalog.tableExists(&quot;mytable&quot;);// list tables in a databasecatalog.listTables(&quot;mydb&quot;); ⭐ 视图操作 1234567891011121314151617181920// create viewcatalog.createTable(new ObjectPath(&quot;mydb&quot;, &quot;myview&quot;), new CatalogViewImpl(...), false);// drop viewcatalog.dropTable(new ObjectPath(&quot;mydb&quot;, &quot;myview&quot;), false);// alter viewcatalog.alterTable(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogViewImpl(...), false);// rename viewcatalog.renameTable(new ObjectPath(&quot;mydb&quot;, &quot;myview&quot;), &quot;my_new_view&quot;, false);// get viewcatalog.getTable(&quot;myview&quot;);// check if a view exist or notcatalog.tableExists(&quot;mytable&quot;);// list views in a databasecatalog.listViews(&quot;mydb&quot;); ⭐ 分区操作 12345678910111213141516171819202122232425262728293031// create viewcatalog.createPartition( new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogPartitionSpec(...), new CatalogPartitionImpl(...), false);// drop partitioncatalog.dropPartition(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogPartitionSpec(...), false);// alter partitioncatalog.alterPartition( new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogPartitionSpec(...), new CatalogPartitionImpl(...), false);// get partitioncatalog.getPartition(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogPartitionSpec(...));// check if a partition exist or notcatalog.partitionExists(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogPartitionSpec(...));// list partitions of a tablecatalog.listPartitions(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;));// list partitions of a table under a give partition speccatalog.listPartitions(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), new CatalogPartitionSpec(...));// list partitions of a table by expression filtercatalog.listPartitionsByFilter(new ObjectPath(&quot;mydb&quot;, &quot;mytable&quot;), Arrays.asList(epr1, ...)); ⭐ 函数操作 1234567891011121314151617// create functioncatalog.createFunction(new ObjectPath(&quot;mydb&quot;, &quot;myfunc&quot;), new CatalogFunctionImpl(...), false);// drop functioncatalog.dropFunction(new ObjectPath(&quot;mydb&quot;, &quot;myfunc&quot;), false);// alter functioncatalog.alterFunction(new ObjectPath(&quot;mydb&quot;, &quot;myfunc&quot;), new CatalogFunctionImpl(...), false);// get functioncatalog.getFunction(&quot;myfunc&quot;);// check if a function exist or notcatalog.functionExists(&quot;myfunc&quot;);// list functions in a databasecatalog.listFunctions(&quot;mydb&quot;); 5.3.SQL 任务参数配置关于 Flink SQL 详细的配置项及功能如下链接所示，详细内容大家可以点击链接去看，博主下面只介绍常用的性能优化参数及其功能： https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/config/ 5.3.1.参数设置方式Flink SQL 相关参数需要在 TableEnvironment 中设置。如下案例： 123456789// instantiate table environmentTableEnvironment tEnv = ...// access flink configurationConfiguration configuration = tEnv.getConfig().getConfiguration();// set low-level key-value optionsconfiguration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;);configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;); 具体参数分为以下 3 类： ⭐ 运行时参数：优化 Flink SQL 任务在执行时的任务性能 ⭐ 优化器参数：Flink SQL 任务在生成执行计划时，经过优化器优化生成更优的执行计划 ⭐ 表参数：用于调整 Flink SQL table 的执行行为 5.3.2.运行时参数用于优化 Flink SQL 任务在执行时的任务性能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 默认值：100// 值类型：Integer// 流批任务：流、批任务都支持// 用处：异步 lookup join 中最大的异步 IO 执行数目table.exec.async-lookup.buffer-capacity: 100// 默认值：false// 值类型：Boolean// 流批任务：流任务支持// 用处：MiniBatch 优化是一种专门针对 unbounded 流任务的优化（即非窗口类应用），其机制是在 `允许的延迟时间间隔内` 以及 `达到最大缓冲记录数` 时触发以减少 `状态访问` 的优化，从而节约处理时间。下面两个参数一个代表 `允许的延迟时间间隔`，另一个代表 `达到最大缓冲记录数`。table.exec.mini-batch.enabled: false// 默认值：0 ms// 值类型：Duration// 流批任务：流任务支持// 用处：此参数设置为多少就代表 MiniBatch 机制最大允许的延迟时间。注意这个参数要配合 `table.exec.mini-batch.enabled` 为 true 时使用，而且必须大于 0 mstable.exec.mini-batch.allow-latency: 0 ms// 默认值：-1// 值类型：Long// 流批任务：流任务支持// 用处：此参数设置为多少就代表 MiniBatch 机制最大缓冲记录数。注意这个参数要配合 `table.exec.mini-batch.enabled` 为 true 时使用，而且必须大于 0table.exec.mini-batch.size: -1// 默认值：-1// 值类型：Integer// 流批任务：流、批任务都支持// 用处：可以用此参数设置 Flink SQL 中算子的并行度，这个参数的优先级 `高于` StreamExecutionEnvironment 中设置的并行度优先级，如果这个值设置为 -1，则代表没有设置，会默认使用 StreamExecutionEnvironment 设置的并行度table.exec.resource.default-parallelism: -1// 默认值：ERROR// 值类型：Enum【ERROR, DROP】// 流批任务：流、批任务都支持// 用处：表上的 NOT NULL 列约束强制不能将 NULL 值插入表中。Flink 支持 `ERROR`（默认）和 `DROP` 配置。默认情况下，当 NULL 值写入 NOT NULL 列时，Flink 会产生运行时异常。用户可以将行为更改为 `DROP`，直接删除此类记录，而不会引发异常。table.exec.sink.not-null-enforcer: ERROR// 默认值：false// 值类型：Boolean// 流批任务：流任务// 用处：接入了 CDC 的数据源，上游 CDC 如果产生重复的数据，可以使用此参数在 Flink 数据源算子进行去重操作，去重会引入状态开销table.exec.source.cdc-events-duplicate: false// 默认值：0 ms// 值类型：Duration// 流批任务：流任务// 用处：如果此参数设置为 60 s，当 Source 算子在 60 s 内未收到任何元素时，这个 Source 将被标记为临时空闲，此时下游任务就不依赖此 Source 的 Watermark 来推进整体的 Watermark 了。// 默认值为 0 时，代表未启用检测源空闲。table.exec.source.idle-timeout: 0 ms// 默认值：0 ms// 值类型：Duration// 流批任务：流任务// 用处：指定空闲状态（即未更新的状态）将保留多长时间。尤其是在 unbounded 场景中很有用。默认 0 ms 为不清除空闲状态table.exec.state.ttl: 0 ms 其中上述参数中最常被用到为一下两种： ⭐ MiniBatch 聚合 123table.exec.mini-batch.enabled: truetable.exec.mini-batch.allow-latency: 60 stable.exec.mini-batch.size: 1000000000 具体使用场景如下链接： https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/tuning/#minibatch-aggregation ⭐ state ttl 状态过期 1234567-- 状态清除如下流 SQL 案例场景很有用，随着实时任务的运行，前几天（即前几天的 p_date）的 state 不会被更新的情况下，就可以使用空闲状态删除机制把 state 给删除select p_date , count(distinct user_id) as uvfrom source_tablegroup p_date 5.3.3.优化器参数Flink SQL 任务在生成执行计划时，优化生成更优的执行计划 12345678910111213141516171819202122232425262728293031323334353637383940414243// 默认值：AUTO// 值类型：String// 流批任务：流、批任务都支持// 用处：聚合阶段的策略。和 MapReduce 的 Combiner 功能类似，可以在数据 shuffle 前做一些提前的聚合，可以选择以下三种方式// TWO_PHASE：强制使用具有 localAggregate 和 globalAggregate 的两阶段聚合。请注意，如果聚合函数不支持优化为两个阶段，Flink 仍将使用单阶段聚合。// 两阶段优化在计算 count，sum 时很有用，但是在计算 count distinct 时需要注意，key 的稀疏程度，如果 key 不稀疏，那么很可能两阶段优化的效果会适得其反// ONE_PHASE：强制使用只有 CompleteGlobalAggregate 的一个阶段聚合。// AUTO：聚合阶段没有特殊的执行器。选择 TWO_PHASE 或者 ONE_PHASE 取决于优化器的成本。// // 注意！！！：此优化在窗口聚合中会自动生效，但是在 unbounded agg 中需要与 minibatch 参数相结合使用才会生效table.optimizer.agg-phase-strategy: AUTO// 默认值：false// 值类型：Boolean// 流批任务：流任务// 用处：避免 group by 计算 count distinct\\sum distinct 数据时的 group by 的 key 较少导致的数据倾斜，比如 group by 中一个 key 的 distinct 要去重 500w 数据，而另一个 key 只需要去重 3 个 key，那么就需要先需要按照 distinct 的 key 进行分桶。将此参数设置为 true 之后，下面的 table.optimizer.distinct-agg.split.bucket-num 可以用于决定分桶数是多少// 后文会介绍具体的案例table.optimizer.distinct-agg.split.enabled: false// 默认值：1024// 值类型：Integer// 流批任务：流任务// 用处：避免 group by 计算 count distinct 数据时的 group by 较少导致的数据倾斜。加了此参数之后，会先根据 group by key 结合 hash_code（distinct_key）进行分桶，然后再自动进行合桶。// 后文会介绍具体的案例table.optimizer.distinct-agg.split.bucket-num: 1024// 默认值：true// 值类型：Boolean// 流批任务：流任务// 用处：如果设置为 true，Flink 优化器将会尝试找出重复的自计划并重用。默认为 true 不需要改动table.optimizer.reuse-sub-plan-enabled: true// 默认值：true// 值类型：Boolean// 流批任务：流任务// 用处：如果设置为 true，Flink 优化器会找出重复使用的 table source 并且重用。默认为 true 不需要改动table.optimizer.reuse-source-enabled: true// 默认值：true// 值类型：Boolean// 流批任务：流任务// 用处：如果设置为 true，Flink 优化器将会做谓词下推到 FilterableTableSource 中，将一些过滤条件前置，提升性能。默认为 true 不需要改动table.optimizer.source.predicate-pushdown-enabled: true 其中上述参数中最常被用到为以下两种： ⭐ 两阶段优化： 1table.optimizer.agg-phase-strategy: AUTO 在计算 count(1)，sum(col) 场景汇总提效很高，因为 count(1)，sum(col) 在经过本地 localAggregate 之后，每个 group by 的 key 就一个结果值。 注意！！！：此优化在窗口聚合中会自动生效，但是在 unbounded agg 中需要与 minibatch 参数相结合使用才会生效。 ⭐ split 分桶： 12table.optimizer.distinct-agg.split.enabled: truetable.optimizer.distinct-agg.split.bucket-num: 1024 1234567891011121314151617181920INSERT INTO sink_tableSELECT count(distinct user_id) as uv, max(cast(server_timestamp as bigint)) as server_timestampFROM source_table-- 上述 SQL 打开了 split 分桶之后的效果等同于以下 SQLINSERT INTO sink_tableSELECT sum(bucket_uv) as uv , max(server_timestamp) as server_timestampFROM ( SELECT count(distinct user_id) as bucket_uv, max(cast(server_timestamp as bigint)) as server_timestamp FROM source_table group by mod(hash_code(user_id), 1024)) 注意！！！：如果有多个 distinct key，则多个 distinct key 都会被作为分桶 key。 5.3.4.表参数1234567891011121314151617181920212223242526272829// 默认值：false// 值类型：Boolean// 流批任务：流、批任务都支持// 用处：DML SQL（即执行 insert into 操作）是异步执行还是同步执行。默认为异步（false），即可以同时提交多个 DML SQL 作业，如果设置为 true，则为同步，第二个 DML 将会等待第一个 DML 操作执行结束之后再执行table.dml-sync: false// 默认值：64000// 值类型：Integer// 流批任务：流、批任务都支持// 用处：Flink SQL 会通过生产 java 代码来执行具体的 SQL 逻辑，但是 jvm 限制了一个 java 方法的最大长度不能超过 64KB，但是某些场景下 Flink SQL 生产的 java 代码会超过 64KB，这时 jvm 就会直接报错。因此此参数可以用于限制生产的 java 代码的长度来避免超过 64KB，从而避免 jvm 报错。table.generated-code.max-length: 64000// 默认值：default// 值类型：String// 流批任务：流、批任务都支持// 用处：在使用天级别的窗口时，通常会遇到时区问题。举个例子，Flink 开一天的窗口，默认是按照 UTC 零时区进行划分，那么在北京时区划分出来的一天的窗口是第一天的早上 8:00 到第二天的早上 8:00，但是实际场景中想要的效果是第一天的早上 0:00 到第二天的早上 0:00 点。因此可以将此参数设置为 GMT+08:00 来解决这个问题。table.local-time-zone: default// 默认值：default// 值类型：Enum【BLINK、OLD】// 流批任务：流、批任务都支持// 用处：Flink SQL planner，默认为 BLINK planner，也可以选择 old planner，但是推荐使用 BLINK plannertable.planner: BLINK// 默认值：default// 值类型：String// 流批任务：流、批任务都支持// 用处：Flink 解析一个 SQL 的解析器，目前有 Flink SQL 默认的解析器和 Hive SQL 解析器，其区别在于两种解析器支持的语法会有不同，比如 Hive SQL 解析器支持 between and、rlike 语法，Flink SQL 不支持table.sql-dialect: default todo hive dialect 5.4.SQL 性能调优本小节主要介绍 Flink SQL 中的聚合算子的优化，在某些场景下应用这些优化后，性能提升会非常大。本小节主要包含以下四种优化： ⭐ （常用）MiniBatch 聚合：unbounded group agg 中，可以使用 minibatch 聚合来做到微批计算、访问状态、输出结果，避免每来一条数据就计算、访问状态、输出一次结果，从而减少访问 state 的时长（尤其是 Rocksdb）提升性能。 ⭐ （常用）两阶段聚合：类似 MapReduce 中的 Combiner 的效果，可以先在 shuffle 数据之前先进行一次聚合，减少 shuffle 数据量 ⭐ （不常用）split 分桶：在 count distinct、sum distinct 的去重的场景中，如果出现数据倾斜，任务性能会非常差，所以如果先按照 distinct key 进行分桶，将数据打散到各个 TM 进行计算，然后将分桶的结果再进行聚合，性能就会提升很大 ⭐ （常用）去重 filter 子句：在 count distinct 中使用 filter 子句于 Hive SQL 中的 count(distinct if(xxx, user_id, null)) 子句，但是 state 中同一个 key 会按照 bit 位会进行复用，这对状态大小优化非常有用 上面简单介绍了聚合场景的四种优化，下面详细介绍一下其最终效果以及实现原理。 5.4.1.MiniBatch 聚合 ⭐ 问题场景：默认情况下，unbounded agg 算子是逐条处理输入的记录，其处理流程如下： ⭐ 从状态中读取 accumulator； ⭐ 累加/撤回的数据记录至 accumulator； ⭐ 将 accumulator 写回状态； ⭐ 下一条记录将再次从流程 1 开始处理。 但是上述处理流程的问题在于会增加 StateBackend 的访问性能开销（尤其是对于 RocksDB StateBackend）。 ⭐ MiniBatch 聚合如何解决上述问题：其核心思想是将一组输入的数据缓存在聚合算子内部的缓冲区中。当输入的数据被触发处理时，每个 key 只需要访问一次状态后端，这样可以大大减少访问状态的时间开销从而获得更好的吞吐量。但是，其会增加一些数据产出的延迟，因为它会缓冲一些数据再去处理。因此如果你要做这个优化，需要提前做一下吞吐量和延迟之间的权衡，但是大多数情况下，buffer 数据的延迟都是可以被接受的。所以非常建议在 unbounded agg 场景下使用这项优化。 下图说明了 MiniBatch 聚合如何减少状态访问的。 上图展示了加 MiniBatch 和没加 MiniBatch 之前的执行区别。 ⭐ 启用 MiniBatch 聚合的参数： 123456TableEnvironment tEnv = ...Configuration configuration = tEnv.getConfig().getConfiguration();configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;); // 启用 MiniBatch 聚合configuration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;); // buffer 最多 5s 的输入数据记录configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;); // buffer 最多的输入数据记录数目 注意！！！ ⭐ table.exec.mini-batch.allow-latency 和 table.exec.mini-batch.size 两者只要其中一项满足条件就会执行 batch 访问状态操作。 ⭐ 上述 MiniBatch 配置不会对 Window TVF 生效，因为！！！Window TVF 默认就会启用小批量优化，Window TVF 会将 buffer 的输入记录记录在托管内存中，而不是 JVM 堆中，因此 Window TVF 不会有 GC 过高或者 OOM 的问题。 5.4.2.两阶段聚合 ⭐ 问题场景：在聚合数据处理场景中，很可能会由于热点数据导致数据倾斜，如下 SQL 所示，当 color = RED 为 50000w 条，而 color = BLUE 为 5 条，就产生了数据倾斜，而器数据处理的算子产生性能瓶颈。 123SELECT color, sum(id)FROM TGROUP BY color ⭐ 两阶段聚合如何解决上述问题：其核心思想类似于 MapReduce 中的 Combiner + Reduce，先将聚合操作在本地做一次 local 聚合，这样 shuffle 到下游的数据就会变少。 还是上面的 SQL 案例，如果在 50000w 条的 color = RED 的数据 shuffle 之前，在本地将 color = RED 的数据聚合成为 1 条结果，那么 shuffle 给下游的数据量就被极大地减少了。 下图说明了两阶段聚合是如何处理热点数据的： ⭐ 启用两阶段聚合的参数： 1234567TableEnvironment tEnv = ...Configuration configuration = tEnv.getConfig().getConfiguration();configuration.setString(&quot;table.exec.mini-batch.enabled&quot;, &quot;true&quot;); // 打开 minibatchconfiguration.setString(&quot;table.exec.mini-batch.allow-latency&quot;, &quot;5 s&quot;);configuration.setString(&quot;table.exec.mini-batch.size&quot;, &quot;5000&quot;);configuration.setString(&quot;table.optimizer.agg-phase-strategy&quot;, &quot;TWO_PHASE&quot;); // 打开两阶段聚合 注意！！！ ⭐ 此优化在窗口聚合中会自动生效，大家在使用 Window TVF 时可以看到 localagg + globalagg 两部分 ⭐ 但是在 unbounded agg 中需要与 MiniBatch 参数相结合使用才会生效。 5.4.3.split 分桶 ⭐ 问题场景：使用两阶段聚合虽然能够很好的处理 count，sum 等常规聚合算子，但是在 count distinct，sum distinct 等算子的两阶段聚合效果在大多数场景下都不太满足预期。 因为 100w 条数据的 count 聚合能够在 local 算子聚合为 1 条数据，但是 count distinct 聚合 100w 条在 local 聚合之后的结果和可能是 90w 条，那么依然会有数据倾斜，如下 SQL 案例所示： 123SELECT color, COUNT(DISTINCT user_id)FROM TGROUP BY color ⭐ split 分桶如何解决上述问题：其核心思想在于按照 distinct 的 key，即 user_id，先做数据的分桶，将数据打散，分散到 Flink 的多个 TM 上进行计算，然后再将数据合桶计算。打开 split 分桶之后的效果就等同于以下 SQL： 1234567SELECT color, SUM(cnt)FROM ( SELECT color, COUNT(DISTINCT user_id) as cnt FROM T GROUP BY color, MOD(HASH_CODE(user_id), 1024))GROUP BY color 下图说明了 split 分桶的处理流程： ⭐ 启用 split 分桶的参数： 12345TableEnvironment tEnv = ...tEnv.getConfig() .getConfiguration() .setString(&quot;table.optimizer.distinct-agg.split.enabled&quot;, &quot;true&quot;); // 打开 split 分桶 注意！！！ ⭐ 如果有多个 distinct key，则多个 distinct key 都会被作为分桶 key。比如 count(distinct a)，sum(distinct b) 这种多个 distinct key 也支持。 ⭐ 小伙伴萌自己写的 UDAF 不支持！ ⭐ 其实此种优化很少使用，因为大家直接自己按照分桶的写法自己就可以写了，而且最后生成的算子图和自己写的 SQL 的语法也能对应的上 5.4.4.去重 filter 子句 ⭐ 问题场景：在一些场景下，用户可能需要从不同维度计算 UV，例如 Android 的 UV、iPhone 的 UV、Web 的 UV 和总 UV。许多用户会选择 CASE WHEN 支持此功能，如下 SQL 所示： 1234567SELECT day, COUNT(DISTINCT user_id) AS total_uv, COUNT(DISTINCT CASE WHEN flag IN (&#x27;android&#x27;, &#x27;iphone&#x27;) THEN user_id ELSE NULL END) AS app_uv, COUNT(DISTINCT CASE WHEN flag IN (&#x27;wap&#x27;, &#x27;other&#x27;) THEN user_id ELSE NULL END) AS web_uvFROM TGROUP BY day 但是如果你想实现类似的效果，Flink SQL 提供了更好性能的写法，就是本小节的 filter 子句。 ⭐ Filter 子句重写上述场景： 1234567SELECT day, COUNT(DISTINCT user_id) AS total_uv, COUNT(DISTINCT user_id) FILTER (WHERE flag IN (&#x27;android&#x27;, &#x27;iphone&#x27;)) AS app_uv, COUNT(DISTINCT user_id) FILTER (WHERE flag IN (&#x27;web&#x27;, &#x27;other&#x27;)) AS web_uvFROM TGROUP BY day Filter 子句的优化点在于，Flink 会识别出三个去重的 key 都是 user_id，因此会把三个去重的 key 存在一个共享的状态中。而不是上文 case when 中的三个状态中。其具体实现区别在于： ⭐ case when：total_uv、app_uv、web_uv 在去重时，state 是存在三个 MapState 中的，MapState key 为 user_id，value 为默认值，判断是否重复直接按照 key 是在 MapState 中的出现过进行判断。如果总 uv 为 1 亿，’android’, ‘iphone’ uv 为 5kw，’wap’, ‘other’ uv 为 5kw，则 3 个 state 要存储总共 2 亿条数据 ⭐ filter：total_uv、app_uv、web_uv 在去重时，state 是存在一个 MapState 中的，MapState key 为 user_id，value 为 long，其中 long 的第一个 bit 位标识在计算总 uv 时此 user_id 是否来光顾哦，第二个标识 ‘android’, ‘iphone’，第三个标识 ‘wap’, ‘other’，因此在上述 case when 相同的数据量的情况下，总共只需要存储 1 亿条数据，state 容量减小了几乎 50% 或者下面的场景也可以使用 filter 子句进行替换。 ⭐ 优化前： 12345678select day , app_typp , count(distinct user_id) as uvfrom source_tablegroup by day , app_type 如果能够确定 app_type 是可以枚举的，比如为 android、iphone、web 三种，则可以使用 filter 子句做性能优化： 12345678select day , count(distinct user_id) filter (where app_type = &#x27;android&#x27;) as android_uv , count(distinct user_id) filter (where app_type = &#x27;iphone&#x27;) as iphone_uv , count(distinct user_id) filter (where app_type = &#x27;web&#x27;) as web_uvfrom source_tablegroup by day 经过上述优化之后，state 大小的优化效果也会是成倍提升的。 5.5.SQL Connector 扩展 - 自定义 Source\\Sink5.5.1.自定义 Source\\Sinktodo 链接 5.5.2.自定义 Source\\Sink 的扩展接口Flink SQL 中除了自定义的 Source 的基础接口之外，还提供了一部分扩展接口用于性能的优化、能力扩展，接下来详细进行介绍。在 Source\\Sink 中主要包含了以下接口： ⭐ Source 算子的接口： ⭐ SupportsFilterPushDown：将过滤条件下推到 Source 中提前过滤，减少下游处理的数据量。案例可见 org.apache.flink.table.filesystem.FileSystemTableSource ⭐ SupportsLimitPushDown：将 limit 条目数下推到 Source 中提前限制处理的条目数。案例可见 org.apache.flink.table.filesystem.FileSystemTableSource ⭐ SupportsPartitionPushDown：（常用于批处理场景）将带有 Partition 属性的 Source，将所有的 Partition 数据获取到之后，然后在 Source 决定哪个 Source 读取哪些 Partition 的数据，而不必在 Source 后过滤。比如 Hive 表的 Partition，将所有 Partition 获取到之后，然后决定某个 Source 应该读取哪些 Partition，详细可见 org.apache.flink.table.filesystem.FileSystemTableSource。 ⭐ SupportsProjectionPushDown：将下游用到的字段下推到 Source 中，然后 Source 中只取这些字段，不使用的字段就不往下游发。案例可见 org.apache.flink.connector.jdbc.table.JdbcDynamicTableSource ⭐ SupportsReadingMetadata：支持读取 Source 的 metadata，比如在 Kafka Source 中读取 Kafka 的 offset，写入时间戳等数据。案例可见 org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicSource ⭐ SupportsWatermarkPushDown：支持将 Watermark 的分配方式下推到 Source 中，比如 Kafka Source 中一个 Source Task 可以读取多个 Partition，然后为每个 Partition 单独分配 Watermark Generator，这样 Watermark 的生成粒度就是单 Partition，在事件时间下数据计算会更加准确。案例可见 org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicSource ⭐ SupportsSourceWatermark：支持自定义的 Source Watermark 分配方式，比如目前已有的 Watermark 分配方式不满足需求，需要自定义 Source 的 Watermark 生成方式，则可以实现此接口 + 在 DDL 中声明 SOURCE_WATERMARK() 来声明使用自定义 Source 的 Watermark 生成方式。案例可见 org.apache.flink.table.planner.connectors.ExternalDynamicSource ⭐ Sink 算子的接口： ⭐ SupportsOverwrite：（常用于批处理场景）支持类似于 Hive SQL 的 insert overwrite table xxx 的能力，将已有分区内的数据进行覆盖。案例可见 org.apache.flink.connectors.hive.HiveTableSink ⭐ SupportsPartitioning：（常用于批处理场景）支持类似于 Hive SQL 的 insert INTO xxx partition(key = ‘A’) xxx 的能力，支持将结果数据写入某个静态分区。案例可见 org.apache.flink.connectors.hive.HiveTableSink ⭐ SupportsWritingMetadata：支持将 metadata 写入到 Sink 中，比如可以往 Kafka Sink 中写入 Kafka 的 timestamp、header 等。案例可见 org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicSink 5.5.3.Source：SupportsFilterPushDown ⭐ 应用场景：将 where 中的一些过滤条件下推到 Source 中进行处理，这样不需要的数据就可以不往下游发送了，性能会有提升。 ⭐ 优化前：如下图 web ui 算子图，过滤条件都在 Source 节点之后有单独的 filter 算子进行承接 ⭐ 优化方案及实现：在 DynamicTableSource 中实现 SupportsFilterPushDown 接口的方法，具体实现方案如下： 1234567891011121314151617public class Abilities_TableSource implements ScanTableSource , SupportsFilterPushDown // 过滤条件下推 &#123; private List&lt;ResolvedExpression&gt; filters; // 方法输入参数：List&lt;ResolvedExpression&gt; filters：引擎下推过来的过滤条件，然后在此方法中来决定哪些条件需要被下推 // 方法输出参数：Result：Result 记录哪些过滤条件在 Source 中应用，哪些条件不能在 Source 中应用 @Override public Result applyFilters(List&lt;ResolvedExpression&gt; filters) &#123; this.filters = new LinkedList&lt;&gt;(filters); // 1.不上推任何过滤条件 // Result.of(上推的 filter, 没有做上推的 filter)// return Result.of(Lists.newLinkedList(), filters); // 2.将所有的过滤条件都上推到 source return Result.of(filters, Lists.newLinkedList()); &#125;&#125; ⭐ 优化效果：如下图 web ui 算子图，过滤条件在 Source 节点执行 5.5.4.Source：SupportsLimitPushDown ⭐ 应用场景：将 limit 子句下推到 Source 中，在批场景中可以过滤大部分不需要的数据 ⭐ 优化前：如下图 web ui 算子图，limit 条件都在 Source 节点之后有单独的 Limit 算子进行承接 ⭐ 优化方案及实现：在 DynamicTableSource 中实现 SupportsLimitPushDown 接口的方法，具体实现方案如下： 123456789101112public class Abilities_TableSource implements ScanTableSource , SupportsLimitPushDown // limit 条件下推 &#123; private long limit = -1; @Override // 方法输入参数：long limit：引擎下推过来的 limit 条目数 public void applyLimit(long limit) &#123; // 将 limit 数接收到之后，然后在 SourceFunction 中可以进行过滤 this.limit = limit; &#125;&#125; ⭐ 优化效果：如下图 web ui 算子图，limit 条件在 Source 节点执行 5.5.5.Source：SupportsProjectionPushDown ⭐ 应用场景：将下游用到的字段下推到 Source 中，然后 Source 中可以做到只取这些字段，不使用的字段就不往下游发 ⭐ 优化前：如下图 web ui 算子图，limit 条件都在 Source 节点之后有单独的 Limit 算子进行承接 ⭐ 优化方案及实现：在 DynamicTableSource 中实现 SupportsProjectionPushDown 接口的方法，具体实现方案如下： 12345678910111213141516171819202122232425public class Abilities_TableSource implements ScanTableSource , SupportsProjectionPushDown // select 字段下推 &#123; private TableSchema tableSchema; @SneakyThrows @Override public ScanRuntimeProvider getScanRuntimeProvider(ScanContext runtimeProviderContext) &#123; // create runtime classes that are shipped to the cluster final DeserializationSchema&lt;RowData&gt; deserializer = decodingFormat.createRuntimeDecoder( runtimeProviderContext, getSchemaWithMetadata(this.tableSchema).toRowDataType()); ... &#125; @Override // 方法输入参数： // int[][] projectedFields：下游算子 `使用到的那些字段` 的下标，可以通过 projectSchemaWithMetadata 方法结合 table schema 信息生成 Source 新的需要写出 schema 信息 public void applyProjection(int[][] projectedFields) &#123; this.tableSchema = projectSchemaWithMetadata(this.tableSchema, projectedFields); &#125;&#125; ⭐ 优化效果：如下图 web ui 算子图，下游没有用到的字段直接在 Source 节点过滤掉，不输出 5.5.6.Source：SupportsReadingMetadata ⭐ 应用场景：支持读取 Source 的 metadata，比如在 Kafka Source 中读取 Kafka 的 offset，写入时间戳等数据 ⭐ 支持之前：比如想获取 Kafka 中的 offset 字段，在之前是不支持的 ⭐ 支持方案及实现：在 DynamicTableSource 中实现 SupportsReadingMetadata 接口的方法，我们来看看 Flink Kafka Consumer 的具体实现方案： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 注意！！！先执行 listReadableMetadata()，然后执行 applyReadableMetadata(xxx, xxx) 方法// 方法输出参数：列出 Kafka Source 可以从 Kafka 中读取的 metadata 数据@Overridepublic Map&lt;String, DataType&gt; listReadableMetadata() &#123; final Map&lt;String, DataType&gt; metadataMap = new LinkedHashMap&lt;&gt;(); // add value format metadata with prefix valueDecodingFormat .listReadableMetadata() .forEach((key, value) -&gt; metadataMap.put(VALUE_METADATA_PREFIX + key, value)); // add connector metadata Stream.of(ReadableMetadata.values()) .forEachOrdered(m -&gt; metadataMap.putIfAbsent(m.key, m.dataType)); return metadataMap;&#125;// 方法输入参数：// List&lt;String&gt; metadataKeys：用户 SQL 中写入到 Sink 表的的 metadata 字段名称（metadataKeys）// DataType producedDataType：将用户 SQL 写入到 Sink 表的所有字段的类型信息传进来，包括了 metadata 字段的类型信息@Overridepublic void applyReadableMetadata(List&lt;String&gt; metadataKeys, DataType producedDataType) &#123; final List&lt;String&gt; formatMetadataKeys = metadataKeys.stream() .filter(k -&gt; k.startsWith(VALUE_METADATA_PREFIX)) .collect(Collectors.toList()); final List&lt;String&gt; connectorMetadataKeys = new ArrayList&lt;&gt;(metadataKeys); connectorMetadataKeys.removeAll(formatMetadataKeys); final Map&lt;String, DataType&gt; formatMetadata = valueDecodingFormat.listReadableMetadata(); if (formatMetadata.size() &gt; 0) &#123; final List&lt;String&gt; requestedFormatMetadataKeys = formatMetadataKeys.stream() .map(k -&gt; k.substring(VALUE_METADATA_PREFIX.length())) .collect(Collectors.toList()); valueDecodingFormat.applyReadableMetadata(requestedFormatMetadataKeys); &#125; this.metadataKeys = connectorMetadataKeys; this.producedDataType = producedDataType;&#125; ⭐ 支持之后的效果： 123456789101112131415161718CREATE TABLE KafkaTable ( // METADATA 字段用于声明可以从 Source 读取的 metadata // 关于 Flink Kafka Source 可以读取的 metadata 见以下链接 // https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/connectors/table/kafka/#available-metadata `event_time` TIMESTAMP(3) METADATA FROM &#x27;timestamp&#x27;, `partition` BIGINT METADATA VIRTUAL, `offset` BIGINT METADATA VIRTUAL, `user_id` BIGINT, `item_id` BIGINT, `behavior` STRING) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;topic&#x27; = &#x27;user_behavior&#x27;, &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;, &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;, &#x27;scan.startup.mode&#x27; = &#x27;earliest-offset&#x27;, &#x27;format&#x27; = &#x27;csv&#x27;); 在后续的 DML SQL 语句中就可以正常使用这些 metadata 字段的数据了。 5.5.7.Source：SupportsWatermarkPushDowntodo 有问题 ⭐ 应用场景：支持将 Watermark 的分配方式下推到 Source 中，比如 Kafka Source 中一个 Source Task 可以读取多个 Partition，Watermark 分配器下推到 Source 算子中后，就可以为每个 Partition 单独分配 Watermark Generator，这样 Watermark 的生成粒度就是 Kafka 的单 Partition，在事件时间下数据乱序会更小。 ⭐ 支持之前：可以看到下图，Watermark 的分配是在 Source 节点之后的。 ⭐ 支持方案及实现：在 DynamicTableSource 中实现 SupportsWatermarkPushDown 接口的方法，我们来看看 Flink Kafka Consumer 的具体实现方案： 123456// 方法输入参数：// WatermarkStrategy&lt;RowData&gt; watermarkStrategy：将用户 DDL 中的 watermark 生成方式传入@Overridepublic void applyWatermark(WatermarkStrategy&lt;RowData&gt; watermarkStrategy) &#123; this.watermarkStrategy = watermarkStrategy;&#125; ⭐ 支持之后的效果： 5.5.8.Sink：SupportsOverwrite ⭐ 应用场景：（常用于批处理场景）支持类似于 Hive SQL 的 insert overwrite table xxx 的能力，将已有分区内的数据进行覆盖。 ⭐ 支持方案及实现：在 DynamicTableSink 中实现 SupportsOverwrite 接口的方法，我们来看看 HiveTableSink 的具体实现方案： 123456789101112131415161718192021222324252627private DataStreamSink&lt;Row&gt; createBatchSink( DataStream&lt;RowData&gt; dataStream, DataStructureConverter converter, StorageDescriptor sd, HiveWriterFactory recordWriterFactory, OutputFileConfig fileNaming, final int parallelism) throws IOException &#123;FileSystemOutputFormat.Builder&lt;Row&gt; builder = new FileSystemOutputFormat.Builder&lt;&gt;();...--- 2. 将 overwrite 字段设置到 FileSystemOutputFormat 中，在后续写入数据到 Hive 表时，如果 overwrite = true，则会覆盖直接覆盖已有数据builder.setOverwrite(overwrite);builder.setStaticPartitions(staticPartitionSpec);...return dataStream .map((MapFunction&lt;RowData, Row&gt;) value -&gt; (Row) converter.toExternal(value)) .writeUsingOutputFormat(builder.build()) .setParallelism(parallelism);&#125;// 1. 方法输入参数：// boolean overwrite：用户写的 SQL 中如果包含了 overwrite 关键字，则方法入参 overwrite = true// 如果不包含 overwrite 关键字，则方法入参 overwrite = false@Overridepublic void applyOverwrite(boolean overwrite) &#123; this.overwrite = overwrite;&#125; ⭐ 支持之后的效果： 支持在批任务中 insert overwrite xxx。 1234567insert overwrite hive_sink_tableselect user_id , order_amount , server_timestamp_bigint , server_timestamp from hive_source_table 5.5.9.Sink：SupportsPartitioning ⭐ 应用场景：（常用于批处理场景）支持类似于 Hive SQL 的 insert INTO xxx partition(key = ‘A’) 的能力，支持将结果数据写入某个静态分区。 ⭐ 支持方案及实现：在 DynamicTableSink 中实现 SupportsPartitioning 接口的方法，我们来看看 HiveTableSink 的具体实现方案： 12345678910111213141516171819202122232425262728293031323334private DataStreamSink&lt;Row&gt; createBatchSink( DataStream&lt;RowData&gt; dataStream, DataStructureConverter converter, StorageDescriptor sd, HiveWriterFactory recordWriterFactory, OutputFileConfig fileNaming, final int parallelism) throws IOException &#123;FileSystemOutputFormat.Builder&lt;Row&gt; builder = new FileSystemOutputFormat.Builder&lt;&gt;();...builder.setMetaStoreFactory(msFactory());builder.setOverwrite(overwrite);--- 2. 将 staticPartitionSpec 字段设置到 FileSystemOutputFormat 中，在后续写入数据到 Hive 表时，如果有静态分区，则会将数据写入到对应的静态分区中builder.setStaticPartitions(staticPartitionSpec);...return dataStream .map((MapFunction&lt;RowData, Row&gt;) value -&gt; (Row) converter.toExternal(value)) .writeUsingOutputFormat(builder.build()) .setParallelism(parallelism);&#125;// 1. 方法输入参数：// Map&lt;String, String&gt; partitionMap：用户写的 SQL 中如果包含了 partition(partition_key = &#x27;A&#x27;) 关键字// 则方法入参 Map&lt;String, String&gt; partitionMap 的输入值转为 JSON 后为：&#123;&quot;partition_key&quot;: &quot;A&quot;&#125;// 用户可以自己将方法入参的 partitionMap 保存到自定义变量中，后续写出到 Hive 表时进行使用@Overridepublic void applyStaticPartition(Map&lt;String, String&gt; partitionMap) &#123; staticPartitionSpec = new LinkedHashMap&lt;&gt;(); for (String partitionCol : getPartitionKeys()) &#123; if (partitionMap.containsKey(partitionCol)) &#123; staticPartitionSpec.put(partitionCol, partitionMap.get(partitionCol)); &#125; &#125;&#125; ⭐ 支持之后的效果： 1234567insert overwrite hive_sink_table partition(date = &#x27;2022-01-01&#x27;)select user_id , order_amount , server_timestamp_bigint , server_timestamp from hive_source_table 5.5.9.Sink：SupportsWritingMetadata ⭐ 应用场景：支持将 metadata 写入到 Sink 中。举例：可以往 Kafka Sink 中写入 Kafka 的 timestamp、header 等。案例可见 org.apache.flink.streaming.connectors.kafka.table.KafkaDynamicSink ⭐ 支持方案及实现：在 DynamicTableSink 中实现 SupportsWritingMetadata 接口的方法，我们来看看 KafkaDynamicSink 的具体实现方案： 1234567891011121314151617181920// 注意！！！先执行 listWritableMetadata()，然后执行 applyWritableMetadata(xxx, xxx) 方法// 1. 方法返回参数 Map&lt;String, DataType&gt;：Flink 会获取到可以写入到 Kafka Sink 中的 metadata 都有哪些@Overridepublic Map&lt;String, DataType&gt; listWritableMetadata() &#123; final Map&lt;String, DataType&gt; metadataMap = new LinkedHashMap&lt;&gt;(); Stream.of(WritableMetadata.values()) .forEachOrdered(m -&gt; metadataMap.put(m.key, m.dataType)); return metadataMap;&#125;// 2. 方法输入参数：// List&lt;String&gt; metadataKeys：通过解析用户的 SQL 语句，得出用户写出到 Sink 的 metadata 列信息，是 listWritableMetadata() 返回结果的子集// DataType consumedDataType：写出到 Sink 字段的 DataType 类型信息，包括了写出的 metadata 列的类型信息（注意！！！metadata 列会被添加到最后一列）。// 用户可以将这两个信息获取到，然后传入构造的 SinkFunction 中实现将对应字段写入 metadata 流程。@Overridepublic void applyWritableMetadata(List&lt;String&gt; metadataKeys, DataType consumedDataType) &#123; this.metadataKeys = metadataKeys; this.consumedDataType = consumedDataType;&#125; ⭐ 支持之后的效果： 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE KafkaSourceTable ( `user_id` BIGINT, `item_id` BIGINT, `behavior` STRING) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;topic&#x27; = &#x27;source_topic&#x27;, &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;, &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;, &#x27;scan.startup.mode&#x27; = &#x27;earliest-offset&#x27;, &#x27;value.format&#x27; = &#x27;json&#x27;);CREATE TABLE KafkaSinkTable ( -- 1. 定义 kafka 中 metadata 的 timestamp 列 `timestamp` TIMESTAMP_LTZ(3) METADATA, `user_id` BIGINT, `item_id` BIGINT, `behavior` STRING) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, &#x27;topic&#x27; = &#x27;sink_topic&#x27;, &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;, &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;, &#x27;scan.startup.mode&#x27; = &#x27;earliest-offset&#x27;, &#x27;value.format&#x27; = &#x27;json&#x27;);insert into KafkaSinkTableselect -- 2. 写入到 kafka 的 metadata 中的 timestamp cast(CURRENT_TIMESTAMP as TIMESTAMP_LTZ(3)) as `timestamp` , user_id , item_id , behaviorfrom KafkaSourceTable 5.6.SQL Format 扩展关于怎么实现一个自定义的 Format 可以参考一下文章。 todo format 链接","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十五）：改了改源码，实现了个 batch lookup join","date":"2021-11-15T07:26:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/16_flink sql 知其所以然（十五）：flink-sql-batch-lookup-join/","text":"看了那么多的技术文，你能明白作者想让你在读完文章后学到什么吗？ 大数据羊说的文章会让你明白 博主会阐明博主期望本文能给小伙伴们带来什么帮助，让小伙伴萌能直观明白博主的心思 博主会以实际的应用场景和案例入手，不只是知识点的简单堆砌 博主会把重要的知识点的原理进行剖析，让小伙伴萌做到深入浅出 1.序篇源码公众号后台回复1.13.2 sql batch lookup join获取。 TODO 上节 书接上回，上节说到了博主发现由于在 flink sql 中 lookup join 访问外部维表存在的性能问题。 由此诞生了一个想法，以 Redis 维表为例，Redis 支持 pipeline 批量访问模式，因此 flink sql lookup join 能不能按照 DataStream 方式一样，先攒一批数据，然后使用 Redis pipeline 批量访问外部存储。博主亲切的将这个功能称为 flink sql batch lookup join，本节就是讲述博主基于 flink 源码对此功能的实现。 废话不多说，咱们先直接上本文的目录和结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 直接来一个实战案例：博主以曝光用户日志流关联用户画像（年龄、性别）维表为例介绍 batch lookup join 具有的基本能力（怎么配置参数，怎么写 sql，最终效果咋样）。 batch lookup join：主要介绍 batch lookup join 的功能是从 flink transformation 出发，确定要 batch lookup join 涉及改动的地方以及其实现思路、原理。也会教给大家一些改动源码来实现自己想要的一些功能的思路。 总结及展望：目前的 batch lookup join 实现其实不符合 sql 的原始语义，后续大家可以按照 sql 标准自己做一些实现 2.来一个实战案例2.1.预期的输入、输出数据来看看在具体场景下，对应输入值的输出值应该长啥样。 需求指标：使用曝光用户日志流（show_log）关联用户画像维表（user_profile）关联到用户的画像（性别，年龄段）数据。 来一波输入数据： 曝光用户日志流（show_log）数据（数据存储在 kafka 中）： log_id timestamp user_id 1 2021-11-01 00:01:03 a 2 2021-11-01 00:03:00 b 3 2021-11-01 00:05:00 c 4 2021-11-01 00:06:00 b 5 2021-11-01 00:07:00 c 用户画像维表（user_profile）数据（数据存储在 redis 中）： user_id(主键) age sex a 12-18 男 b 18-24 女 c 18-24 男 注意：redis 中的数据结构存储是按照 key，value 去存储的。其中 key 为 user_id，value 为 age，sex 的 json。如下图所示： 预期输出数据如下： log_id timestamp user_id age sex 1 2021-11-01 00:01:03 a 12-18 男 2 2021-11-01 00:03:00 b 18-24 女 3 2021-11-01 00:05:00 c 18-24 男 4 2021-11-01 00:06:00 b 18-24 女 5 2021-11-01 00:07:00 c 18-24 男 2.2.batch lookup join sql 代码batch lookup join sql 代码和原来的 lookup join sql 代码一模一样。如下 sql。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CREATE TABLE show_log ( log_id BIGINT, `timestamp` as cast(CURRENT_TIMESTAMP as timestamp(3)), user_id STRING, proctime AS PROCTIME())WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.user_id.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE user_profile ( user_id STRING, age STRING, sex STRING ) WITH ( &#x27;connector&#x27; = &#x27;redis&#x27;, &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, &#x27;port&#x27; = &#x27;6379&#x27;, &#x27;format&#x27; = &#x27;json&#x27;, &#x27;lookup.cache.max-rows&#x27; = &#x27;500&#x27;, &#x27;lookup.cache.ttl&#x27; = &#x27;3600&#x27;, &#x27;lookup.max-retries&#x27; = &#x27;1&#x27;);CREATE TABLE sink_table ( log_id BIGINT, `timestamp` TIMESTAMP(3), user_id STRING, proctime TIMESTAMP(3), age STRING, sex STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- lookup join 的 query 逻辑INSERT INTO sink_tableSELECT s.log_id as log_id , s.`timestamp` as `timestamp` , s.user_id as user_id , s.proctime as proctime , u.sex as sex , u.age as ageFROM show_log AS sLEFT JOIN user_profile FOR SYSTEM_TIME AS OF s.proctime AS uON s.user_id = u.user_id 可以看到 lookup join 和 batch lookup join 的代码是完全相同的，唯一的不同之处在于，batch lookup join 需要设置 table config 参数，如下图所示： 2.2.batch lookup join 效果将原生 lookup join 和 batch lookup join 的效果做个对比： 原生的 lookup join：每输入一条数据，访问外部维表获取到结果输出一条数据，如下图所示。 博主实现的 batch lookup join：是每攒够 30 条数据或者每 5s（防止数据量少的情况下，长时间不输出数据） 就利用 redis pipeline 能力访问外部存储一次。然后批量输出结果，如下图所示。大大提高了吞吐。 3.batch lookup join 实现3.1.怎么知道应该改哪部分源码？博主将通过下面几个问题去交给大家怎么改源码去实现自己的功能。 改源码的有哪些比较好的思路？ 结论：首先就是参考类似模块的实现（不会写，但是我会抄啊！），比如本文要实现 batch lookup join，必然要参考原生的 lookup join 去实现。 大家在改 flink 源码时，因为 flink 源码的模块太多了，项目非常庞大，往往第一步碰到的问题不是怎么去实现这个功能，而是应该在什么地方去改才能实现！ 结论：一个 flink 的任务（DataStream\\Table\\SQL）所有的精华精华精华都集中在 transformation 中！！！只要是涉及到算子实现的东西，小伙伴萌就可以到 transformation 中去寻找。可以将断点打在每一个 operator 的构造器或者 open 方法中就可以看到其实在哪一步构造和初始化的。这样就能顺着调用栈往前回溯而确定要改哪部分代码了。 3.2.lookup join 原理3.2.1.transformation在实现 batch lookup join 之前，当然要从原生的 lookup join 的实现开始入手，看看 flink 官方大大是怎么实现的，具体 transformation 如下图所示： 具体的实现逻辑承载在 org.apache.flink.streaming.api.operators.ProcessOperator，org.apache.flink.table.runtime.operators.join.lookup.LookupJoinRunner 中。 3.2.2.LookupJoinRunnerLookupJoinRunner 中的数据处理逻辑集中在 processElement 中。 可以看到上图，LookupJoinRunner 又内嵌了一层 fetcher 来实现具体的 lookup 逻辑。 其中 fetcher：就是根据 flink sql lookup join 逻辑生成的 lookup join 的代码实例； 其中 collector：collector 的主要功能就是将原始数据 RowData 和 lookup 到的 RowData 的数据合并为 JoinedRowData 结果，然后输出。 接下来详细看看 fetcher 和 collector。 3.2.3.fetcher 把这个 fetcher 的代码 copy 出来瞅瞅。 fetcher 内嵌了 RedisRowDataLookupFunction 来作为最终访问外部维表的函数。 3.2.4.RedisRowDataLookupFunction访问 redis 获取到数据。 3.2.5.collector 把这个 collector 的代码 copy 出来瞅瞅。 3.3.lookup join 算子实现调用链是不是感觉一个 lookup join 的调用链贼复杂。 因为 batch lookup join 是完全参考 lookup join 去实现的，所以接下来博主介绍一下整体的调用链关系，这就会方便后续设计 batch lookup join 实现方案的时候去确定具体修改哪一部分代码。 整体的调用逻辑如下： ProcessOpeartor 把 原始 RowData 传给 LookupJoinRunner LookupJoinRunner 把 原始 RowData 传给根据 sql 代码生成的 fetcher fetcher 中把 原始 RowData 传给 RedisRowDataLookupFunction 然后去 lookup 维表，lookup 到的结果数据为 lookup RowData collector 把 原始 RowData 和 lookup RowData 数据合并为 JoinedRowData 然后输出。 3.4.batch lookup join 设计思路还是一样，先看看设计思路最终的结论，batch lookup join 算子调用链设计如下： 详细说明一下设计思路： 如果想做到批量访问外部存储（Redis）的数据。可以推断出 RedisRowDataLookupFunction 的输入需要是 List&lt;原始 RowData&gt; ，输出需要是 List&lt;lookup RowData&gt;。其中输入数据输入到 RedisRowDataLookupFunction 中后，使用 Redis pipeline 去批量访问外部存储，然后把结果 List&lt;lookup RowData&gt; 输出。 由 RedisRowDataLookupFunction 的输出数据为 List&lt;lookup RowData&gt; 推断出 collector 输入数据格式必然是 List&lt;原始 RowData&gt;。由于在 lookup join 中 collector 的逻辑就是将 原始 RowData 和 lookup RowData 合并为 JoinedRowData，将结果输出。因此 collector 这里就是将 List&lt;原始 RowData&gt; 和 List&lt;lookup RowData&gt; 进行遍历合并，一条一条的输出 JoinedRowData。 同样 RedisRowDataLookupFunction 的输入数据是 fetcher 传入的，则推断出 fetcher 输入数据格式必然是 List&lt;原始 RowData&gt;。 由于 fetcher 输入是 List&lt;原始 RowData&gt;，则 LookupJoinRunner 输出到 fetcher 的数据也需要是 List&lt;原始 RowData&gt;。但是 ProcessOpeartor 只能传给 LookupJoinRunner 原始 RowData，因此可以得出我们的每攒 30 条数据或者每隔 5s 的逻辑就能确定需要在 LookupJoinRunner 中做了。 思路有了，那么 batch lookup join 涉及到的改动项也就能确认了。 新建一个 BatchLookupJoinRunner：实现攒批逻辑（每攒 30 条数据或者每隔 5s），其中攒批的数据放在 ListState 中，以防止丢失，在 table config 中的 is.dim.batch.mode 设置为 true 时使用此 BatchLookupJoinRunner。 代码生成的 fetcher：将原来输入的 原始 RowData 改为 List&lt;原始 RowData&gt;。 新建一个 RedisRowDataBatchLookupFunction：实现将输入的批量数据 List&lt;原始 RowData&gt; 拿到之后使用 redis pipeline 批量访问外部存储，获取到 List&lt;lookup RowData&gt; 结果数据给 collector。 代码生成的 collector：将原来 lookup join 中的输入 原始 RowData，lookup RowData 改为 List&lt;原始 RowData&gt;，List&lt;lookup RowData&gt;，添加遍历循环 List&lt;原始 RowData&gt;，List&lt;lookup RowData&gt;，按顺序合并 List 中的每一项 原始 RowData，lookup RowData 输出 JoinedRowData 的逻辑。 3.5.batch lookup join 的最终效果3.5.1.transformation可以看到 is.dim.batch.mode 设置为 true 时，transformation 如下。transformation 中的重点处理逻辑就是 BatchLookupJoinRunner 3.5.2.BatchLookupJoinRunner 3.5.3.fetchersql 生成的 fetcher 代码如下： 3.5.4.RedisRowDataBatchLookupFunctionRedisRowDataBatchLookupFunction 拿到输入的 List 数据，调用 Redis pipeline 批量访问外部存储。 3.5.5.collectorsql 生成的 collector 代码如下： 3.6.待改进项目前上述方案实现的不足之处如下： batch 的执行逻辑与 sql 原始的语义不一致。因为从 sql 上看是完全没有这种 batch lookup join 的语义的。 其中每 5s博主简单实现了下，完全基于数据驱动的每 5s 攒一批，不是基于 onTimer 驱动的。可能会出现来了一条数据之后，5 min 内都没有来数据，则数据就不输出了。 没有考虑实现代码的抽象，以实现功能为主，所以很多基于源码的改动都是直接 copy 出来了另一个方法实现。 4.xdm 怎么使用这个功能？ git clone https://github.com/yangyichao-mango/flink/tree/release-1.13.2 在 clone 下来的项目的中，重新把下面两个模块 install (mvn clean install) 到本地仓库中。 然后在你的项目中引用两个 blink 包即可使用。使用方法就是只需要把 table config 的 is.dim.batch.mode 设置为 true，代码还按照 lookup join 的方式写即可。 4.总结与展望源码公众号后台回复1.13.2 sql batch lookup join获取。 本文主要介绍了 flink sql batch lookup join 的使用方式，并介绍了其实现思路以及效果，主要内容如下： 直接来一个实战案例：博主以曝光用户日志流关联用户画像（年龄、性别）维表为例介绍 batch lookup join 具有的基本能力（怎么配置参数，怎么写 sql，最终效果咋样）。 batch lookup join：主要介绍 batch lookup join 的功能是从 flink transformation 出发，确定要 batch lookup join 涉及改动的地方以及其实现思路、原理。也会教给大家一些改动源码来实现自己想要的一些功能的思路。 总结及展望：目前的 batch lookup join 实现其实不符合 sql 的原始语义，后续大家可以按照 sql 标准自己做一些实现","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十六）：flink sql 开发企业级利器之 Dlink","date":"2021-11-15T07:26:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/17_flink sql 知其所以然（十六）：flink-sql-开发利器之dlink/","text":"1.序篇博主这个系列都是讲 flink sql 相关的实践的。 讲到这个章节，其实挺多常用的 flink sql 语法及实战案例都已经讲了。 那么原理讲了，得在自己家公司把 flink sql 这等好东西用起来啊。 搞大数据开发的同学基本都知道在 HUE 上面写 hive sql 贼爽。那么有没有写 flink sql 的企业级的 web IDE 推荐的呢？ 经过博主调研之后，发现有两款非常优秀的利器： Apache Zeppelin Dlink 为啥先介绍 Dlink 呢？ 因为博主和其开发人员混的很熟了，所以就先拿 Dlink 来尝试尝试。 废话不多说，大家都想先看效果再看怎么部署。先看看最终效果。 2.Dlink 平台效果2.1.登录 登录账号和密码默认为 admin/admin。 2.2.flink sql 开发界面具体功能如下图所示： 注意： 预跑就是用于快速验证 sql 是否是正确的，可以快速以 standalone 模式跑出来一个结果。肥肠地好用。想看到预跑的结果，在 sql 中不能写 insert into xxx 这段。 可以看到是一个功能很齐全的 web IDE。 接下来我们看看怎么安装部署 Dlink 0.4.0。 3.安装部署篇3.1.Dlink 的 github源码直接去 github 上看，已经开源了，链接如下。 https://github.com/DataLinkDC/dlink 3.2.部署环境准备此部署示例是在 Mac OS 上进行，其他环境未测试。 环境 版本 备注 jdk 1.8.0_201 web 基础环境 mysql 8.0+ 存储 web IDE 作业，集群等信息 nginx 博主使用的是 1.21.1 web 前端访问 3.3.下载解压 Dlink 安装包博主是基于 Dlink 0.4.0 版本部署安装的。 第一步：下载 Dlink 0.4.0 安装包。 我们打开 Dlink 0.4.0 release Notes 看看，链接如下： https://github.com/DataLinkDC/dlink/releases/tag/0.4.0 打开上述 0.4.0 release Notes 链接后，点击下图中的 dlink-release-0.4.0.tar.gz 下载 Dlink 0.4.0 的安装包。 第二步：解压 Dlink 0.4.0 安装包看看。 解压后得到的 dlink-release-0.4.0 目录结构如下： 1234567891011121314config/ -- 配置文件|- application.ymllib/ -- 外部依赖及Connector|- dlink-client-1.13-0.4.0.jar|- dlink-connector-jdbc-1.13-0.4.0.jar|- dlink-function-0.4.0.jar|- dlink-metadata-clickhouse-0.4.0.jar|- dlink-metadata-mysql-0.4.0.jar|- dlink-metadata-oracle-0.4.0.jar|- dlink-metadata-postgresql-0.4.0.jarsql/|- dlink.sql -- Mysql初始化脚本auto.sh -- 启动停止脚本dlink-admin-0.4.0.jar -- 程序包 3.4.配置 Dlink MySQL既然是一个 web IDE，必然会存储一些 web 应用相关的信息。这些信息就是存储在 MySQL 中的。 第一步：创建 MySQL dlink 库。 使用 MySQL-cli 连接 MySQL 创建库。 1234&gt; mysql -u用户名 -p密码mysql&gt; create database dlink;mysql&gt; show databases; 第二步：使用 Dlink 的 sql 脚本（dlink 目录\\sql 目录\\dlink.sql）初始化 Dlink 数据库表信息，具体初始化命令行如下。 1234&gt; mysql -h localhost -u用户名 -p密码 -Ddlink &lt; dlink.sql&gt; mysql -u用户名 -p密码mysql&gt; use dlink;mysql&gt; show tables; 第三步：Dlink 也是个 web 项目，用的是 SpringBoot 那一套东西，所以连接 MySQL 得需要进行 Spring 相关的配置。 所以需要去 dlink 目录\\config 目录\\application.yml 中修改 MySQL 相关的配置。由于博主是在本地部署。所以涉及到改动的只有用户名和密码，改完之后保存。 3.5.启动 web 后端Dlink 是前后端分离的，刚刚我们配置了 MySQL 相关的环境，则可以直接启动后端了，后端占用的端口是 8888，启动命令如下。 1sh auto.sh start 在 Mac OS 下启动可能会遇到下面的问题： 这个错误的原因如下链接： https://jingyan.baidu.com/article/9f63fb91d014b8c8410f0e7a.html 解决方案如下： 直接把 auto.sh 在其他编辑器中重新复制出来一个 auto1.sh 启动就可以。 其他命令： 123456# 停止sh auto.sh stop# 重启sh auto.sh restart# 状态sh auto.sh status 运行日志： 控制台输出：项目根目录下的 dlink.log 文件。 日志归档输出：项目根目录下的 logs 目录下。 3.6.配置 web 前端前端都是一些静态文件，Dlink 使用 Nginx 作为访问前端静态文件的服务器。 第一步：Nginx 在 Mac OS 的安装，如下链接： https://www.jianshu.com/p/4f433d219ab7 第二步：在 nginx.conf 文件中配置 Dlink 的 server 信息。 本地安装的话，直接把下面这段 copy 到 nginx.conf 中对应的 server 配置下就行。 12345678910111213141516171819202122232425262728293031323334353637server &#123; listen 9999; server_name localhost; # gzip config gzip on; gzip_min_length 1k; gzip_comp_level 9; gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png; gzip_vary on; gzip_disable &quot;MSIE [1-6]\\.&quot;; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root html; index index.html index.htm; try_files $uri $uri&#x2F; &#x2F;index.html; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; location ^~ &#x2F;api &#123; proxy_pass http:&#x2F;&#x2F;127.0.0.1:8888; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; &#125;&#125; 第三步：注意，重点。一定要将 【dlink 目录\\html 目录\\所有文件】上传至 Nginx 的 [html 目录]下。不然访问 http://127.0.0.1:9999 啥都看不到。 第四步：reload Nginx 配置信息。 第五步：然后我们就可以 happy 的使用 Dlink 了。 4.总结及展望其他功能博主还在测试中。 引用 Dlink 官网的介绍，Dlink 将紧跟 Flink 官方社区发展，为推广及发展 Flink 的应用而奋斗，打造 FlinkSQL 的最佳搭档的形象。 5.Dlink 社区交流欢迎您加入社区交流分享与批评，也欢迎您为社区贡献自己的力量。 QQ社区群：543709668，申请备注 Dlink，不写不批。 微信社区群（推荐）：添加 wenmo_ai ，申请备注 Dlink，邀请进群。 公众号：DataLink数据中台","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十四）：维表 join 的性能优化之路（上）","date":"2021-11-15T06:26:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/15_flink sql 知其所以然（十四）：flink-sql-lookup-join/","text":"看了那么多的技术文，你能明白作者想让你在读完文章后学到什么吗？ 大数据羊说的文章会让你明白 博主会阐明博主期望本文能给小伙伴们带来什么帮助，让小伙伴萌能直观明白博主的心思 博主会以实际的应用场景和案例入手，不只是知识点的简单堆砌 博主会把重要的知识点的原理进行剖析，让小伙伴萌做到深入浅出 1.序篇源码公众号后台回复1.13.2 sql lookup join获取。 废话不多说，咱们先直接上本文的目录和结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 背景及应用场景介绍：博主期望你能了解到，flink sql 提供了轻松访问外部存储的 lookup join（与上节不同，上节说的是流与流的 join）。lookup join 可以简单理解为使用 flatmap 访问外部存储数据然后将维度字段拼接到当前这条数据上面 来一个实战案例：博主以曝光用户日志流关联用户画像（年龄、性别）维表为例介绍 lookup join 应该达到的关联的预期效果。 flink sql lookup join 的解决方案以及原理的介绍：主要介绍 lookup join 的在上述实战案例的 sql 写法，博主期望你能了解到，lookup join 是基于处理时间的，并且 lookup join 经常会由于访问外部存储的 qps 过高而导致背压，产出延迟等性能问题。我们可以借鉴在 DataStream api 中的维表 join 优化思路在 flink sql 使用 local cache，异步访问维表，批量访问维表三种方式去解决性能问题。 总结及展望：官方并没有提供 批量访问维表 的能力，因此博主自己实现了一套，具体使用方式和原理实现敬请期待下篇文章。 2.背景及应用场景介绍维表作为 sql 任务中一种常见表的类型，其本质就是关联表数据的额外数据属性，通常在 join 语句中进行使用。比如源数据有人的 id，你现在想要得到人的性别、年龄，那么可以通过用户 id 去关联人的性别、年龄，就可以得到更全的数据。 维表 join 在离线数仓中是最常见的一种数据处理方式了，在实时数仓的场景中，flink sql 目前也支持了维表的 join，即 lookup join，生产环境可以用 mysql，redis，hbase 来作为高速维表存储引擎。 Notes： 在实时数仓中，常用实时维表有两种更新频率 实时的更新：维度信息是实时新建的，实时写入到高速存储引擎中。然后其他实时任务在做处理时实时的关联这些维度信息。 周期性的更新：对于一些缓慢变化维度，比如年龄、性别的用户画像等，几万年都不变化一次的东西😂，实时维表的更新可以是小时级别，天级别的。 3.来一个实战案例来看看在具体场景下，对应输入值的输出值应该长啥样。 需求指标：使用曝光用户日志流（show_log）关联用户画像维表（user_profile）关联到用户的维度之后，提供给下游计算分性别，年龄段的曝光用户数使用。此处我们只关心关联维表这一部分的输入输出数据。 来一波输入数据： 曝光用户日志流（show_log）数据（数据存储在 kafka 中）： log_id timestamp user_id 1 2021-11-01 00:01:03 a 2 2021-11-01 00:03:00 b 3 2021-11-01 00:05:00 c 4 2021-11-01 00:06:00 b 5 2021-11-01 00:07:00 c 用户画像维表（user_profile）数据（数据存储在 redis 中）： user_id(主键) age sex a 12-18 男 b 18-24 女 c 18-24 男 注意：redis 中的数据结构存储是按照 key，value 去存储的。其中 key 为 user_id，value 为 age，sex 的 json。如下图所示： 预期输出数据如下： log_id timestamp user_id age sex 1 2021-11-01 00:01:03 a 12-18 男 2 2021-11-01 00:03:00 b 18-24 女 3 2021-11-01 00:05:00 c 18-24 男 4 2021-11-01 00:06:00 b 18-24 女 5 2021-11-01 00:07:00 c 18-24 男 flink sql lookup join 登场。下面是官网的链接。 https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/sql/queries/joins/#lookup-join 4.flink sql lookup join4.1.lookup join 定义以上述案例来说，lookup join 其实简单理解来，就是每来一条数据去 redis 里面搂一次数据。然后把关联到的维度数据给拼接到当前数据中。 熟悉 DataStream api 的小伙伴萌，简单来理解，就是 lookup join 的算子就是 DataStream api 中的 flatmap 算子中处理每一条来的数据，针对每一条数据去访问用户画像的 redis。（实际上，flink sql api 中也确实是这样实现的！sql 生成的 lookup join 代码就是继承了 flatmap） 4.2.上述案例解决方案来看看上述案例的 flink sql lookup join sql 怎么写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CREATE TABLE show_log ( log_id BIGINT, `timestamp` as cast(CURRENT_TIMESTAMP as timestamp(3)), user_id STRING, proctime AS PROCTIME())WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.user_id.length&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.log_id.max&#x27; = &#x27;10&#x27;);CREATE TABLE user_profile ( user_id STRING, age STRING, sex STRING ) WITH ( &#x27;connector&#x27; = &#x27;redis&#x27;, &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, &#x27;port&#x27; = &#x27;6379&#x27;, &#x27;format&#x27; = &#x27;json&#x27;, &#x27;lookup.cache.max-rows&#x27; = &#x27;500&#x27;, &#x27;lookup.cache.ttl&#x27; = &#x27;3600&#x27;, &#x27;lookup.max-retries&#x27; = &#x27;1&#x27;);CREATE TABLE sink_table ( log_id BIGINT, `timestamp` TIMESTAMP(3), user_id STRING, proctime TIMESTAMP(3), age STRING, sex STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);-- lookup join 的 query 逻辑INSERT INTO sink_tableSELECT s.log_id as log_id , s.`timestamp` as `timestamp` , s.user_id as user_id , s.proctime as proctime , u.sex as sex , u.age as ageFROM show_log AS sLEFT JOIN user_profile FOR SYSTEM_TIME AS OF s.proctime AS uON s.user_id = u.user_id 这里使用了 for SYSTEM_TIME as of 时态表的语法来作为维表关联的标识语法。 Notes： 实时的 lookup 维表关联能使用处理时间去做关联。 运行结果如下： log_id timestamp user_id age sex 1 2021-11-01 00:01:03 a 12-18 男 2 2021-11-01 00:03:00 b 18-24 女 3 2021-11-01 00:05:00 c 18-24 男 4 2021-11-01 00:06:00 b 18-24 女 5 2021-11-01 00:07:00 c 18-24 男 flink web ui 算子图如下： 但是！！！但是！！！但是！！！ flink 官方并没有提供 redis 的维表 connector 实现。 没错，博主自己实现了一套。关于 redis 维表的 connector 实现，直接参考下面的文章。都是可以从 github 上找到源码拿来用的！ TODO 4.3.关于维表使用的一些注意事项 同一条数据关联到的维度数据可能不同：实时数仓中常用的实时维表都是在不断的变化中的，当前流表数据关联完维表数据后，如果同一个 key 的维表的数据发生了变化，已关联到的维表的结果数据不会再同步更新。举个例子，维表中 user_id 为 1 的数据在 08：00 时 age 由 12-18 变为了 18-24，那么当我们的任务在 08：01 failover 之后从 07：59 开始回溯数据时，原本应该关联到 12-18 的数据会关联到 18-24 的 age 数据。这是有可能会影响数据质量的。所以小伙伴萌在评估你们的实时任务时要考虑到这一点。 会发生实时的新建及更新的维表博主建议小伙伴萌应该建立起数据延迟的监控机制，防止出现流表数据先于维表数据到达，导致关联不到维表数据 4.4.再说说维表常见的性能问题及优化思路所有的维表性能问题都可以总结为：高 qps 下访问维表存储引擎产生的任务背压，数据产出延迟问题。 举个例子： 在没有使用维表的情况下：一条数据从输入 flink 任务到输出 flink 任务的时延假如为 0.1 ms，那么并行度为 1 的任务的吞吐可以达到 1 query / 0.1 ms = 1w qps。 在使用维表之后：每条数据访问维表的外部存储的时长为 2 ms，那么一条数据从输入 flink 任务到输出 flink 任务的时延就会变成 2.1 ms，那么同样并行度为 1 的任务的吞吐只能达到 1 query / 2.1 ms = 476 qps。两者的吞吐量相差 21 倍。 这就是为什么维表 join 的算子会产生背压，任务产出会延迟。 那么当然，解决方案也是有很多的。抛开 flink sql 想一下，如果我们使用 DataStream api，甚至是在做一个后端应用，需要访问外部存储时，常用的优化方案有哪些？这里列举一下： 按照 redis 维表的 key 分桶 + local cache：通过按照 key 分桶的方式，让大多数据的维表关联的数据访问走之前访问过得 local cache 即可。这样就可以把访问外部存储 2.1 ms 处理一个 query 变为访问内存的 0.1 ms 处理一个 query 的时长。 异步访问外存：DataStream api 有异步算子，可以利用线程池去同时多次请求维表外部存储。这样就可以把 2.1 ms 处理 1 个 query 变为 2.1 ms 处理 10 个 query。吞吐可变优化到 10 / 2.1 ms = 4761 qps。 批量访问外存：除了异步访问之外，我们还可以批量访问外部存储。举一个例子：在访问 redis 维表的 1 query 占用 2.1 ms 时长中，其中可能有 2 ms 都是在网络请求上面的耗时，其中只有 0.1 ms 是 redis server 处理请求的时长。那么我们就可以使用 redis 提供的 pipeline 能力，在客户端（也就是 flink 任务 lookup join 算子中），攒一批数据，使用 pipeline 去同时访问 redis sever。这样就可以把 2.1 ms 处理 1 个 query 变为 7ms（2ms + 50 * 0.1ms） 处理 50 个 query。吞吐可变为 50 query / 7 ms = 7143 qps。博主这里测试了下使用 redis pipeline 和未使用的时长消耗对比。如下图所示。 博主认为上述优化效果中，最好用的是 1 + 3，2 相比 3 还是一条一条发请求，性能会差一些。 既然 DataStream 可以这样做，flink sql 必须必的也可以借鉴上面的这些优化方案。具体怎么操作呢？看下文骚操作 4.5.lookup join 的具体性能优化方案 按照 redis 维表的 key 分桶 + local cache：sql 中如果要做分桶，得先做 group by，但是如果做了 group by 的聚合，就只能在 udaf 中做访问 redis 处理，并且 udaf 产出的结果只能是一条，所以这种实现起来非常复杂。我们选择不做 keyby 分桶。但是我们可以直接使用 local cache 去做本地缓存，虽然【直接缓存】的效果比【先按照 key 分桶再做缓存】的效果差，但是也能一定程度上减少访问 redis 压力。在博主实现的 redis connector 中，内置了 local cache 的实现，小伙伴萌可以参考下面这部篇文章进行配置。TODO 异步访问外存：目前博主实现的 redis connector 不支持异步访问，但是官方实现的 hbase connector 支持这个功能，参考下面链接文章的，点开之后搜索 lookup.async。https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/connectors/table/hbase/ 批量访问外存：这玩意官方必然没有实现啊，但是，但是，但是，经过博主周末两天的疯狂 debug，改了改源码，搞定了基于 redis 的批量访问外存优化的功能。 4.6.基于 redis connector 的批量访问机制优化先描述一下大概是个什么东西，具体怎么用。 你只需要在 StreamTableEnvironment 中的 table config 配置上 is.dim.batch.mode 为 true，sql 不用做任何改动的情况下，flink lookup join 算子会自动优化，优化效果如下： lookup join 算子的每个 task 上，每攒够 30 条数据 or 每隔五秒（处理时间） 去触发一次批量访问 redis 的请求，使用的是 jedis client 的 pipeline 功能访问 redis server。实测性能有很大提升。 关于这个批量访问机制的优化介绍和使用方式介绍，小伙伴们先别急，下篇文章会详细介绍到。 5.总结与展望源码公众号后台回复1.13.2 sql lookup join获取。 本文主要介绍了 flink sql lookup join 的使用方式，并介绍了一些经常出现的性能问题以及优化思路，总结如下： 背景及应用场景介绍：博主期望你能了解到，flink sql 提供了轻松访问外部存储的 lookup join（与上节不同，上节说的是流与流的 join）。lookup join 可以简单理解为使用 flatmap 访问外部存储数据然后将维度字段拼接到当前这条数据上面 来一个实战案例：博主以曝光用户日志流关联用户画像（年龄、性别）维表为例介绍 lookup join 应该达到的关联的预期效果。 flink sql lookup join 的解决方案以及原理的介绍：主要介绍 lookup join 的在上述实战案例的 sql 写法，博主期望你能了解到，lookup join 是基于处理时间的，并且 lookup join 经常会由于访问外部存储的 qps 过高而导致背压，产出延迟等性能问题。我们可以借鉴在 DataStream api 中的维表 join 优化思路在 flink sql 使用 local cache，异步访问维表，批量访问维表三种方式去解决性能问题。 总结及展望：官方并没有提供 批量访问维表 的能力，因此博主自己实现了一套，具体使用方式和原理实现敬请期待下篇文章。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十二）：流 join 很难嘛？？？（上）","date":"2021-11-15T06:25:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/13_flink sql 知其所以然（十二）：flink-sql-join/","text":"想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇源码公众号后台回复1.13.2 sql join 的奇妙解析之路获取。 废话不多说，咱们先直接上本文的目录和结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 背景及应用场景介绍：博主期望你能了解到，flink sql 提供的丰富的 join 方式（总结 6 种：regular join，维表 join，快照 join，interval join，array 拍平，table function）对我们满足需求提供了强大的后盾，这 6 种 join 中涉及到流与流的 join 最常用的是 regular join 以及 interval join 来一个实战案例：博主以一个曝光日志流 left join 点击日志流为案例展开，介绍离线 hive sql left join 的解决方案及 flink sql left join 的解决方案，主要是想告诉小伙伴 flink sql 也有类似于 hive sql 的 regular join flink sql regular join 的解决方案以及存在问题的介绍：主要介绍 regular join 的在上述实战案例的运行结果及分析源码机制，博主期望你能了解到，left join，right join，full join 虽然写起来简单，但是会存在着 retract 的问题，所以在使用前，你应该充分了解其运行机制，避免出现写入 kafka 的数据发重，发多的问题 本文主要介绍 flink sql regular join retract 的问题，下节介绍怎么使用 interval join 来避免这种 retract 问题，并满足第 2 点的实战案例需求 2.背景及应用场景介绍在我们的日常场景中，应用最广的一种操作必然有 join 的一席之地，例如 计算曝光数据和点击数据的 CTR，需要通过唯一 id 进行 join 关联 事实数据关联维度数据获取维度，进而计算维度指标 上述场景，在离线数仓应用之广就不多说了。 那么，实时流之间的关联要怎么操作呢？ flink sql 为我们提供了六种强大的关联方式，帮助我们在流式场景中达到流关联的目的。如下图官网截图所示： （流 join）regular join：即 left join，right join，full join，inner join 维表 lookup join：维表关联 temporal join：快照表 join （流 join）interval join：两条流在一段时间区间之内的 join array 炸开：列转行，类似 hive lateral view explode table function join：通过 table function 自定义函数实现 join（类似于 hive lateral view explode，用户可以自定义这个 explode 函数） 在实时数仓中，设计到流与流 join 就是 regular join 以及 interval join。所以本文主要介绍这两种（太长的篇幅大家可能也不想看，所以之后的文章就以简洁，短为目标）。 3.来一个实战案例先来一个实际案例来看看在具体输入值的场景下，输出值应该长啥样。 场景：即常见的曝光日志流（show_log）通过 log_id 关联点击日志流（click_log），将数据的关联结果进行下发。 来一波输入数据： 曝光数据： log_id timestamp show_params 1 2021-11-01 00:01:03 show_params 2 2021-11-01 00:03:00 show_params2 3 2021-11-01 00:05:00 show_params3 点击数据： log_id timestamp click_params 1 2021-11-01 00:01:53 click_params 2 2021-11-01 00:02:01 click_params2 预期输出数据如下： log_id timestamp show_params click_params 1 2021-11-01 00:01:00 show_params click_params 2 2021-11-01 00:01:00 show_params2 click_params2 3 2021-11-01 00:02:00 show_params3 null 熟悉离线 hive sql 的同学可能 10s 就写完上面这个 sql 了，如下 12345678INSERT INTO sink_tableSELECT show_log.log_id as log_id, show_log.timestamp as timestamp, show_log.show_params as show_params, click_log.click_params as click_paramsFROM show_logLEFT JOIN click_log ON show_log.log_id = click_log.log_id; 那么我们看看上述需求如果要以 flink sql 实现需要怎么做呢？ 虽然 flink sql 提供了 left join 的能力，但是在实际使用时，可能会出现预期之外的问题。下节详述。 4.flink sql regular join4.1.flink sql还是上面的案例，我们先用 flink sql 实际跑一遍看看结果： 12345678INSERT INTO sink_tableSELECT show_log.log_id as log_id, show_log.timestamp as timestamp, show_log.show_params as show_params, click_log.click_params as click_paramsFROM show_logLEFT JOIN click_log ON show_log.log_id = click_log.log_id; flink web ui 算子图如下： 结果如下： 12345+[1 | 2021-11-01 00:01:03 | show_params | null]-[1 | 2021-11-01 00:01:03 | show_params | null]+[1 | 2021-11-01 00:01:03 | show_params | click_params]+[2 | 2021-11-01 00:03:00 | show_params | click_params]+[3 | 2021-11-01 00:05:00 | show_params | null] 从结果上看，其输出数据有 +，-，代表其输出的数据是一个 retract 流的数据。分析原因发现是，由于第一条 show_log 先于 click_log 到达，所以就先直接发出 +[1 | 2021-11-01 00:01:03 | show_params | null]，后面 click_log 到达之后，将上一次未关联到 click log 的 show_log 消息撤回，然后将关联到的 +[1 | 2021-11-01 00:01:03 | show_params | click_params] 下发。 但是 retract 流会导致写入到 kafka 的数据变多，这是我们不希望碰到的。我们期望的结果应该是一个 append 数据流。 那为什么 left join 会出现这种问题呢？就要从 left join 的原理说起了。 来定位到具体的实现源码。先看一下 transformations。 可以看到 left join 的具体 operator 是 org.apache.flink.table.runtime.operators.join.stream.StreamingJoinOperator。 其核心逻辑就集中在 processElement 方法上面。并且源码对于 processElement 的处理逻辑有详细的注释说明，如下图所示。 注释看起来逻辑比较难理解，是经过抽象的。我们这里按照 left join，inner join，right join，full join 分类给大家解释一下。 4.2.left join首先是 left join，以上面的 show_log（左表） left join click_log（右表） 为例： 首先如果 join xxx on 中的条件是等式则代表 join 是在相同 key 下进行的，join 的 key 即 show_log.log_id，click_log.log_id，相同 key 的数据会被发送到一个并发中进行处理。如果 join xxx on 中的条件是不等式，则两个流的 source 算子向 join 算子下发数据是按照 global 的 partition 策略进行下发的，并且 join 算子并发会被设置为 1，所有的数据会被发送到这一个并发中处理。 相同 key 下，当 show_log 来一条数据，如果 click_log 有数据：则 show_log 与 click_log 中的所有数据进行遍历关联一遍输出[+（show_log，click_log）]数据，并且把 show_log 保存到左表的状态中（以供后续 join 使用）。 相同 key 下，当 show_log 来一条数据，如果 click_log 中没有数据：则 show_log 不会等待，直接输出[+（show_log，null）]数据，并且把 show_log 保存到左表的状态中（以供后续 join 使用）。 相同 key 下，当 click_log 来一条数据，如果 show_log 有数据：则 click_log 对 show_log 中所有的数据进行遍历关联一遍。在输出数据前，会判断，如果被关联的这条 show_log 之前没有关联到过 click_log（即往下发过[+（show_log，null）]），则先发一条[-（show_log，null）]，后发一条[+（show_log，click_log）]，代表把之前的那条没有关联到 click_log 数据的 show_log 中间结果给撤回，把当前关联到的最新结果进行下发，并把 click_log 保存到右表的状态中（以供后续左表进行关联）。这也就解释了为什么输出流是一个 retract 流。 相同 key 下，当 click_log 来一条数据，如果 show_log 没有数据：把 click_log 保存到右表的状态中（以供后续左表进行关联）。 4.3.inner join以上面的 show_log（左表） left join click_log（右表） 为例： 首先如果 join xxx on 中的条件是等式则代表 join 是在相同 key 下进行的，join 的 key 即 show_log.log_id，click_log.log_id，相同 key 的数据会被发送到一个并发中进行处理。如果 join xxx on 中的条件是不等式，则两个流的 source 算子向 join 算子下发数据是按照 global 的 partition 策略进行下发的，并且 join 算子并发会被设置为 1，所有的数据会被发送到这一个并发中处理。 相同 key 下，当 show_log 来一条数据，如果 click_log 有数据：则 show_log 与 click_log 中的所有数据进行遍历关联一遍输出[+（show_log，click_log）]数据，并且把 show_log 保存到左表的状态中（以供后续 join 使用）。 相同 key 下，当 show_log 来一条数据，如果 click_log 中没有数据：则 show_log 不会输出数据，会把 show_log 保存到左表的状态中（以供后续 join 使用）。 相同 key 下，当 click_log 来一条数据，如果 show_log 有数据：则 click_log 与 show_log 中的所有数据进行遍历关联一遍输出[+（show_log，click_log）]数据，并且把 click_log 保存到右表的状态中（以供后续 join 使用）。 相同 key 下，当 click_log 来一条数据，如果 show_log 没有数据：则 click_log 不会输出数据，会把 click_log 保存到右表的状态中（以供后续 join 使用）。 4.4.right joinright join 和 left join 一样，只不过顺序反了，这里不再赘述。 4.5.full join以上面的 show_log（左表） left join click_log（右表） 为例： 首先如果 join xxx on 中的条件是等式则代表 join 是在相同 key 下进行的，join 的 key 即 show_log.log_id，click_log.log_id，相同 key 的数据会被发送到一个并发中进行处理。如果 join xxx on 中的条件是不等式，则两个流的 source 算子向 join 算子下发数据是按照 global 的 partition 策略进行下发的，并且 join 算子并发会被设置为 1，所有的数据会被发送到这一个并发中处理。 相同 key 下，当 show_log 来一条数据，如果 click_log 有数据：则 show_log 对 click_log 中所有的数据进行遍历关联一遍。在输出数据前，会判断，如果被关联的这条 click_log 之前没有关联到过 show_log（即往下发过[+（null，click_log）]），则先发一条[-（null，click_log）]，后发一条[+（show_log，click_log）]，代表把之前的那条没有关联到 show_log 数据的 click_log 中间结果给撤回，把当前关联到的最新结果进行下发，并把 show_log 保存到左表的状态中（以供后续 join 使用） 相同 key 下，当 show_log 来一条数据，如果 click_log 中没有数据：则 show_log 不会等待，直接输出[+（show_log，null）]数据，并且把 show_log 保存到左表的状态中（以供后续 join 使用）。 相同 key 下，当 click_log 来一条数据，如果 show_log 有数据：则 click_log 对 show_log 中所有的数据进行遍历关联一遍。在输出数据前，会判断，如果被关联的这条 show_log 之前没有关联到过 click_log（即往下发过[+（show_log，null）]），则先发一条[-（show_log，null）]，后发一条[+（show_log，click_log）]，代表把之前的那条没有关联到 click_log 数据的 show_log 中间结果给撤回，把当前关联到的最新结果进行下发，并把 click_log 保存到右表的状态中（以供后续 join 使用） 相同 key 下，当 click_log 来一条数据，如果 show_log 中没有数据：则 click_log 不会等待，直接输出[+（null，click_log）]数据，并且把 click_log 保存到右表的状态中（以供后续 join 使用）。 4.6.regular join 的总结总的来说上述四种 join 可以按照以下这么划分。 inner join 会互相等，直到有数据才下发。 left join，right join，full join 不会互相等，只要来了数据，会尝试关联，能关联到则发出的消息字段是全的，关联不到则另一边的字段为 null。后续数据来了之后，发现之前下发过的数据为没有关联到的数据时，就会做回撤，把关联到的结果进行下发 4.7.怎样才能解决 retract 导致数据重复下发到 kafka 这个问题呢？既然 flink sql 在 left join、right join、full join 实现上的原理就是以这种 retract 的方式去实现的，就不能通过这种方式来满足业务了。 我们来转变一下思路，上述 join 的特点就是不会相互等，那有没有一种 join 是可以相互等待的呢。以 left join 的思路为例，左表在关联不到右表的时候，可以选择等待一段时间，如果超过这段时间还等不到再下发 (show_log，null)，如果等到了就下发（show_log，click_log）。 interval join 闪亮登场。关于 interval join 是如何实现上述场景，及其原理实现，本篇的（下）会详细介绍，敬请期待。 5.总结与展望源码公众号后台回复1.13.2 sql join 的奇妙解析之路获取。 本文主要介绍了 flink sql regular 的在满足 join 场景时存在的问题，并通过解析其实现说明了运行原理，博主期望你读完本文之后能了解到： 背景及应用场景介绍：博主期望你能了解到，flink sql 提供的丰富的 join 方式（总结 6 种：regular join，维表 join，快照 join，interval join，array 拍平，table function）对我们满足需求提供了强大的后盾，这 6 种 join 中涉及到流与流的 join 最常用的是 regular join 以及 interval join 来一个实战案例：博主以一个曝光日志流 left join 点击日志流为案例展开，介绍离线 hive sql left join 的解决方案及 flink sql left join 的解决方案，主要是想告诉小伙伴 flink sql 也有类似于 hive sql 的 regular join flink sql regular join 的解决方案以及存在问题的介绍：主要介绍 regular join 的在上述实战案例的运行结果及分析源码机制，博主期望你能了解到，left join，right join，full join 虽然写起来简单，但是会存在着 retract 的问题，所以在使用前，你应该充分了解其运行机制，避免出现写入 kafka 的数据发重，发多的问题 本文主要介绍 flink sql regular join retract 的问题，下节介绍怎么使用 interval join 来避免这种 retract 问题，并满足第 2 点的实战案例需求","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十三）：流 join 很难嘛？？？（下）","date":"2021-11-15T06:25:59.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/14_flink sql 知其所以然（十三）：flink-sql-interval-join/","text":"看了那么多的技术文，你能明白作者想让你在读完文章后学到什么吗？ 大数据羊说的文章会让你明白 博主会阐明博主期望本文能给小伙伴们带来什么帮助，让小伙伴萌能直观明白博主的心思 博主会以实际的应用场景和案例入手，不只是知识点的简单堆砌 博主会把重要的知识点的原理进行剖析，让小伙伴萌做到深入浅出 1.序篇源码公众号后台回复1.13.2 sql interval join 的奇妙解析之路获取。 本节是 flink sql 流 join 系列的下篇，上篇的链接如下： 废话不多说，咱们先直接上本文的目录和结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 背景及应用场景介绍：博主期望你能了解到，flink sql 提供的丰富的 join 方式（总结 6 种：regular join，维表 join，快照 join，interval join，array 拍平，table function）对我们满足需求提供了强大的后盾，这 6 种 join 中涉及到流与流的 join 最常用的是 regular join 以及 interval join，本节主要介绍 interval join 来一个实战案例：博主以上节说到的曝光日志流点击日志流为案例展开，主要是想告诉小伙伴 flink sql left join 数据不会互相等待，存在 retract 问题，会导致写入 kafka 的数据量变大，然后转变思路为使用 flink sql interval join 的方式可以使得数据互相等待一段时间进行 join，这种方式不会存在 retract 问题 flink sql interval join 的解决方案以及原理的介绍：主要介绍 interval join 的在上述实战案例的运行结果及分析源码机制，博主期望你能了解到，interval join 的执行机制是会在你设置的 interval 区间之内互相等待一段时间，一旦时间推进（事件时间由 watermark 推进）到区间之外（即当前这条数据再也不可能被另一条流的数据 join 到时），outer join 会输出没有 join 到的数据，inner join 会从 state 中删除这条数据 总结及展望 2.背景及应用场景介绍书接上文，上文介绍了曝光流在关联点击流时，使用 flink sql regular join 存在的 retract 问题。 本文介绍怎么使用 flink sql interval join 解决这些问题。 3.来一个实战案例看看上节的实际案例，来看看在具体输入值的场景下，输出值应该长啥样。 场景：即常见的曝光日志流（show_log）通过 log_id 关联点击日志流（click_log），将数据的关联结果进行下发。 来一波输入数据： 曝光数据： log_id timestamp show_params 1 2021-11-01 00:01:03 show_params 2 2021-11-01 00:03:00 show_params2 3 2021-11-01 00:05:00 show_params3 点击数据： log_id timestamp click_params 1 2021-11-01 00:01:53 click_params 2 2021-11-01 00:02:01 click_params2 预期输出数据如下： log_id timestamp show_params click_params 1 2021-11-01 00:01:00 show_params click_params 2 2021-11-01 00:01:00 show_params2 click_params2 3 2021-11-01 00:02:00 show_params3 null 上节的 flink sql regular join 解决方案如下： 12345678INSERT INTO sink_tableSELECT show_log.log_id as log_id, show_log.timestamp as timestamp, show_log.show_params as show_params, click_log.click_params as click_paramsFROM show_logLEFT JOIN click_log ON show_log.log_id = click_log.log_id; 上节说道，flink sql left join 在流数据到达时，如果左表流（show_log）join 不到右表流（click_log），则不会等待右流直接输出（show_log，null），在后续右表流数据代打时，会将（show_log，null）撤回，发送（show_log，click_log）。这就是为什么产生了 retract 流，从而导致重复写入 kafka。 对此，我们也是提出了对应的解决思路，既然 left join 中左流不会等待右流，那么能不能让左流强行等待右流一段时间，实在等不到在数据关联不到的数据即可。 当当当！！！ 本文的 flink sql interval join 登场，它就能等。 4.flink sql interval join4.1.interval join 定义大家先通过下面这句话和图简单了解一下 interval join 的作用（熟悉 DataStream 的小伙伴萌可能已经使用过了），后续会详细介绍原理。 interval join 就是用一个流的数据去关联另一个流的一段时间区间内的数据。关联到就下发关联到的数据，关联不到且在超时后就根据是否是 outer join（left join，right join，full join）下发没关联到的数据。 4.2.案例解决方案来看看上述案例的 flink sql interval join sql 怎么写： 12345678910INSERT INTO sink_tableSELECT show_log.log_id as log_id, show_log.timestamp as timestamp, show_log.show_params as show_params, click_log.click_params as click_paramsFROM show_log LEFT JOIN click_log ON show_log.log_id = click_log.log_idAND show_log.row_time BETWEEN click_log.row_time - INTERVAL &#x27;10&#x27; MINUTE AND click_log.row_time + INTERVAL &#x27;10&#x27; MINUTE; 这里设置了 show_log.row_time BETWEEN click_log.row_time - INTERVAL &#39;10&#39; MINUTE AND click_log.row_time + INTERVAL &#39;10&#39; MINUTE代表 show_log 表中的数据会和 click_log 表中的 row_time 在前后 10 分钟之内的数据进行关联。 运行结果如下： 123+[1 | 2021-11-01 00:01:03 | show_params | click_params]+[2 | 2021-11-01 00:03:00 | show_params | click_params]+[3 | 2021-11-01 00:05:00 | show_params | null] 如上就是我们期望的正确结果了。 flink web ui 算子图如下： 那么此时你可能有一个问题，结果中的前两条数据 join 到了输出我是理解的，那当 show_log join 不到 click_log 时为啥也输出了？原理是啥？ 博主带你们来定位到具体的实现源码。先看一下 transformations。 可以看到事件时间下 interval join 的具体 operator 是 org.apache.flink.table.runtime.operators.join.KeyedCoProcessOperatorWithWatermarkDelay。 其核心逻辑就集中在 processElement1 和 processElement2 中，在 processElement1 和 processElement2 中使用 org.apache.flink.table.runtime.operators.join.interval.RowTimeIntervalJoin 来处理具体 join 逻辑。RowTimeIntervalJoin 重要方法如下图所示。 下面详细给大家解释一下。 4.3.TimeIntervalJoin 简版说明join 时，左流和右流会在 interval 时间之内相互等待，如果等到了则输出数据[+（show_log，click_log）]，如果等不到，并且另一条流的时间已经推进到当前这条数据在也不可能 join 到另一条流的数据时，则直接输出[+（show_log，null）]，[+（null，click_log）]。 举个例子，show_log.row_time BETWEEN click_log.row_time - INTERVAL &#39;10&#39; MINUTE AND click_log.row_time + INTERVAL &#39;10&#39; MINUTE，当 click_log 的时间推进到 2021-11-01 11:00:00 时，这时 show_log 来一条 2021-11-01 02:00:00 的数据，那这条 show_log 必然不可能和 click_log 中的数据 join 到了，因为 click_log 中 2021-11-01 01:50:00 到 2021-11-01 02:10:00 之间的数据以及过期删除了。则 show_log 直接输出 [+（show_log，null）] Notes：如果你设置了 allowLateness，join 不到的数据的输出和 state 的清理会多保留 allowLateness 时间 4.4.TimeIntervalJoin 详细实现说明以上面案例的 show_log（左表） interval join click_log（右表） 为例（不管是 inner interval join，left interval join，right interval join 还是 full interval join，都会按照下面的流程执行）： 第一步，首先如果 join xxx on 中的条件是等式则代表 join 是在相同 key 下进行的（上述案例中 join 的 key 即 show_log.log_id，click_log.log_id），相同 key 的数据会被发送到一个并发中进行处理。如果 join xxx on 中的条件是不等式，则两个流的 source 算子向 join 算子下发数据是按照 global 的 partition 策略进行下发的，并且 join 算子并发会被设置为 1，所有的数据会被发送到这一个并发中处理。 第二步，相同 key 下，一条 show_log 的数据先到达，首先会计算出下面要使用的最重要的三类时间戳： 根据 show_log 的时间戳（l_time）计算出能关联到的右流的时间区间下限（r_lower）、上限（r_upper） 根据 show_log 目前的 watermark 计算出目前右流的数据能够过期做过期处理的时间的最小值（r_expire） 获取左流的 l_watermark，右流的 r_watermark，这两个时间戳在事件语义的任务中都是 watermark 第三步，遍历所有同 key 下的 click_log 来做 join 对于遍历的每一条 click_log，走如下步骤 经过判断，如果 on 中的条件为 true，则和 click_log 关联，输出[+（show_log，click_log）]数据；如果 on 中的条件为 false，则啥也不干 接着判断当前这条 click_log 的数据时间（r_time）是否小于右流的数据过期时间的最小值（r_expire）（即判断这条 click_log 是否永远不会再被 show_log join 到了）。如果小于，并且当前 click_log 这一侧是 outer join，则不用等直接输出[+（null，click_log）]），从状态删除这条 click_log；如果 click_log 这一侧不是 outer join，则直接从状态里删除这条 click_log。 第四步，判断右流的时间戳（r_watermark）是否小于能关联到的右流的时间区间上限（r_upper）： 如果是，则说明这条 show_log 还有可能被 click_log join 到，则 show_log 放到 state 中，并注册后面用于状态清除的 timer。 如果否，则说明关联不到了，则输出[+（show_log，null）] 第五步，timer 触发时： timer 触发时，根据当前 l_watermark，r_watermark 以及 state 中存储的 show_log，click_log 的 l_time，r_time 判断是否再也不会被对方 join 到，如果是，则根据是否为 outer join 对应输出[+（show_log，null）]，[+（null，click_log）]，并从状态中删除对应的 show_log，click_log。 上面只是左流 show_log 数据到达时的执行流程（即 ProcessElement1），当右流 click_log 到达时也是完全类似的执行流程（即 ProcessElement2）。 4.5.使用注意事项小伙伴萌在使用 interval join 需要注意的两点事项： interval join 的时间区间取决于日志的真实情况：设置大了容易造成任务的 state 太大，并且时效性也会变差。设置小了，join 不到，下发的数据在后续使用时，数据质量会存在问题。所以小伙伴萌在使用时建议先使用离线数据做一遍两条流的时间戳 diff 比较，来确定真实情况下的时间戳 diff 的分布是怎样的。举例：你通过离线数据 join 并做时间戳 diff 后发现 99% 的数据都能在时间戳相差 5min 以内 join 到，那么你就有依据去设置 interval 时间差为 5min。 interval join 中的时间区间条件即支持事件时间，也支持处理时间。事件时间由 watermark 推进。 5.总结与展望源码公众号后台回复1.13.2 sql interval join 的奇妙解析之路获取。 本文主要介绍了 flink sql interval 是怎么避免出现 flink regular join 存在的 retract 问题的，并通过解析其实现说明了运行原理，博主期望你读完本文之后能了解到： 背景及应用场景介绍：博主期望你能了解到，flink sql 提供的丰富的 join 方式（总结 6 种：regular join，维表 join，快照 join，interval join，array 拍平，table function）对我们满足需求提供了强大的后盾，这 6 种 join 中涉及到流与流的 join 最常用的是 regular join 以及 interval join，本节主要介绍 interval join 来一个实战案例：博主以上节说到的曝光日志流点击日志流为案例展开，主要是想告诉小伙伴 flink sql left join 数据不会互相等待，存在 retract 问题，会导致写入 kafka 的数据量变大，然后转变思路为使用 flink sql interval join 的方式可以使得数据互相等待一段时间进行 join，这种方式不会存在 retract 问题 flink sql interval join 的解决方案以及原理的介绍：主要介绍 interval join 的在上述实战案例的运行结果及分析源码机制，博主期望你能了解到，interval join 的执行机制是会在你设置的 interval 区间之内互相等待一段时间，一旦时间推进（事件时间由 watermark 推进）到区间之外（即当前这条数据再也不可能被另一条流的数据 join 到时），outer join 会输出没有 join 到的数据，inner join 会从 state 中删除这条数据 总结及展望","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"当我们在做流批一体时，我们在做什么？","date":"2021-11-15T06:25:58.000Z","path":"2021/11/15/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/11_流批一体的简单思考/","text":"1.前言本文主要是分享目前博主理解的流批一体产生的背景，想解决的问题，以及后续可能实现的思路，并以几个案例进行介绍。抛砖引玉，让大家不止停留在做流批一体这件事，而是能更深入思考背后的原因。 2.背景在介绍流批一体之前，首先看看目前流和批领域常用的引擎： 批任务：常用 Hive、Spark 流任务：常用 Flink 3.什么问题导致产生了流批一体的概念呢？ 一个前提：在生产场景中：即同一个口径的指标分别用流任务产出了实时数据，用批任务产出了离线数据，才会去考虑是否需要做流批一体。如果一个指标只需要产出离线，何谈流批一体呢？ 一个角度：流批一体应该站在流的角度思考，去将流任务产出的结果在批领域（或者以批数据的形式）进行复用，而不仅仅是在引擎侧面，API 接口层面的统一 解决的问题：在上述前提和思考角度的基础上，博主认为，流批一体目前需要解决的最重要的就是数据质量问题（与阿里在 FFA 2020 上分享的流批一体要解决的数据质量问题一样），用过 Flink 做实时数据开发的同学应该都碰到过 Flink 产出数据的时候，总会由于一些异常（比如使用了窗口可能会导致丢数）导致和离线 Hive、Spark 产出的数据有一些微小的差别，这样就没法做到实时数据在离线领域的复用。博主理解，流批一体的重点就是要解决这个问题，其他的在资源节约、人效提高方面的优势都是基于此的附加价值。 Notes:有同学可能就要问了，为什么说资源节约、人效提高只是附加价值呢？举一个例子，如果我们能保证产出的实时数据和离线数据是完全一致的，将实时数据进行复用，那我们那我们就不需要离线数据了！这样离线的资源就被节约了 4.那么导致流任务产生数据质量问题的原因是什么，有哪些常见场景？博主认为，目前最重要的一个原因就是数据乱序导致的数据质量问题。 在实时领域最常用和常见的场景有以下两种： 第一种是 Flink 任务开窗口的场景。举例，一个开了 TUMBLE WINDOW 的 Flink 任务，遇到严重的数据乱序的情况（用户配置的最大乱序、允许延迟等参数都解决不了），那么任务就会把数据给丢掉，这种场景下就会导致实时数据与离线数据产生差异。 第二种是实时维表关联的场景。如果事实表的数据先到，就有关联不到维表中的数据。从而产生与离线的差异。 5.想要解决上述数据质量问题，可行的思路有哪些？ 理想化的思路：以 TUMBLE WINDOW 为例， TUMBLE WINDOW 的初衷就是为了产出不变的结果（即 append 流），因此遇到延迟很大的数据才无法处理，那么我们可以将 TUMBLE WINDOW 使用 GROUP AGG（retract 流、或者叫做 CDC 模式）替换去计算。当有迟到的数据时，GROUP AGG 会正常的处理及将上次的结果给撤回，将重新计算的新结果下发下去。但是这有问题在于如果我们想用 CDC 的模式去运行任务，我们需要全链路都是以 CDC 的模式去运行，包括计算引擎、消息队列、OLAP 引擎等。（CDC 是不是想到了数据湖？）。再以一个分钟\\小时累计指标举例，我们看看阿里在 FFA 2020 上的分享是怎么做的。可以看到实际阿里就是使用 GROUP AGG 做的计算。但是对于后续的链路不知道是否是使用 CDC 的方式运行的。 阿里 FFA 2020：如下图阿里做的所示，第一种情况是如果流批一体输入源不同，需要批任务调度订正结果，第二种情况是如果流批结果相同，就不跑批任务了。第一种情况没有啥可说的；但是如果是第二种情况，验证流批结果相同的前提是，跑了批任务产出了结果主动去和流任务的结果去做对比，但是实际是批任务并没有调度！！！所以这就需要做很多的监控来保障流任务产出的整体流程没有问题，保障能达到和预期批任务产出的结果相同。 上述的第一种思路相对比较理想化，基本是站在流任务产出的数据可以以批的模式进行复用角度去思考的。基本撇开了批任务执行这一个过程。第二种阿里 FFA 2020 的思路相比来说对于链路软硬件条件没那么高，博主认为是更具可行性的。 6.总结本文主要介绍了以下三部分内容： 流批一体的诞生是为了解决同一个指标在离线、实时任务产出数据差异问题（数据质量） 导致数据差异的根本原因就是数据乱序 如果想解决这个问题，理想化就是全链路 CDC，更具操作行可以参考阿里 FFA 2020","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"晋升答辩","date":"2021-11-13T06:25:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/05_数据团队建设/03_个人/gogogo/","text":"1.前言准备答辩内容及材料是一个非常耗时耗力的过程，因此有一些方法的沉淀的话，后续对自己以及帮你 review 材料的人都会更轻松一些。 2.本质晋升永远是有了下一个职级的能力才会有晋升机会。如果你只是做好了你这个职级的事情，没有跨越职级的能力。同样是没有晋升机会的。 3.平常怎么要求自己在平常工作生活中，按照下一个职级（一般公司内部都会有透明的职级能力模型）的要求做事情。明确业务需要达到什么地步？技术需要达到什么地步？ 4.怎么准备答辩材料4.1.准备材料前你需要知道的事情 确认下一个职级的要求：审视一下自己在这些要求上面是否已经达到，或者在什么项目上体现出了这些能力，这些项目将成为之后做 PPT 的素材。 站在评委的角度上去思考答辩 PPT 的内容：所以需要明确评委都是谁，是否和你做的是一个领域的东西，涉及到后续做 PPT 或者准备答辩内容时，其中涉及到的概念是否需要稍微展开举例。举一个例子，比如说想体现出实时计算中的状态，管理是非常复杂的，但是如果评委是做离线数据的话，他们其实是对状态处理没有什么概念的，所以你这里就得考虑多解释一下状态管理为什么复杂，状态管理为什么难。如果你的评委本身就是做实时计算的话，那么这里你就可以简单的介绍一下即可，不用解释的那么复杂。 晋升答辩不是技术分享：准备的内容要能给评委讲明白讲懂，明确这是一场晋升答辩，不是硬核的技术分享（硬核技术分享一般都是针对于某一个点体现深度），也不是给别人上课，因此晋升答辩内容既不能太难，也不能太简单。 评委关心的是你解决问题的能力：评委关心的是解决问题的能力有没有达到下一个职级，因此答辩的内容是要重点突出做项目的过程，包括你的分析过程，剖析难点问题的过程，解决难点问题的过程，而不是简单的介绍一下这个项目最终的结果，结果只是一个点缀，不是重点。 所有的工作都需要有价值，有目标：所有的在答辩过程中描述的工作都需要有价值，有目标。以一种碰到问题 → 解决问题的思路去说，而不是凭空就出现了问题的解决方法。 挑重点说：时间很宝贵，不可能将所有的问题及解决方案都说完，要调能突出能力的重点说。信息量不能爆炸，本身评委可能就不太了解你这部分内容，如果你还说了非常多的东西，评委的接受度会急剧降低。 成果量化：体现出你做的好的一个最简单的方式就是将成果进行量化，比如对什么东西进行了优化，那么优化的效果就要体现出来，比如有了一倍的性能提升。 注意体现工作大小的方式：负责的东西尽量以模块的方式体现出来，不然如果说的太小的话，评委会认为做的没有什么技术含量，或者没有什么价值。 不要超越当前职级太多去说事情：需要站在当前的职级以及下一个职级的角度上去说事情，不建议说超出自己职责能力范围太多的事情，比如说，如果是应届生晋升，如果在整个过程中去说指导组内其他老人做了什么事情，评委就会觉得你可能是不是把自己拔的太高了，也会认为你们的团队管理是不是有问题，怎么能让一个新手去教一个老手。 PPT 慎用标红加粗：做 PPT 时，有时会回去把一些自己认为重要的字体进行家族标红，但是一定要想清楚标红的逻辑，你要说出来为什么标红加粗，不然评委会懵逼。 PPT 上的内容要简单易理解：不要写一句你自己都看不懂的话在上面 PPT 尽量写短语：用短语引申 划清和他人工作的界限：如果涉及到和他人一起合作，需要说明、划分清楚界限，让评委知道你在项目中干了什么。不可能所有的工作都是一个人完成的。 PPT 尽量在同一页中体现问题以及对应的解法：如果在两页会有割裂感。如果一页写不下，那么在下一页也要将问题体现出来。 4.2.答辩材料应该包含的内容以 PPT 为例，一般会包含以下几个部分的内容。 个人简介 &amp; 工作内容概述 工作成果及心得体会 专业影响力及专业贡献 未来思考及规划 4.2.1.个人简介 &amp; 工作内容概述个人简介 &amp; 工作内容概述主要是让评委知道你是做什么方向的，参与过什么项目，目前负责哪一块的。 个人简介：主要介绍在什么时间在什么公司主要干了什么项目？比如说在 2015年5月 - 2016年5月在阿里巴巴负责什么数据项目的建设。 工作内容概述：主要是介绍目前的工作内容及负责的工作。可以简单挑几个重点项目中你负责的工作模块，做一个对应的介绍。 4.2.2.工作成果及心得体会这部分是主要介绍以及突出自己解决问题能力的部分，主要去介绍你工作重点突出的项目以及解决的难点问题。让评委知道你是怎么分析问题、解决问题、以及在项目中干了什么牛逼的事情。可以介绍一到两个项目（两个项目需要各有侧重，比如第一个项目体现技术方案牛逼，第二个可以体现保障方案牛逼）。 可以通过以下几点进行介绍。 项目背景：主要是让评委知道这个项目是做什么的，包括了业务本身的背景以及目标，你负责的模块的定位以及目标（讲清楚为什么需要你负责的模块，你负责的模块在这个项目中是干啥的，其重要性）。 需求分析以及难点问题分析：从需求以及业务的保障要求出发，分析业务特征以及目前组内的能力现状，从而明确难点问题（在业务上的难点与挑战是什么？在技术上的难点和挑战是什么？）。比如也可以从业务出发，比如业务一年比一年难，之前的技术方案不满足业务要求，其中的难点是什么？ 难点问题的解决方案：主要围绕着上述难点问题，将问题一个一个进行解决，在做 PPT 时，需要注意问题解决方案的先后逻辑关系，不建议只是罗列问题以及问题的解决方案。可以围绕着一个技术\\业务框架图，去介绍这些问题的解决方案以及方案在框架中的定位。 Notes: 这里要注意我们的解决方案可能是非常多的，但是不必全部都说出来，列举出来，因为答辩的时间是有限的，没有那么多时间去把所有的东西都说清楚，所以我们需要挑重点，说能体现我们能力的重点。 项目成果：可以简单带过就可以，比如说你在数据建设上做了什么东西，达成了什么目标？在数据保障上做到了什么？在数据沉淀上做到了什么？在知识传播上又做了什么？ 4.2.3.专业影响力及专业贡献这里我们需要注意，因为所有的工作都需要有价值，有目标，以结果为导向，对我们之后的工作有帮助。所以在答辩的时候也需要从解决问题或者达成目标出发来说影响力及贡献，带着目的去做影响力的扩大和专业贡献，而不能简单地只说出有哪些影响力及贡献。 可以围绕着以下三个方面去说： 技术演进：推进了什么工具链的优化，帮助解决了什么问题，在什么场景应用，应用的广泛度，提高了多少人效，优化了多少性能（列举一些数字） 知识沉淀：沉淀了什么方法论、什么文档、什么工具，帮助后续的工作有什么样的指导、建议、帮助（比如作为标准化的方案）。 知识的传播、知识分享：在公司外部你有什么分享？然后达到了技术影响力的输出。在公司内部分享了东西？包括组内外的技术分享，交流组内的技术分享。指导了多少人干了什么事情，干了多少事情，从而能够帮助他人更高效、标准地上手什么样的开发等。 4.2.4.未来思考及规划未来规划主要是站在目前自己的角色出发去说。不能说一些虚无缥缈的大东西。 思路可以是目前的痛点，未来的规划。 可以从以下三个角度去说： 从业务角度说：比如说现在业务遇到了什么样的难题，或者什么样的问题没有解决，未来你要怎么样去解决这些问题（比如怎样做到低成本或者更高效的？） 从技术角度说：目前什么什么方案不成熟，然后后续要做什么样的优化（比如说目前什么什么技术研究深度、广度不够，后续要怎么进行深度和广度上的探索研究？） 从个人影响力说：比如后续可以从公司外，公司内总内外怎么样去提升个人的影响力（比如说你可以分享一些技术，分享一些文章，开设一些课程？） 5.总结再次说明，晋升永远是有了下一个职级的能力才会有晋升机会。所以如果你想晋升，一定不能只停留满足现状。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（九）：1.13.2 flink tumble window","date":"2021-11-13T06:25:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/10_flink sql 知其所以然（九）：tumble-window-window-tvf/","text":"想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构源码公众号后台回复1.13.2 tumble window 的奇妙解析之路获取。 针对 datastream api 大家都比较熟悉了，还是那句话，在 datastream 中，你写的代码逻辑是什么样的，它最终的执行方式就是什么样的。 但是对于 flink sql 的执行过程，大家还是不熟悉的。 此节就是窗口聚合章节的第二篇，上节介绍了 1.13 之前的 tumble window 实现，本节介绍 window tvf 下的 tumble window 案例给大家介绍其使用方式和原理。 本节依然从以下几个章节给大家详细介绍 flink sql 的能力。 目标篇-本文能帮助大家了解 flink sql 什么？ 回顾上节的 flink sql 适用场景的结论 概念篇-先聊聊常见的窗口聚合 窗口竟然拖慢数据产出？ 常用的窗口 实战篇-简单的 tumble window 案例和运行原理 先看一个 datastream 窗口案例 flink sql tumble window 的语义 tumble window 实际案例 GeneratedWatermarkGenerator - flink 1.12.1 BinaryRowDataKeySelector - flink 1.12.1 AggregateWindowOperator - flink 1.12.1 总结与展望篇 先说说结论，以下这些结论已经在上节说过了，此处附上上节文章： 场景问题：flink sql 很适合简单 ETL，以及基本全部场景下的聚合类指标（本节要介绍的 tumble window 就在聚合类指标的范畴之内）。 语法问题：flink sql 语法其实是和其他 sql 语法基本一致的。基本不会产生语法问题阻碍使用 flink sql。但是本节要介绍的 tumble window 的语法就是略有不同的那部分。下面详细介绍。 运行问题：查看 flink sql 任务时的一些技巧，以及其中一些可能会碰到的坑： 去 flink webui 就能看到这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑。 sql 的 watermark 类型必须要设置为 TIMESTAMP(3)。如果你的数据源时间戳类型是 13 位 bigint 类型时间戳，可以用 ts AS TO_TIMESTAMP_LTZ(row_time, 3) 将其转换为 TIMESTAMP(3) 类型。 事件时间逻辑中，sql api 和 datastream api 对于数据记录时间戳存储逻辑是不一样的。datastream api：每条记录的 rowtime 是放在 StreamRecord 中的时间戳字段中的。sql api：时间戳是每次都从数据中进行获取的。算子中会维护一个下标。可以按照下标从数据中获取时间戳。 2.目标篇-本文能帮助大家了解 flink sql tumble window 什么？关于 flink sql tumble window 一般都会有以下问题。本文的目标也是为大家解答这些问题： 场景问题：场景问题就不必多说，datastream 在 tumble window 场景下的应用很多了，分钟级别聚合等常用场景 语法问题：1.13.2 flink sql 写 tumble window 语法已经没有之前的特殊写法了。下文详细介绍。 运行问题：使用一条简单的分钟级别同时在线案例的 tumble window sql 帮大家从 transformation、runtime 帮大家理解 tumble window 的整体运行机制。 理解误区：既然是 sql 必然要遵循 sql 语义，sql tumble window 聚合是输入多条，产出一条数据。并不像 datastream 那样可以在窗口 udf 中做到多条输入，多条输出。 在正式开始聊 tumble window 之前，先看看上节 flink sql 适用场景的结论。让大家先有 flink sql 的一个整体印象以及结论。 2.1.回顾上节的 flink sql 适用场景的结论不装了，我坦白了，flink sql 其实很适合干的活就是 dwd 清洗，dws 聚合。 此处主要针对实时数仓的场景来说。flink sql 能干 dwd 清洗，dws 聚合，基本上实时数仓的大多数场景都能给覆盖了。 flink sql 牛逼！！！ 但是！！！ 经过博主使用 flink sql 经验来看，并不是所有的 dwd，dws 聚合场景都适合 flink sql（截止发文阶段来说）！！！ 其实这些目前不适合 flink sql 的场景总结下来就是在处理上比 datastream 还是会有一定的损失。 先总结下使用场景：1. dwd：简单的清洗、复杂的清洗、维度的扩充、各种 udf 的使用2. dws：各类聚合 然后分适合的场景和不适合的场景来说，因为只这一篇不能覆盖所有的内容，所以本文此处先大致给个结论，之后会结合具体的场景详细描述。 适合的场景： 简单的 dwd 清洗场景 全场景的 dws 聚合场景 目前不太适合的场景： 复杂的 dwd 清洗场景：举例比如使用了很多 udf 清洗，尤其是使用很多的 json 类解析清洗 关联维度场景：举例比如 datastream 中经常会有攒一批数据批量访问外部接口的场景，flink sql 目前对于这种场景虽然有 localcache、异步访问能力，但是依然还是一条一条访问外部缓存，这样相比批量访问还是会有性能差距。 3.概念篇-先聊聊常见的窗口聚合窗口聚合大家都在 datastream api 中很熟悉了，目前在实时数据处理的过程中，窗口计算可以说是最重要、最常用的一种计算方式了。 但是在抛出窗口概念之前，博主有几个关于窗口的小想法说一下。 3.1.窗口竟然拖慢数据产出？一个小想法。 先抛结论：窗口会拖慢实时数据的产出，是在目前下游分析引擎能力有限的情况下的一种妥协方案。 站在数据开发以及需求方的世界中，当然希望所有的数据都是实时来的，实时处理的，实时产出的，实时展现的。 举个例子：如果你要满足一个一分钟窗口聚合的 pv，uv，或者其他聚合需求。 olap 数据服务引擎 就可以满足上述的实时来的，实时处理的，实时产出的，实时展现的的场景。flink 消费处理明细数据，产出到 kafka，然后直接导入到 olap 引擎中。查询时直接用 olap 做聚合。这其中是没有任何窗口的概念的。但是整个链路中，要保障端对端精确一次，要保障大数据量情况下 olap 引擎能够秒级查询返回，更何况有一些去重类指标的计算，等等场景。把这些压力都放在 olap 引擎的压力是很大的。 因此在 flink 数据计算引擎中就诞生了窗口的概念。我们可以直接在计算引擎中进行窗口聚合计算，然后等到窗口结束之后直接把结果数据产出。这就出现了博主所说的窗口拖慢了实时数据产出的情况。而且窗口在处理不好的情况下可能会导致数据丢失。 关于上述两种情况的具体优劣选择，都由大家自行选择。上述只是引出博主一些想法。 3.2.常用的窗口目前已知的窗口分为以下四种。 1. Tumble Windows2. Hop Windows3. Cumulate Windows4. Session Windows 这些窗口的具体描述直接见官网，有详细的说明。此处不赘述。 https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/sql/queries/window-agg/ 此处介绍下 flink 中常常会涉及到的两个容易混淆的概念就是：窗口 + key。这里来形象的说明下。 窗口：时间周期上面的划分。将无限流进行纵向切分，将无限流切分为一个一个的窗口，窗口相当于是无限流中的一段时间内的数据。 key：数据类别上面的划分。将无限流进行横向划分，相同 key 的数据会被划分到一组中，这个 key 的数据也是一条无限流。 如下图所示。 4.实战篇-简单的 tumble window 案例和运行原理源码公众号后台回复1.13.2 tumble window 的奇妙解析之路获取。 4.1.先看一个 datastream 窗口案例在介绍 sql tumble window 窗口算子执行案例之前，先看一个 datastream 中的窗口算子案例。其逻辑都是相通的。会对我们了解 sql tumble window 算子有帮助。 我们先看看 datastream 处理逻辑。 以下面这个为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class _04_TumbleWindowTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); env.setParallelism(1); env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime); env.addSource(new UserDefinedSource()) .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;Tuple4&lt;String, String, Integer, Long&gt;&gt;(Time.seconds(0)) &#123; @Override public long extractTimestamp(Tuple4&lt;String, String, Integer, Long&gt; element) &#123; return element.f3; &#125; &#125;) .keyBy(new KeySelector&lt;Tuple4&lt;String, String, Integer, Long&gt;, String&gt;() &#123; @Override public String getKey(Tuple4&lt;String, String, Integer, Long&gt; row) throws Exception &#123; return row.f0; &#125; &#125;) .window(TumblingEventTimeWindows.of(Time.seconds(10))) .sum(2) .print(); env.execute(&quot;1.12.1 DataStream TUMBLE WINDOW 案例&quot;); &#125; private static class UserDefinedSource implements SourceFunction&lt;Tuple4&lt;String, String, Integer, Long&gt;&gt; &#123; private volatile boolean isCancel; @Override public void run(SourceContext&lt;Tuple4&lt;String, String, Integer, Long&gt;&gt; sourceContext) throws Exception &#123; while (!this.isCancel) &#123; sourceContext.collect(Tuple4.of(&quot;a&quot;, &quot;b&quot;, 1, System.currentTimeMillis())); Thread.sleep(10L); &#125; &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; &#125;&#125; datastream 生产的具体的 transformation 如下图： 其中我们只关注最重要的 WindowOperator 算子。 其中 WindowOperator 算子包含的重要属性如下图。 来看看 WindowOperator 的执行逻辑。窗口执行的整体详细流程可以参考：http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/ 4.2.flink sql tumble window 的语义介绍到 tumble window 的语义，总要有对比的去介绍。这里的参照物就是 datastream api。 在 datastream api 中。tumble window 一般用作以下两种场景。 业务场景：使用 tumble window 很轻松的计算出窗口内的聚合数据。一般是多条输入数据，窗口结束时一条输出数据。 优化场景：窗口聚合一批数据然后批量访问外部存储扩充维度、或者有一些自定义的处理逻辑。一般是多条输入数据，窗口结束时多条输出数据。 但是在 sql api 中。tumble window 是聚合（group by）语义，聚合在 sql 标准中的数据处理逻辑是多条输入，在窗口触发时就输出一条数据的语义。而上面的常常用在 datastream 中的优化场景是多对多的场景。因此和 sql 语义不符合。所以 flink sql tumble window 一般都是用于计算聚合运算值来使用。 4.3.tumble window 实际案例滚动窗口的特性就是会将无限流进行纵向划分成一个一个的窗口，每个窗口都是相同的大小，并且不重叠。 来，在介绍原理之前，总要先用起来，我们就以下面这个例子展开。 1.（flink 1.13.2）场景：简单且常见的分维度分钟级别同时在线用户数、总销售额 数据源表： 1234567891011121314151617181920CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;) Notes - 关于 watermark 容易踩得坑：sql 的 watermark 类型必须要设置为 TIMESTAMP(3)。如果你的数据源时间戳类型是 13 位 bigint 类型时间戳，可以用 ts AS TO_TIMESTAMP_LTZ(row_time, 3) 将其转换为 TIMESTAMP(3) 类型。 数据汇表： 1234567891011CREATE TABLE sink_table ( dim STRING, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理逻辑： 可以看下下面语法，窗口聚合的写法有专门的 tumble(row_time, interval &#39;1&#39; minute) 写法，这就是与平常我们写的 hive sql，mysql 等不一样的地方。 123456789101112131415161718192021222324252627282930insert into sink_tableselect dim, sum(bucket_pv) as pv, sum(bucket_sum_price) as sum_price, max(bucket_max_price) as max_price, min(bucket_min_price) as min_price, sum(bucket_uv) as uv, max(window_start) as window_startfrom ( SELECT dim, UNIX_TIMESTAMP(CAST(window_start AS STRING)) * 1000 as window_start, window_end, count(*) as bucket_pv, sum(price) as bucket_sum_price, max(price) as bucket_max_price, min(price) as bucket_min_price, -- 计算 uv 数 count(distinct user_id) as bucket_uv FROM TABLE(TUMBLE( TABLE source_table , DESCRIPTOR(row_time) , INTERVAL &#x27;60&#x27; SECOND)) GROUP BY window_start, window_end, dim, -- 按照用户 id 进行分桶，防止数据倾斜 mod(user_id, 1024))group by dim, window_start 2.运行：可以看到，其实在 flink sql 任务中，其会把对应的处理逻辑给写到算子名称上面。 Notes - 观察 flink sql 技巧 1：这个其实就是我们观察 flink sql 任务的第一个技巧。如果你想知道你的 flink 任务在干啥，第一反应是去 flink webui 看看这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑 先看一下整个算子图，如下图。从左到右总共分为四个算子。 第一个算子就是数据源算子，分配 watermark 第二个算子就是在数据源算子的本地进行聚合，类似于 map-reduce map 阶段的 combiner 作用，先在本地进行聚合，然后将聚合结果发下去。 第三个算子就是第一层 group by 分桶聚合计算，将数据按照 user_id 分桶打散，然后聚合计算。 第四个算子就是第二层 group by 合桶计算。 整体描述一下： 来看看每一个算子具体做了什么事情。 第一个算子： table scan 读取数据源 从数据源中获取对应的字段（包括源表定义的 rowtime） 分配 watermark（按照源表定义的 watermark 分配对应的 watermark） 将一些必要的字段抽取。比如 group by 中的字段。在 hash 时需要使用。 第二个算子： 类似 map-reduce 的 combiner 本地聚合。这里的 combiner 的聚合粒度有两部组成，第一部分就是 group by 的 key，第二部分是 user_id。 将数据按照第一层 select 中的数据进行计算以及格式化 Notes： 首先 local agg 的目的是在不影响数据正确性的情况下，减少输出到下游的数据量，提升任务性能。 其中 max，min，count 都能很好地利用本地 combiner 输出量，比如 max 就取 group by key 粒度的最大值即可 但是一旦涉及到 count(distinct)，只按照 group by key 粒度去处理数据，就会出现数据准确性问题，举例：比如两个 source 都来相同 id 的数据，在去重时，按照 group by key 去重就会导致这个 user_id 在两个算子上都计算一次，在下游算子聚合时就会将这两个结果都 +1，最后结果就算重复了。 第三个算子： 窗口聚合分桶计算 将数据按照第一层 select 中的数据进行计算以及格式化 第四个算子： 窗口聚合合桶计算 将数据按照第二层 select 中的数据进行计算以及格式化 将结果 sink 到输出表 3.（flink 1.13.2）结果： 123456781&gt; +U[7, 36403, 1824202613, 99999, 2, 30498, 1632136920000]2&gt; -U[a, 37001, 1857079208, 99999, 3, 30857, 1632136920000]2&gt; +U[a, 37037, 1858977218, 99999, 3, 30886, 1632136920000]1&gt; -U[7, 36403, 1824202613, 99999, 2, 30498, 1632136920000]1&gt; +U[7, 36428, 1825407205, 99999, 2, 30523, 1632136920000]1&gt; -U[2, 36970, 1848722634, 99999, 6, 30876, 1632136920000]2&gt; -U[6, 36911, 1856162742, 99998, 2, 30801, 1632136920000]... 4.（flink 1.13.2）原理： 关于 sql 开始运行的机制见上一节详述。 此处只介绍相比前一节新增内容。可以看到上述代码的具体 transformation 如下图。 4.4.LocalSlicingWindowAggOperator - flink 1.13.24.4.1.整体处理逻辑 整体处理逻辑如下图。 这里处理每一条数据时，主要是把数据放入到 local buffer 中。 涉及到 local combiner 处理计算时，就是第 3 点，跟进代码 windowBuffer.advanceProgress(currentWatermark)。 这里看下具体 combine 流程。总共四步，如下图。 4.4.2.local agg udf 逻辑其实 local agg 的处理逻辑很简单，基本和上节说的 1.12 实现一致。都是代码生成之后做 sum，count，count distinct 的计算。 4.5.SlicingWindowOperator - flink 1.12.14.5.1.整体算子处理逻辑依然如下图： 先看看 transformation 中包含什么内容： 整体处理逻辑如下： 也是在处理 watermark 时，进行聚合计算。 这里有一个重点，就是 global agg udf 是执行 merge 操作进行聚合的。其逻辑就是将上游 combiner 的结果数据聚合。 在窗口触发时，将结果输出。 4.5.2.local agg、global agg udf 逻辑 其实 global agg 和 local agg 逻辑基本一致，这里不再赘述。 5.总结与展望篇想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看） 源码公众号后台回复1.13.2 tumble window 的奇妙解析之路获取。 本文主要介绍了 window tvf 实现的 tumble window 聚合类指标的常见场景案例以及其底层运行原理。 而且也介绍了在查看 flink sql 任务时的一些技巧： 去 flink webui 就能看到这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑。 sql 的 watermark 类型要设置为 TIMESTAMP(3)。如果你的数据源时间戳类型是 13 位 bigint 类型时间戳，可以用 ts AS TO_TIMESTAMP_LTZ(row_time, 3) 将其转换为 TIMESTAMP(3) 类型。 事件时间逻辑中，sql api 和 datastream api 对于数据记录时间戳存储逻辑是不一样的。datastream api：每条记录的 rowtime 是放在 StreamRecord 中的时间戳字段中的。sql api：时间戳是每次都从数据中进行获取的。算子中会维护一个下标。可以按照下标从数据中获取时间戳。 希望大家能持续关注。支持博主。喜欢的请关注 + 点赞 + 再看。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十）：大家都用 cumulate window 计算累计指标啦","date":"2021-11-13T06:25:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/11_flink sql 知其所以然（十）：周期内累计指标用 cumulate window 就够了/","text":"想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇源码公众号后台回复1.13.2 cumulate window 的奇妙解析之路获取。 此节就是窗口聚合章节的第三篇，上节介绍了 1.13 window tvf tumble window 实现，本节主要介绍 1.13. window tvf 的一个重磅更新，即 cumulate window。 本节从以下几个章节给大家详细介绍 cumulate window 的能力。 应用场景介绍 预期的效果 解决方案介绍 总结及展望篇 2.应用场景介绍先来一个简单的小调查：在实时场景中，你见到过最多的指标需求场景是哪一种？ 答案：博主相信，占比比较多的不是 PCU（即同时在线 PV，UV），而是周期内累计 PV，UV 指标（如每天累计到当前这一分钟的 Pv，UV）。因为这类指标是一段周期内的累计状态，对分析师来说更具统计分析价值，而且几乎所有的复合指标都是基于此类指标的统计（不然离线为啥都要一天的数据，而不要一分钟的数据呢）。 本文要介绍的就是周期内累计 PV，UV 指标在 flink 1.13 版本的最优解决方案。 3.预期的效果先来一个实际案例来看看在具体输入值的场景下，输出值应该长啥样。 指标：每天的截止当前分钟的累计 money（sum(money)），去重 id 数（count(distinct id)）。每天代表窗口大小为 1 天，分钟代表移动步长为分钟级别。 来一波输入数据： time id money 2021-11-01 00:01:00 A 3 2021-11-01 00:01:00 B 5 2021-11-01 00:01:00 A 7 2021-11-01 00:02:00 C 3 2021-11-01 00:03:00 C 10 预期输出数据： time count distinct id sum money 2021-11-01 00:01:00 2 15 2021-11-01 00:02:00 3 18 2021-11-01 00:03:00 3 28 转化为折线图长这样： 可以看到，其特点就在于，每一分钟的输出结果都是当天零点累计到当前的结果。 4.解决方案介绍4.1.1.13 之前可选的解决方案有两种 tumble window（1天窗口） + early-fire（1分钟） group by（1天） + minibatch（1分钟） 但是上述两种解决方案产出的都是 retract 流，关于 retract 流存在的缺点见如下文章： 并且 tumble window + early-fire 的触发机制是基于处理时间而非事件时间，具体缺点见如下文章： 4.2.1.13 及之后诞生了 cumulate window 解法，具体见官网链接： https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/sql/queries/window-tvf/#cumulate 如下官网文档所示，介绍 cumulate window 的第一句话就是 cumulate window 非常适合于之前使用 tumble window + early-fire 的场景。可以说 cumulate window 就是在用户计算周期内累计 PV，UV 指标时，使用了 tumble window + early-fire 后发现这种方案存在了很多坑的情况下，而诞生的！ 其计算机制如下图所示： 还是以刚刚的案例说明，以天为窗口，每分钟输出一次当天零点到当前分钟的累计值，在 cumulate window 中，其窗口划分规则如下： [2021-11-01 00:00:00, 2021-11-01 00:01:00][2021-11-01 00:00:00, 2021-11-01 00:02:00][2021-11-01 00:00:00, 2021-11-01 00:03:00]…[2021-11-01 00:00:00, 2021-11-01 23:58:00][2021-11-01 00:00:00, 2021-11-01 23:59:00] 第一个 window 统计的是一个区间的数据；第二个 window 统计的是第一区间和第二个区间的数据；第三个 window 统计的是第一区间，第二个区间和第三个区间的数据。 那么以 cumulate window 实现上述的需求，具体的 SQL 如下： 1234567891011SELECT UNIX_TIMESTAMP(CAST(window_end AS STRING)) * 1000 as window_end, window_start, sum(money) as sum_money, count(distinct id) as count_distinct_idFROM TABLE(CUMULATE( TABLE source_table , DESCRIPTOR(row_time) , INTERVAL &#x27;60&#x27; SECOND , INTERVAL &#x27;1&#x27; DAY))GROUP BY window_start, window_end 其中 CUMULATE(TABLE source_table, DESCRIPTOR(row_time), INTERVAL &#39;60&#39; SECOND, INTERVAL &#39;1&#39; DAY) 中的INTERVAL &#39;1&#39; DAY 代表窗口大小为 1 天，INTERVAL &#39;60&#39; SECOND，窗口划分步长为 60s。 其中 window_start, window_end 字段是 cumulate window 自动生成的类型是 timestamp(3)。 window_start 固定为窗口的开始时间。window_end 随着步长向前移动，变化。 最终结果如下。 输入数据：row_time|id|money-|-|-2021-11-01 00:01:00 | A | 32021-11-01 00:01:00 | B | 52021-11-01 00:01:00 | A | 72021-11-01 00:02:00 | C | 32021-11-01 00:03:00 | C | 10 输出数据：window_end|window_start|sum_money|count_distinct_id-|-|-|-2021-11-21T00:01 | 1635696000000 | 2 | 152021-11-21T00:02 | 1635696000000 | 3 | 182021-11-21T00:03 | 1635696000000 | 3 | 28 Notes：天级别窗口划分的时候一定要注意时区问题喔！https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/table/timezone/ 4.3.cumulate window 原理解析首先 cumulate window 是一个窗口，其窗口计算的触发也是完全由 watermark 推动的。与 tumble window 一样。 cumulate window 维护了一个 slice state 和 merged state，slice state 就是每一分钟内窗口数据（叫做切片），merged state 的作用是当 watermark 推动到下一分钟时，这一分钟的 slice state 就会被 merge 到 merged stated 中。从而就计算出当天累计到当前分钟的数据。 4.4.cumulate window 怎么解决 tumble window + early-fire 的问题 问题1：tumble window + early-fire 处理时间触发的问题。 cumulate window 可以以事件时间推进进行触发。 问题1：tumble window + early-fire retract 流问题。 cumulate window 是 append 流。 5.总结源码公众号后台回复1.13.2 cumulate window 的奇妙解析之路获取。 本文主要介绍了 window tvf 实现的 cumulate window 聚合类指标的场景案例以及其运行原理： 介绍了周期内累计 PV，UV 是我们最常用的指标场景质疑。 在 tumble window + early-fire 或者 groupby + minibatch 计算周期内累计 PV，UV 存在各种问题是，诞生了 cumulate window 帮我们解决了这些问题，并以一个案例进行说明。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（十一）：去重不仅仅有 count distinct 还有强大的 deduplication","date":"2021-11-13T06:25:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/12_flink sql 知其所以然（十一）：去重不仅仅有 count distinct 还有强大的 deduplication/","text":"想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇源码公众号后台回复1.13.2 deduplication 的奇妙解析之路获取。 下面即是文章目录，也对应到了本文的结论，小伙伴可以先看结论快速了解博主期望本文能给小伙伴们带来什么帮助： 背景及应用场景介绍：博主期望你了解到，flink sql 的 deduplication 其实就是 row_number = 1，所以它可以在去重的同时，还能保留原始字段数据 来一个实战案例：博主以一个日志上报重复的场景，来引出下文要介绍的 flink sql deduplication 解决方案 基于 Deduplication 的解决方案及原理解析：博主期望你了解到，deduplication 中，当 row_number order by proctime（处理时间）去重的原理就是给每一个 partition key 维护一个 value state。如果当前 value state 不为空，则说明 id 已经来过了，当前这条数据就不用下发了。如果 value state 为空，则 id 还没还没来过，把 value state 标记之后，把当前数据下发。 总结及展望篇 2.背景及应用场景介绍你是否遇到过一下的场景： 由于上游发过来的数据有重复或者日志源头数据有重复上报，导致下游计算 count，sum 时算多 想做到去重计算的同时，原始表的所有字段还能正常保留且下发 那么你能想到哪些解决方案呢？ 熟悉离线计算的小伙伴可能很快就能给出答案。没错，hive sql 中的 row_number = 1。flink sql 中也是提供了一模一样的功能，xdm，完美的解决这个问题。 下面开始正式篇章。 3.来一个实战案例先来一个实际案例来看看在具体输入值的场景下，输出值应该长啥样。 场景：埋点数据上报的的字段有 id（标识唯一一条日志），timestamp（事件时间戳），page（时间发生的当前页面），param1，param2，paramN…。但是日志上报时由于一些机制导致日志上报重复，下游算多了，因此需要做一次去重，下游再去消费去过重的数据。 来一波输入数据： id timestamp page param1 param2 paramN 1 2021-11-01 00:01:00 A xxx1 xxx2 xxxN 1 2021-11-01 00:01:00 A xxx1 xxx2 xxxN 2 2021-11-01 00:01:00 A xxx3 xxx2 xxxN 2 2021-11-01 00:01:00 A xxx3 xxx2 xxxN 3 2021-11-01 00:03:00 C xxx5 xxx2 xxxN 其中第二条和第四条是重复上报的数据，则预期输出数据如下： id timestamp page param1 param2 paramN 1 2021-11-01 00:01:00 A xxx1 xxx2 xxxN 2 2021-11-01 00:01:00 A xxx3 xxx2 xxxN 3 2021-11-01 00:03:00 C xxx5 xxx2 xxxN 4.基于 Deduplication 的解决方案及原理解析4.1.sql 写法还是上面的案例，我们来看看最终的 sql 应该怎么写： 12345678910111213141516171819select id, timestamp, page, param1, param2, paramNfrom ( SELECT id, timestamp, page, param1, param2, paramN -- proctime 代表处理时间即 source 表中的 PROCTIME() row_number() over(partition by id order by proctime) as rn FROM source_table)where rn = 1 上面的 sql 应该很好理解。其中由于我们并不关心重复数据上报的时间前后，所以此处就直接使用 order by proctime 进行处理，按照数据来的前后时间去第一条。 4.2.proctime 下 flink 生成的算子图及 sql 算子语义算子图如下所示： source 算子：source 通过 keyby 的方式向 deduplication 算子发数据时，其中 keyby 的 key 就是 sql 中的 id deduplication 算子：deduplication 算子为每一个 partition key 都维护了一个 value state 用于去重。每来一条数据时都从当前 partition key 的 value state 去获取 value，如果不为空，则说明已经有数据来过了，当前这一条数据就是重复数据，就不往下游算子下发了，如果为空，则说明之前没有数据来过，当前这一条数据就是第一条数据，则把当前的 value state 值设置为 true，往下游算子下发数据 4.3.proctime 下 deduplication 原理解析具体的去重算子为 deduplication。我们通过 transformation 可以看到去重算子为下图所示： 上述的去重逻辑集中在 org.apache.flink.table.runtime.operators.deduplicate.ProcTimeDeduplicateKeepFirstRowFunction 的 processFirstRowOnProcTime，如下图所示： 5.总结与展望源码公众号后台回复1.13.2 deduplication 的奇妙解析之路获取。 本文主要介绍了 deduplication 的应用场景案例以及其运行原理，主要包含下面两部分： 背景及应用场景介绍：博主期望你了解到，flink sql 的 deduplication 其实就是 row_number = 1，所以它可以在去重的同时，还能保留原始字段数据 来一个实战案例：博主以一个日志上报重复的场景，来引出下文要介绍的 flink sql deduplication 解决方案 基于 Deduplication 的解决方案及原理解析：博主期望你了解到，deduplication 中，当 row_number order by proctime（处理时间）去重的原理就是给每一个 partition key 维护一个 value state。如果当前 value state 不为空，则说明 id 已经来过了，当前这条数据就不用下发了。如果 value state 为空，则 id 还没还没来过，把 value state 标记之后，把当前数据下发。 总结及展望篇","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink ck 恢复","date":"2021-11-13T06:25:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/03_state/02_本地调试_flink_ck/","text":"想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构源码公众号后台回复flink idea 本地调试状态重启获取。 案例代码 本地任务启动指定 ck 存储路径 本地任务停止时，保留 ck 本地任务重启时，指定从 ck 重启 2.案例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CREATE TABLE source_table ( dim BIGINT, user_id BIGINT, price BIGINT, row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;1&#x27;, &#x27;fields.dim.min&#x27; = &#x27;1&#x27;, &#x27;fields.dim.max&#x27; = &#x27;2&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;);CREATE TABLE sink_table ( dim BIGINT, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;);insert into sink_tableselect dim, sum(bucket_pv) as pv, sum(bucket_sum_price) as sum_price, max(bucket_max_price) as max_price, min(bucket_min_price) as min_price, sum(bucket_uv) as uv, max(window_start) as window_startfrom ( select dim, count(*) as bucket_pv, sum(price) as bucket_sum_price, max(price) as bucket_max_price, min(price) as bucket_min_price, count(distinct user_id) as bucket_uv, UNIX_TIMESTAMP(CAST(tumble_start(row_time, interval &#x27;1&#x27; DAY) AS STRING)) * 1000 as window_start from source_table group by mod(user_id, 1024), dim, tumble(row_time, interval &#x27;1&#x27; DAY))group by dim, window_start 3.本地任务启动指定 ck 存储路径1234567// 状态后端设置// 设置存储文件位置为 file:///Users/flink/checkpointsRocksDBStateBackend rocksDBStateBackend = new RocksDBStateBackend( &quot;file:///Users/flink/checkpoints&quot;, ENABLE_INCREMENTAL_CHECKPOINT);rocksDBStateBackend.setNumberOfTransferThreads(NUMBER_OF_TRANSFER_THREADS);rocksDBStateBackend.setPredefinedOptions(PredefinedOptions.SPINNING_DISK_OPTIMIZED_HIGH_MEM);env.setStateBackend((StateBackend) rocksDBStateBackend); 效果： 4.本地任务启动停止时，保留 ck12// ck 设置env.getCheckpointConfig().enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION); 效果： 5.本地任务重启时，指定从 ck 重启1234567// ck 设置Configuration configuration = new Configuration();configuration.setString(&quot;execution.savepoint.path&quot;, &quot;file:///Users/flink/checkpoints/ce2e1969c5088bf27daf35d4907659fd/chk-5&quot;);StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration); 效果： 6.总结与展望篇想啥呢，小宝贝，还不三连？？？（关注 + 点赞 + 再看） 源码公众号后台回复flink idea 本地调试状态重启获取。 希望大家能持续关注。支持博主。喜欢的请关注 + 点赞 + 再看。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（八）：flink sql tumble window 的奇妙解析之路","date":"2021-11-13T06:23:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/09_flink sql 知其所以然（八）：不会连最适合 flink sql 的 窗口聚合场景都没见过吧/","text":"感谢您的小爱心（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构源码公众号后台回复flink sql tumble window 的奇妙解析之路获取。 针对 datastream api 大家都比较熟悉了，还是那句话，在 datastream 中，你写的代码逻辑是什么样的，它最终的执行方式就是什么样的。 但是对于 flink sql 的执行过程，大家还是不熟悉的。上节使用 ETL，group agg（sum，count等）简单聚合类 query 带大家走进一条 flink sql query 逻辑的世界。帮大家至少能够熟悉在 flink sql 程序运行时知道 flink 程序在干什么。 此节就是窗口聚合章节的第一篇，以一个最简单、最常用的分钟 tumble window 聚合案例给大家介绍其使用方式和原理。 由于 flink 1.13 引入了 window tvf，所以 1.13 和 1.12 及之前版本的实现不同。本节先介绍 flink 1.12 及之前的 tumble window 实现。这也是大家在引入 flink sql 能力时最常使用的。 本节依然从以下几个章节给大家详细介绍 flink sql 的能力。 目标篇-本文能帮助大家了解 flink sql 什么？ 回顾上节的 flink sql 适用场景的结论 概念篇-先聊聊常见的窗口聚合 窗口竟然拖慢数据产出？ 常用的窗口 实战篇-简单的 tumble window 案例和运行原理 先看一个 datastream 窗口案例 flink sql tumble window 的语义 tumble window 实际案例 GeneratedWatermarkGenerator - flink 1.12.1 BinaryRowDataKeySelector - flink 1.12.1 AggregateWindowOperator - flink 1.12.1 总结与展望篇 先说说结论，以下这些结论已经在上节说过了，此处附上上节文章： 场景问题：flink sql 很适合简单 ETL，以及基本全部场景下的聚合类指标（本节要介绍的 tumble window 就在聚合类指标的范畴之内）。 语法问题：flink sql 语法其实是和其他 sql 语法基本一致的。基本不会产生语法问题阻碍使用 flink sql。但是本节要介绍的 tumble window 的语法就是略有不同的那部分。下面详细介绍。 运行问题：查看 flink sql 任务时的一些技巧，以及其中一些可能会碰到的坑： 去 flink webui 就能看到这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑。 sql 的 watermark 类型要设置为 TIMESTAMP(3)。 事件时间逻辑中，sql api 和 datastream api 对于数据记录时间戳存储逻辑是不一样的。datastream api：每条记录的 rowtime 是放在 StreamRecord 中的时间戳字段中的。sql api：时间戳是每次都从数据中进行获取的。算子中会维护一个下标。可以按照下标从数据中获取时间戳。 2.目标篇-本文能帮助大家了解 flink sql tumble window 什么？关于 flink sql tumble window 一般都会有以下问题。本文的目标也是为大家解答这些问题： 场景问题：场景问题就不必多说，datastream 在 tumble window 场景下的应用很多了，分钟级别聚合等常用场景 语法问题：flink sql 写 tumble window 任务时是一种与 hive sql 中没有的语法。下文详细介绍。 运行问题：使用一条简单的 tumble window sql 帮大家从 transformation、runtime 帮大家理解 tumble window 的整体运行机制。 理解误区：既然是 sql 必然要遵循 sql 语义，sql tumble window 聚合是输入多条，产出一条数据。并不像 datastream 那样可以在窗口 udf 中做到多对多。 在正式开始聊 tumble window 之前，先看看上节 flink sql 适用场景的结论。让大家先有 flink sql 的一个整体印象以及结论。 2.1.回顾上节的 flink sql 适用场景的结论不装了，我坦白了，flink sql 其实很适合干的活就是 dwd 清洗，dws 聚合。 此处主要针对实时数仓的场景来说。flink sql 能干 dwd 清洗，dws 聚合，基本上实时数仓的大多数场景都能给覆盖了。 flink sql 牛逼！！！ 但是！！！ 经过博主使用 flink sql 经验来看，并不是所有的 dwd，dws 聚合场景都适合 flink sql（截止发文阶段来说）！！！ 其实这些目前不适合 flink sql 的场景总结下来就是在处理上比 datastream 还是会有一定的损失。 先总结下使用场景：1. dwd：简单的清洗、复杂的清洗、维度的扩充、各种 udf 的使用2. dws：各类聚合 然后分适合的场景和不适合的场景来说，因为只这一篇不能覆盖所有的内容，所以本文此处先大致给个结论，之后会结合具体的场景详细描述。 适合的场景： 简单的 dwd 清洗场景 全场景的 dws 聚合场景 目前不太适合的场景： 复杂的 dwd 清洗场景：举例比如使用了很多 udf 清洗，尤其是使用很多的 json 类解析清洗 关联维度场景：举例比如 datastream 中经常会有攒一批数据批量访问外部接口的场景，flink sql 目前对于这种场景虽然有 localcache、异步访问能力，但是依然还是一条一条访问外部缓存，这样相比批量访问还是会有性能差距。 3.概念篇-先聊聊常见的窗口聚合窗口聚合大家都在 datastream api 中很熟悉了，目前在实时数据处理的过程中，窗口计算可以说是最重要、最常用的一种计算方式了。 但是在抛出窗口概念之前，博主有几个关于窗口的小想法说一下。 3.1.窗口竟然拖慢数据产出？一个小想法。 先抛结论：窗口会拖慢实时数据的产出，是在目前下游分析引擎能力有限的情况下的一种妥协方案。 站在数据开发以及需求方的世界中，当然希望所有的数据都是实时来的，实时处理的，实时产出的，实时展现的。 举个例子：如果你要满足一个一分钟窗口聚合的 pv，uv，或者其他聚合需求。 olap 数据服务引擎 就可以满足上述的实时来的，实时处理的，实时产出的，实时展现的的场景。flink 消费处理明细数据，产出到 kafka，然后直接导入到 olap 引擎中。查询时直接用 olap 做聚合。这其中是没有任何窗口的概念的。但是整个链路中，要保障端对端精确一次，要保障大数据量情况下 olap 引擎能够秒级查询返回，更何况有一些去重类指标的计算，等等场景。把这些压力都放在 olap 引擎的压力是很大的。 因此在 flink 数据计算引擎中就诞生了窗口的概念。我们可以直接在计算引擎中进行窗口聚合计算，然后等到窗口结束之后直接把结果数据产出。这就出现了博主所说的窗口拖慢了实时数据产出的情况。而且窗口在处理不好的情况下可能会导致数据丢失。 关于上述两种情况的具体优劣选择，都由大家自行选择。上述只是引出博主一些想法。 3.2.常用的窗口目前已知的窗口分为以下四种。 1. Tumble Windows2. Hop Windows3. Cumulate Windows4. Session Windows 这些窗口的具体描述直接见官网，有详细的说明。此处不赘述。 https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/table/sql/queries/window-agg/ 此处介绍下 flink 中常常会涉及到的两个容易混淆的概念就是：窗口 + key。这里来形象的说明下。 窗口：时间周期上面的划分。将无限流进行纵向切分，将无限流切分为一个一个的窗口，窗口相当于是无限流中的一段时间内的数据。 key：数据类别上面的划分。将无限流进行横向划分，相同 key 的数据会被划分到一组中，这个 key 的数据也是一条无限流。 如下图所示。 4.实战篇-简单的 tumble window 案例和运行原理源码公众号后台回复flink sql tumble window 的奇妙解析之路获取。 4.1.先看一个 datastream 窗口案例在介绍 sql tumble window 窗口算子执行案例之前，先看一个 datastream 中的窗口算子案例。其逻辑都是相通的。会对我们了解 sql tumble window 算子有帮助。 我们先看看 datastream 处理逻辑。 以下面这个为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class _04_TumbleWindowTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); env.setParallelism(1); env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime); env.addSource(new UserDefinedSource()) .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;Tuple4&lt;String, String, Integer, Long&gt;&gt;(Time.seconds(0)) &#123; @Override public long extractTimestamp(Tuple4&lt;String, String, Integer, Long&gt; element) &#123; return element.f3; &#125; &#125;) .keyBy(new KeySelector&lt;Tuple4&lt;String, String, Integer, Long&gt;, String&gt;() &#123; @Override public String getKey(Tuple4&lt;String, String, Integer, Long&gt; row) throws Exception &#123; return row.f0; &#125; &#125;) .window(TumblingEventTimeWindows.of(Time.seconds(10))) .sum(2) .print(); env.execute(&quot;1.12.1 DataStream TUMBLE WINDOW 案例&quot;); &#125; private static class UserDefinedSource implements SourceFunction&lt;Tuple4&lt;String, String, Integer, Long&gt;&gt; &#123; private volatile boolean isCancel; @Override public void run(SourceContext&lt;Tuple4&lt;String, String, Integer, Long&gt;&gt; sourceContext) throws Exception &#123; while (!this.isCancel) &#123; sourceContext.collect(Tuple4.of(&quot;a&quot;, &quot;b&quot;, 1, System.currentTimeMillis())); Thread.sleep(10L); &#125; &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; &#125;&#125; datastream 生产的具体的 transformation 如下图： 其中我们只关注最重要的 WindowOperator 算子。 其中 WindowOperator 算子包含的重要属性如下图。 来看看 WindowOperator 的执行逻辑。窗口执行的整体详细流程可以参考：http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/ 4.2.flink sql tumble window 的语义介绍到 tumble window 的语义，总要有对比的去介绍。这里的参照物就是 datastream api。 在 datastream api 中。tumble window 一般用作以下两种场景。 业务场景：使用 tumble window 很轻松的计算出窗口内的聚合数据。一般是多条输入数据，窗口结束时一条输出数据。 优化场景：窗口聚合一批数据然后批量访问外部存储扩充维度、或者有一些自定义的处理逻辑。一般是多条输入数据，窗口结束时多条输出数据。 但是在 sql api 中。tumble window 是聚合（group by）语义，聚合在 sql 标准中的数据处理逻辑是多条输入，在窗口触发时就输出一条数据的语义。而上面的常常用在 datastream 中的优化场景是多对多的场景。因此和 sql 语义不符合。所以 flink sql tumble window 一般都是用于计算聚合运算值来使用。 4.3.tumble window 实际案例滚动窗口的特性就是会将无限流进行纵向划分成一个一个的窗口，每个窗口都是相同的大小，并且不重叠。 本文主要介绍 flink 1.12 及之前版本的实现。下一篇文章介绍 flink 1.13 的实现。 来，在介绍原理之前，总要先用起来，我们就以下面这个例子展开。 1.（flink 1.12.1）场景：简单且常见的分维度分钟级别同时在线用户数、总销售额 数据源表： 1234567891011121314151617181920CREATE TABLE source_table ( -- 维度数据 dim STRING, -- 用户 id user_id BIGINT, -- 用户 price BIGINT, -- 事件时间戳 row_time AS cast(CURRENT_TIMESTAMP as timestamp(3)), -- watermark 设置 WATERMARK FOR row_time AS row_time - INTERVAL &#x27;5&#x27; SECOND) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;100000&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;100000&#x27;) Notes - 关于 watermark 容易踩得坑：sql 的 watermark 类型必须要设置为 TIMESTAMP(3)。 数据汇表： 1234567891011CREATE TABLE sink_table ( dim STRING, pv BIGINT, sum_price BIGINT, max_price BIGINT, min_price BIGINT, uv BIGINT, window_start bigint) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理逻辑： 可以看下下面语法，窗口聚合的写法有专门的 tumble(row_time, interval &#39;1&#39; minute) 写法，这就是与平常我们写的 hive sql，mysql 等不一样的地方。 1234567891011121314151617181920212223242526insert into sink_tableselect dim, sum(bucket_pv) as pv, sum(bucket_sum_price) as sum_price, max(bucket_max_price) as max_price, min(bucket_min_price) as min_price, sum(bucket_uv) as uv, max(window_start) as window_startfrom ( select dim, count(*) as bucket_pv, sum(price) as bucket_sum_price, max(price) as bucket_max_price, min(price) as bucket_min_price, -- 计算 uv 数 count(distinct user_id) as bucket_uv, cast(tumble_start(row_time, interval &#x27;1&#x27; minute) as bigint) * 1000 as window_start from source_table group by -- 按照用户 id 进行分桶，防止数据倾斜 mod(user_id, 1024), dim, tumble(row_time, interval &#x27;1&#x27; minute))group by dim, window_start 2.运行：可以看到，其实在 flink sql 任务中，其会把对应的处理逻辑给写到算子名称上面。 Notes - 观察 flink sql 技巧 1：这个其实就是我们观察 flink sql 任务的第一个技巧。如果你想知道你的 flink 任务在干啥，第一反应是去 flink webui 看看这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑 先看一下整个算子图，如下图。从左到右总共分为三个算子。 第一个算子就是数据源算子 第二个算子就是分了桶的窗口聚合算子，第一个算子和第二个算子之间 hash 传输就是按照 group key 进行 hash 传输 第三个算子就是外层进行合桶计算的算子，同样也是 hash 传输，将分桶的数据在一个算子中进行合并计算 来看看每一个算子具体做了什么事情。 第一个算子： table scan 读取数据源 从数据源中获取对应的字段（包括源表定义的 rowtime） 分配 watermark（按照源表定义的 watermark 分配对应的 watermark） 将一些必要的字段抽取。比如 group by 中的字段。在 hash 时需要使用。 第二个算子： 窗口聚合，计算窗口聚合数据 将数据按照第一层 select 中的数据进行计算以及格式化 第三个算子： group 聚合合桶计算 将数据按照第二层 select 中的数据进行计算以及格式化 将数据 sink 写出 3.（flink 1.12.1）结果： 12345678910+I(9,1,32682,32682,32682,1,1631026440000)-U(9,1,32682,32682,32682,1,1631026440000)+U(9,2,115351,82669,32682,2,1631026440000)+I(2,1,76148,76148,76148,1,1631026440000)+I(8,1,79321,79321,79321,1,1631026440000)+I(a,1,85792,85792,85792,1,1631026440000)+I(0,1,12858,12858,12858,1,1631026440000)+I(5,1,36753,36753,36753,1,1631026440000)+I(3,1,19218,19218,19218,1,1631026440000)... 4.（flink 1.12.1）原理： 关于 sql 开始运行的机制见上一节详述。 此处只介绍相比前一节新增内容。可以看到上述代码的具体 transformation 如下图。 4.4.GeneratedWatermarkGenerator - flink 1.12.1按照顺序，首先看看 watermark 算子。同 datastream 的自定义 watermark 分配策略。 watermark 生成的具体代码 WatermarkGenerator$6，主要获取 watermark 的逻辑在 currentWatermark 方法中。如下图。 4.5.BinaryRowDataKeySelector - flink 1.12.1接着就是 group by（同 datastream 中的 keyby）。 group by key 生成的具体代码 KeyProjection$19，主要逻辑在 apply 方法中。 下一个就是窗口聚合算子。 4.6.AggregateWindowOperator - flink 1.12.1兄弟们！！！兄弟们！！！兄弟们！！！ 本节的重头戏来了。sql 窗口聚合算子解析搞起来了。 关于 WatermarkGenerator 和 KeyProjection 没有什么可以详细介绍的，都是输入一条数据，输出一条数据，逻辑很简单。 但是窗口聚合算子的计算逻辑相比上面两个算子复杂很多。窗口算子又承载了窗口聚合的主要逻辑，所以本文重点介绍窗口算子计算的逻辑。 先来看看 sql 窗口整体处理流程。其实与 datastream 处理流程基本一致，但只是少了 Evictor。如下图所示。 接着来看看上述 sql 生成的窗口聚合算子 AggregateWindowOperator，截图中属性也很清晰。 具体生成的窗口聚合代码 GroupingWindowAggsHandler$59。 计算逻辑 GroupingWindowAggsHandler$59#accumulate。 上面那段都是在 flink 客户端初始化处理的。包括窗口算子的初始化等。 下面这段处理逻辑是在 flink TM 运行时开始执行的，包括窗口算子资源的初始化以及运行逻辑。就到了正式的数据处理环节了。 窗口算子 Task 运行。 窗口算子 Task 初始化。 StreamTask 整体的处理流程。 窗口算子 open 初始化。 窗口算子 open 初始化后的结果。如下图，对应的具体组件。 初始化完成之后，开始处理具体数据。 循环 loop，一直 run 啊 run。 判断记录的具体类型，然后执行不同的逻辑。 来看看处理一条数据的 processElement 方法逻辑，进行 acc 处理。代码中的的 windowAggregator 就是之前代码生成的 GroupingWindowAggsHandler$59。 Notes：事件时间逻辑中，sql api 和 datastream api 对于数据记录时间戳存储逻辑是不一样的。datastream api：每条记录的 rowtime 是放在 StreamRecord 中的时间戳字段中的。sql api：时间戳是每次都从数据中进行获取的。算子中会维护一个下标。可以按照下标从数据中获取时间戳。 来看看 watermark 到达并且触发窗口计算时，执行 onEventTime 逻辑。 触发窗口计算时，onEventTime -&gt; emitWindowResult，产出具体数据。 至此整个 sql tumble window 的处理逻辑也就很清楚了。和 datastream 基本上都是一致的。是不是整个逻辑就理清楚了。 5.总结与展望篇源码公众号后台回复flink sql tumble window 的奇妙解析之路获取。 本文主要介绍了 tumble window 聚合类指标的常见场景案例以及其底层运行原理。 而且也介绍了在查看 flink sql 任务时的一些技巧： 去 flink webui 就能看到这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑。 sql 的 watermark 类型要设置为 TIMESTAMP(3)。 事件时间逻辑中，sql api 和 datastream api 对于数据记录时间戳存储逻辑是不一样的。datastream api：每条记录的 rowtime 是放在 StreamRecord 中的时间戳字段中的。sql api：时间戳是每次都从数据中进行获取的。算子中会维护一个下标。可以按照下标从数据中获取时间戳。 后续文章会基于一些最常见的案例以及原理层面介绍 1.13 版本的 flink sql tumble window（基于最新的 window tvf）。 希望大家能持续关注。支持博主。喜欢的请关注 + 点赞 + 再看。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（七）：不会连最适合 flink sql 的 ETL 和 group agg 场景都没见过吧？","date":"2021-11-13T06:22:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/08_flink sql 知其所以然（七）：不会连最适合 flink sql 的 ETL 和 group agg 场景都没见过吧？/","text":"感谢您的小爱心（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构前面的章节铺垫了那么多，终于在本节走入一条 query 了。 针对 datastream api 大家都比较熟悉了，还是那句话，在 datastream 中，你写的代码逻辑是什么样的，它最终的执行方式就是什么样的。 但是对于 flink sql 的执行过程，大家还是不熟悉的。 因此本文通过以下章节使用 ETL，group agg（sum，count等）简单聚合类 query 带大家走进一条 flink sql query 逻辑的世界。帮大家至少能够熟悉在 flink sql 程序运行时知道 flink 程序在干什么。 背景篇-大家不了解 flink sql 什么？ 目标篇-本文能帮助大家了解 flink sql 什么？ 实战篇-简单的 query 案例和运行原理 总结与展望篇 先说说结论： 场景问题：flink sql 很适合简单 ETL，以及基本全部场景下的聚合类指标。 语法问题：flink sql 语法其实是和其他 sql 语法基本一致的。基本不会产生语法问题阻碍使用 flink sql。 运行问题：查看 flink sql 任务时的一些技巧： 去 flink webui 看看这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑。 如果你想知道你的 flink 任务执行了什么代码，就去看看 sql 最后转换成的 transformation 里面具体要执行哪些操作。flink sql 生成的代码也在里面。 如果你不确定线上任务执行原理，可以直接在本地尝试运行。 2.背景篇-大家不了解 flink sql 什么？首先从大家用 flink sql 的一个初衷和状态出发，想一下大家在开始上手 flink sql 时，是什么样的一个想法？ 博主大概整理了下，在初步上手 flink sql，一般从入手到踩坑整个过程中，一般都会有以下几种问题或者想法： 场景问题：首先 flink sql 是用来提效的，那相比 datastream，哪些场景很适合 flink sql 去做？ 语法问题：我写 sql 时 flink sql 语法会不会和其他 sql 语法有不同？ 运行问题：我写了一条 sql，运行起来了，但是对我来说是黑盒的，我怎么知道这个任务正在执行什么操作？有没有什么好办法帮我去理解 flink sql 的运行机制？ 理解误区：在理解 flink sql 的运算机制上有哪些误区？ 坑：flink sql 一般都有啥坑？提前了解帮我们避免踩坑。 就是上面这些想法，会让很多想在公司内部引入 flink sql 的同学望而却步。 3.目标篇-本文能帮助大家了解 flink sql 什么？来看看本文的目标： 场景问题：帮大家理解哪些场景是非常适合 flink sql 的 语法问题：帮大家简单熟悉 flink sql 的语法 运行问题：使用一条简单的 query sql 看看其运行起来的过程，其运行的机制 理解误区：运算机制上的常见误区 坑：看看 sql 一般会有啥坑 由于一篇文章不能覆盖所有概念，本文主要介绍一些最简单的 ETL，聚合场景，主要集中于前三点。 后两点在后续系列文章中会按照场景详细展开。 4.实战篇-简单的 query 案例和运行原理4.1.场景问题：有哪些场景适合 flink sql？不装了，我坦白了，flink sql 其实很适合干的活就是 dwd 清洗，dws 聚合。 此处主要针对实时数仓的场景来说。flink sql 能干 dwd 清洗，dws 聚合，基本上实时数仓的大多数场景都能给覆盖了。 flink sql 牛逼！！！ 但是！！！ 经过博主使用 flink sql 经验来看，并不是所有的 dwd，dws 聚合场景都适合 flink sql（截止发文阶段来说）！！！ 其实这些目前不适合 flink sql 的场景总结下来就是在处理上比 datastream 还是会有一定的损失。 先总结下使用场景：1. dwd：简单的清洗、复杂的清洗、维度的扩充、各种 udf 的使用2. dws：各类聚合 然后分适合的场景和不适合的场景来说，因为只这一篇不能覆盖所有的内容，所以本文此处先大致给个结论，之后会结合具体的场景详细描述。 适合的场景： 简单的 dwd 清洗场景 全场景的 dws 聚合场景 目前不太适合的场景： 复杂的 dwd 清洗场景：举例比如使用了很多 udf 清洗，尤其是使用很多的 json 类解析清洗 关联维度场景：举例比如 datastream 中经常会有攒一批数据批量访问外部接口的场景，flink sql 目前对于这种场景虽然有 localcache、异步访问能力，但是依然还是一条一条访问外部缓存，这样相比批量访问还是会有性能差距。 4.2.语法\\运行问题其实总结来说，对于接触过 sql 的同学来说，除了 flink sql 中窗口聚合类的写法来说，其他的 sql 语法都是相同的，很容易理解。 本节会针对具体的案例进行详细介绍。 4.2.1.ETL最简单的 ETL 类型任务。 1SELECT select_list FROM table_expression [ WHERE boolean_expression ] 1.场景：简单的 dwd 清洗过滤场景 源码公众号后台回复不会连最适合 flink sql 的 ETL 和 group agg 场景都没见过吧获取。 数据源表： 123456789CREATE TABLE source_table ( order_number BIGINT, price DECIMAL(32,2)) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.order_number.min&#x27; = &#x27;10&#x27;, &#x27;fields.order_number.max&#x27; = &#x27;11&#x27;) 数据汇表： 123456CREATE TABLE sink_table ( order_number BIGINT, price DECIMAL(32,2)) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) ETL 逻辑： 123insert into sink_tableselect * from source_tablewhere order_number = 10 2.运行：可以看到，其实在 flink sql 任务中，其会把对应的处理逻辑给写到算子名称上面。 Notes - 观察 flink sql 技巧 1：这个其实就是我们观察 flink sql 任务的第一个技巧。如果你想知道你的 flink 任务在干啥，第一反应是去 flink webui 看看这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑 3.结果 123456789101112+I[10, 337546916355686018150362513408.00]+I[10, 734895198061906189720381030400.00]+I[10, 496632591763800912960818249728.00]+I[10, 495090465926828588045441171456.00]+I[10, 167305033642317182838130081792.00]+I[10, 409466913112794578407573684224.00]+I[10, 894352160414515330502514180096.00]+I[10, 680063350384451712068576346112.00]+I[10, 50807402446574997641386524672.00]+I[10, 646597093362022945955245981696.00]+I[10, 233317961584082024331537809408.00]... 4.原理： 先看一下一个 flink sql 任务的入口执行逻辑。 首先看看建表语句的执行和 query 语句执行的逻辑有什么不同。 可以发现执行到 executeInternal 时会针对具体的 operation 来执行不同的操作。 执行建表操作就是具体的 CreateTableOperation 时，会将表的信息保存到 catalogManager。 执行 query 操作就是具体的 ModifyOperation 时，会将对应的逻辑转换成对应的 Transformation。 Transformation 中就包含了执行的整体逻辑以及对应要执行的 sql 代码内容。 接下来我们详细看下对应的 transform 中包含了什么内容。 首先是最外层 LegacySinkTransformation，即 sink 算子，如图就是 print sink function。比较好理解。 然后是中间层 OneInputTransformation，即 sql 中过滤和转换操作（select * from source_table where order_number = 10），如图是代码生成的具体过滤和转换逻辑。 生成的代码就在 GeneratedOperator 中的 code 字段。我们将对应的 code 复制到一个新的文件夹中。 这个算子是直接继承了 OneInputStreamOperator 进行直接执行逻辑，跳过了 datastream 那一层。 我们来看看最重要的 processElement 逻辑，具体字段解释和执行逻辑如图所示。 Notes - 观察 flink sql 技巧 2：这个其实就是我们观察 flink sql 任务的第二个技巧。如果你想知道你的 flink 任务执行了什么代码，就去看看 sql 最后转换成的 transformation 里面具体要执行哪些操作。 4.2.2.去重场景1.场景：最简单的去重场景 源码公众号后台回复不会连最适合 flink sql 的 ETL 和 group agg 场景都没见过吧获取。 数据源： 1234567CREATE TABLE source_table ( string_field STRING) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.string_field.length&#x27; = &#x27;3&#x27;) 数据汇： 12345CREATE TABLE sink_table ( string_field STRING) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理： 123insert into sink_tableselect distinct string_fieldfrom source_table 2.运行：可以看到，其实在 flink sql 任务中，其会把对应的处理逻辑给写到算子名称上面。 3.上面这个案例的结果： 12345678910+I[cd3]+I[8fc]+I[b0c]+I[1d8]+I[e28]+I[c5f]+I[e7d]+I[dfa]+I[1fe]... 4.原理： 此处我们只关注和上面不同的逻辑。 第一个就是 PartitionTransform 中的 KeyGroupStreamPartitioner，就是对应的分区逻辑。来看看生成代码的逻辑。 其中做 shuffle 逻辑时，是按照 string_field 作为 key 进行 shuffle。 第二个就是 OneInputTransformation 中的 KeyedProcessOperator，就是对应的去重逻辑。 可以看到生成的 function 中只有这三段代码是业务逻辑代码，但是其中的 RowData 初始化大小都是 0。那么到底是哪里做的去重逻辑呢？ 我们跟一下处理逻辑会发现。去重逻辑主要集中在 GroupAggFunction#processElement。 4.2.3.group 聚合场景4.2.3.1.简单聚合场景1.场景：最简单的聚合场景 源码公众号后台回复不会连最适合 flink sql 的 ETL 和 group agg 场景都没见过吧获取。 count，sum，avg，max，min 等： 数据源： 12345678910CREATE TABLE source_table ( order_id STRING, price BIGINT) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.order_id.length&#x27; = &#x27;1&#x27;, &#x27;fields.price.min&#x27; = &#x27;1&#x27;, &#x27;fields.price.max&#x27; = &#x27;1000000&#x27;) 数据汇： 12345678910CREATE TABLE sink_table ( order_id STRING, count_result BIGINT, sum_result BIGINT, avg_result DOUBLE, min_result BIGINT, max_result BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理逻辑： 123456789insert into sink_tableselect order_id, count(*) as count_result, sum(price) as sum_result, avg(price) as avg_result, min(price) as min_result, max(price) as max_resultfrom source_tablegroup by order_id 2.运行： 3.上面这个案例的结果： 1234567891011121314+I[1, 1, 415300, 415300.0, 415300, 415300]+I[d, 1, 416878, 416878.0, 416878, 416878]+I[0, 1, 120837, 120837.0, 120837, 120837]+I[c, 1, 337749, 337749.0, 337749, 337749]+I[7, 1, 387053, 387053.0, 387053, 387053]+I[8, 1, 387042, 387042.0, 387042, 387042]+I[2, 1, 546317, 546317.0, 546317, 546317]+I[e, 1, 22131, 22131.0, 22131, 22131]+I[9, 1, 651731, 651731.0, 651731, 651731]-U[0, 1, 120837, 120837.0, 120837, 120837]+U[0, 2, 566664, 283332.0, 120837, 445827]+I[b, 1, 748659, 748659.0, 748659, 748659]-U[7, 1, 387053, 387053.0, 387053, 387053]+U[7, 2, 1058056, 529028.0, 387053, 671003] 4.原理： 来瞅一眼 transformation。 还是和之前的逻辑一样，跟一下 GroupAggFunction 的逻辑。如下图，有五个执行步骤执行计算。 再看最终生成的 function 代码逻辑。 首先看看 count 怎么算的。 sum 怎么算的。 4.2.3.2.去重聚合场景1.场景：去重聚合场景 数据源： 12345678910CREATE TABLE source_table ( dim STRING, user_id BIGINT) WITH ( &#x27;connector&#x27; = &#x27;datagen&#x27;, &#x27;rows-per-second&#x27; = &#x27;10&#x27;, &#x27;fields.dim.length&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.min&#x27; = &#x27;1&#x27;, &#x27;fields.user_id.max&#x27; = &#x27;1000000&#x27;) 数据汇： 123456CREATE TABLE sink_table ( dim STRING, uv BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理： 12345insert into sink_tableselect dim, count(distinct user_id) as uvfrom source_tablegroup by dim 2.运行： 3.上面这个案例的结果： 1234567891011+U[9, 3097]-U[a, 3054]+U[a, 3055]-U[8, 3030]+U[8, 3031]-U[4, 3137]+U[4, 3138]-U[6, 3139]+U[6, 3140]-U[0, 3082]+U[0, 3083] 4.原理： 此处只看和之前的案例不一样的地方。 4.2.3.3.语法糖1.grouping sets 多维计算。相当于语法糖，用户可以根据自己的场景去指定自己想要的维度组合。 数据汇： 1234567CREATE TABLE sink_table ( supplier_id STRING, product_id STRING, total BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理逻辑： 123456789101112insert into sink_tableSELECT supplier_id, product_id, COUNT(*) AS totalFROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY GROUPING SETS ((supplier_id, product_id), (supplier_id), ()) 其结果等同于： 1234567891011121314151617181920212223242526272829303132333435insert into sink_tableSELECT supplier_id, product_id, COUNT(*) AS totalFROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY supplier_id, product_idUNION ALLSELECT supplier_id, cast(null as string) as product_id, COUNT(*) AS totalFROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY supplier_idUNION ALLSELECT cast(null as string) AS supplier_id, cast(null as string) AS product_id, COUNT(*) AS totalFROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating) 结果如下： 1234567891011121314151617+I[supplier1, product1, 1]+I[supplier1, null, 1]+I[null, null, 1]+I[supplier1, product2, 1]-U[supplier1, null, 1]+U[supplier1, null, 2]-U[null, null, 1]+U[null, null, 2]+I[supplier2, product3, 1]+I[supplier2, null, 1]-U[null, null, 2]+U[null, null, 3]+I[supplier2, product4, 1]-U[supplier2, null, 1]+U[supplier2, null, 2]-U[null, null, 3]+U[null, null, 4] grouping sets 能帮助我们在多维场景下，减少很多冗余代码。关于 grouping sets 原理后面的系列文章会介绍。 2.rollup rollup 是上卷计算的一种简化写法。比如可以把 GROUPING SETS ((supplier_id, product_id), (supplier_id), ()) 简化为 ROLLUP (supplier_id, product_id)。 数据汇： 1234567CREATE TABLE sink_table ( supplier_id STRING, product_id STRING, total BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理逻辑： 12345678SELECT supplier_id, rating, COUNT(*)FROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY ROLLUP (supplier_id, product_id) 其结果等同于： 123456789101112SELECT supplier_id, rating, product_id, COUNT(*)FROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY GROUPING SET ( ( supplier_id, product_id ), ( supplier_id ), ( )) 结果如下： 1234567891011121314151617+I[supplier1, product1, 1]+I[supplier1, null, 1]+I[null, null, 1]+I[supplier1, product2, 1]-U[supplier1, null, 1]+U[supplier1, null, 2]-U[null, null, 1]+U[null, null, 2]+I[supplier2, product3, 1]+I[supplier2, null, 1]-U[null, null, 2]+U[null, null, 3]+I[supplier2, product4, 1]-U[supplier2, null, 1]+U[supplier2, null, 2]-U[null, null, 3]+U[null, null, 4] 5.CUBE 计算 源码公众号后台回复不会连最适合 flink sql 的 ETL 和 group agg 场景都没见过吧获取。 cube 相当于是一种覆盖了所有维度组合聚合计算。比如 group by a, b, c。其会将 a, b, c 三个维度的所有维度组合进行 group by。 数据汇： 1234567CREATE TABLE sink_table ( supplier_id STRING, product_id STRING, total BIGINT) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) 数据处理逻辑： 12345678SELECT supplier_id, rating, product_id, COUNT(*)FROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY CUBE (supplier_id, product_id) 它等同于 12345678910111213SELECT supplier_id, rating, product_id, COUNT(*)FROM (VALUES (&#x27;supplier1&#x27;, &#x27;product1&#x27;, 4), (&#x27;supplier1&#x27;, &#x27;product2&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product3&#x27;, 3), (&#x27;supplier2&#x27;, &#x27;product4&#x27;, 4))AS Products(supplier_id, product_id, rating)GROUP BY GROUPING SET ( ( supplier_id, product_id ), ( supplier_id ), ( product_id ), ( )) 结果如下： 123456789101112131415161718192021+I[supplier1, product1, 1]+I[supplier1, null, 1]+I[null, product1, 1]+I[null, null, 1]+I[supplier1, product2, 1]-U[supplier1, null, 1]+U[supplier1, null, 2]+I[null, product2, 1]-U[null, null, 1]+U[null, null, 2]+I[supplier2, product3, 1]+I[supplier2, null, 1]+I[null, product3, 1]-U[null, null, 2]+U[null, null, 3]+I[supplier2, product4, 1]-U[supplier2, null, 1]+U[supplier2, null, 2]+I[null, product4, 1]-U[null, null, 3]+U[null, null, 4] 5.总结与展望篇本文主要介绍了 ETL，group agg 聚合类指标的一些常见场景案例以及其底层运行原理。我们可以发现 flink sql 的语法其实和 hive sql，mysql 啥的语法都是基本一致的。所以上手 flink sql 时，语法基本不会成为我们的障碍。 而且也介绍了在查看 flink sql 任务时的一些技巧： 去 flink webui 看看这个任务目前在做什么。包括算子名称都会给直接展示给我们目前哪个算子在干啥事情，在处理啥逻辑。 如果你想知道你的 flink 任务执行了什么代码，就去看看 sql 最后转换成的 transformation 里面具体要执行哪些操作。 后续文章会继续介绍 flink sql 窗口聚合，一些理解误区，和坑之类的案例。 希望大家能持续关注。支持博主。喜欢的请关注 + 点赞 + 再看。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（六）：flink sql 约会 calcite","date":"2021-11-13T06:21:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/07_flink sql 知其所以然（六）：流批哄哄的 sql 语法解析器/","text":"感谢您的小爱心（关注 + 点赞 + 再看），对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构本文主要介绍 flink sql 与 calcite 之间的关系。flink sql 的解析主要依赖 calcite。 而博主通过此文抛砖引玉帮助大家理解 flink sql 在解析中是怎样依赖 calcite 的，以及 flink sql 解析的流程，sql parser 相关内容。希望对大家有所帮助。 本文通过以下几节进行介绍，对某个章节感兴趣的可以直接划到对应章节。 背景篇-一条 flink sql 的执行过程 发挥自己的想象力 看看 flink 的实现 简介篇-calcite 扮演的角色 calcite 是啥？ flink sql 为啥选择 calcite？ 案例篇-calcite 的能力、案例 先用用 calcite 关系代数 calcite 必知的基础 model calcite 的处理流程（以 flink sql 为例） calcite 怎么做到这么通用？ 原理剖析篇-calcite 在 flink sql 中大展身手 FlinkSqlParserImpl FlinkSqlParserImpl 的生成 总结与展望篇 2.背景篇-一条 flink sql 的执行过程本节先给大家大致描述一条 flink sql 的执行过程，不了解详细内容不要紧，主要先了解整个流程，有了全局视角之后，后续会详述细节。 在介绍一条 flink sql 的执行过程之前，先来看看 flink datastream 任务的执行过程，这对理解一条 flink sql 的执行过程有很大的帮助。 datastream：datastream 在使用时要在 flink datastream api 提供的各种 udf（比如 flatmap，keyedprocessfunction 等）中自定义处理逻辑，具体的业务执行逻辑都是敲代码、 java 文件写的，然后编译在 jvm 中执行，就和一个普通的 main 函数应用一模一样的流程。因为代码执行逻辑都是自己写的，所以这一部分相对好理解。 sql：java 编译器不能识别和编译一条 sql 进行执行，那么一条 SQL 是咋执行的呢？ 2.1.先发挥自己的想象力我们逆向思维进行考虑，如果想让一条 flink sql 按照我们的预期在 jvm 中执行，需要哪些过程。 整体来说：参考 datastream，如果 jvm 能执行 datastream java code 编译后的 class 文件，那么加一个 sql 解析层，能将 sql 逻辑解析为 datastream 的各种算子，然后编译执行不就 vans 了。 sql parser：首先得有一个 sql parser 吧，得先能识别 sql 语法，将 sql 语法转化为 AST、具体的关系代数。 关系代数到 datastream 算子的映射：sql 逻辑解析为 datastream，需要有一个解析的映射逻辑吧。sql 是基于关系代数的，可以维护一个 sql 中的每个关系代数到具体 datastream 接口的映射关系，有了这些映射关系我们就可以将 sql 映射成一段可执行的 datastream 代码。举个例子：其可以将： sql select xxx 解析为类似 datastream 中的 map where xxx 解析为 filter group by 解析成 keyby sum（xx），count（xxx）可以解析为 datastream 中的 aggregate function etc… 代码生成：有了 sql AST，sql 到 datasretam 算子的映射关系之后，就要进行具体的代码生成了。比如去解析 sql AST 中具体哪些字段用作 where 逻辑，哪些字段用作 group by，都需要生成对应具体的 datastream 代码。 运行：经过上述流程之后，就可以将一个 sql 翻译成一个 datastream 作业了，happy 的执行。 如下图所示，描绘了上述逻辑： 那么这个和 flink 实际实现有啥异同呢？ flink 大致是这样做的，虽在 flink 本身的中间还有一些其他的流程，后来的版本也不是基于 datastream，但是整体的处理逻辑还是和上述一致的。 所以不了解整体流程的同学可以先按照上述流程进行理解。 按照 博主的脑洞 来总结一条 sql 的使命就是：sql -&gt; AST -&gt; codegen(java code) -&gt; 让我们 run 起来好吗 2.2.看看 flink 的实现 上面手绘可能看不清，下面这张图更清楚。 标准的一条 flink sql 运行起来的流程如下： Notes：刚开始对其中的 SqlNode，RelNode 概念可能比较模糊。先理解整个流程，后续会详细介绍这些概念。 sql 解析阶段：calcite parser 解析（sql -&gt; AST，AST 即 SqlNode Tree） SqlNode 验证阶段：calcite validator 校验（SqlNode -&gt; SqlNode，语法、表达式、表信息） 语义分析阶段：SqlNode 转换为 RelNode，RelNode 即 Logical Plan（SqlNode -&gt; RelNode） 优化阶段：calcite optimizer 优化（RelNode -&gt; RelNode，剪枝、谓词下推等） 物理计划生成阶段：Logical Plan 转换为 Physical Plan（等同于 RelNode 转换成 DataSet\\DataStream API） 后续的运行逻辑与 datastream 一致 可以发现 flink 的实现 比 博主的脑洞 整体主要框架上面是一致的。多出来的部分主要是 SqlNode 验证阶段，优化阶段。 3.简介篇-calcite 在 flink sql 中的角色大致了解了 一条 flink sql 的运行流程 之后，我们来看看 calcite 这玩意到底在 flink 里干了些啥。 根据上文总结来说 calcite 在 flink sql 中担当了 sql 解析、验证、优化功能。 看着 calcite 干了这么多事，那 calcite 是个啥东东，它的定位是啥？ 3.1.calcite 是啥？calcite 是一个动态数据的管理框架，它可以用来构建数据库系统的不同的解析的模块，但是它不包含数据存储数据处理等功能。 calcite 的目标是一种方案，适应所有的需求场景，希望能为不同计算平台和数据源提供统一的 sql 解析引擎，但是它只是提供查询引擎，而没有真正的去存储这些数据。 下图是目前使用了 calcite 能力的其他组件，也可见官网 https://calcite.apache.org/docs/powered_by.html 。 简单来说的话，可以先理解为 calcite 具有这几个功能（当然还有其他很牛逼的功能，感兴趣可以自查官网）。 自定义 sql 解析器：比如说我们新发明了一个引擎，然后我们要在这个引擎上来创造一套基于 sql 的接口，那么我们就可以使用直接 calcite，不用自己去写一套专门的 sql 的解析器，以及执行以及优化引擎，calcite 人都有。 sql parser（extends SqlAbstractParserImpl）：将 sql 的各种关系代数解析为具体的 AST，这些 AST 都能对应到具体的 java model，在 java 的世界里面，对象很重要，有了这些对象（SqlSelect、SqlNode），就可以根据这些对象做具体逻辑处理了。举个例子，如下图，一条简单的 select c,d from source where a = &#39;6&#39; sql，经过 calcite 的解析之后，就可以得到 AST model（SqlNode）。可以看到有 SqlSelect、SqlIdentifier、SqlIdentifier、SqlCharStringLiteral。 sql validator（extends SqlValidatorImpl）：根据语法、表达式、表信息进行 SqlNode 正确性校验。 sql optimizer：剪枝、谓词下推等优化 上面的这些能力整体组成如下图所示： 实际使用 calcite 解析一条 sql，跑起来看看。 3.2.flink sql 为什么选择 calcite？ 不用重复造轮子。有限的精力应该放在有价值的事情上。 calcite 有针对 stream 表的解决方案。具体可见 https://calcite.apache.org/docs/stream.html。 4.案例篇-calcite 的能力、案例4.1.先用用 calcite重中之重，在了解原理之前，先跑起来是王道，也会帮助我们逐步理解。 官网已经有一个 csv 的案例了。感兴趣的可以直达 https://calcite.apache.org/docs/tutorial.html 。 跑完一个 csv demo，在详细了解 calcite 之前还需要了解下 sql，calcite 的支柱：关系代数。 4.2.关系代数sql 是基于关系代数的查询语言，是关系代数在工程上的一种很好的实现方案。在工程中，关系代数难表达，但是 sql 就易于理解。关系代数和 sql 的关系如下。 可以将一条 sql 解析为一个关系代数表达式的组合。在 sql 中的操作都可以转化成关系代数的表达式。 sql 的执行优化（所有的优化的前提都是优化前和优化后最终执行结果相同，即等价交换）是基于关系代数运算的。 4.2.1.常用关系代数总结下，有哪些常用的关系代数： 4.2.2.sql 优化支柱之关系代数等价变换关系代数等价变换是 calcite optimizer 的基础理论。 下面是一些等价变换的例子。 1.连接（⋈），笛卡尔积（×）的交换律 2.连接（⋈），笛卡尔积（×）的结合律 3.投影（Π）的串接定律 4.选择（σ）的串接定律 5.选择（σ）与投影（Π）的交换 6.选择（σ）与笛卡尔积（×）的交换 7.选择（σ）与并（∪）的交换 8.选择（σ）与差（-）的交换 9.投影（Π）与笛卡尔积（×）的交换 10.投影（Π）与并（∪）的交换 然后看一个基于关系代数优化的实际 sql 案例： 有三个关系 A（a1,a2,a3,…）、B（b1,b2,b3, … ）、C（a1,b1,c1,c2, … ） 有一个查询请求如下： SELECT A.a1 FROM A，B，C WHERE A.a1 = C.a1 AND B.b1 = C.b1 AND f(c1) 1.首先将 sql 转为关系代数的语法树。 2.优化：选择（σ）的串接定律。 3.优化：选择（σ）与笛卡尔积（×）的交换。 4.优化：投影（π）与笛卡尔积（×）的交换。 关于关系代数我们就有了大致的了解。 除此之外，对于更深入了解 flink sql，calcite 而言，我们还需要了解一下在 calcite 代码体系中有哪些重要 model。 4.3.calcite 必知的基础 modelcalcite 中有两个最最基础、重要的 model 在我们理解 flink sql 解析流程时需要知道的。 SqlNode：sql 转化而成，可以理解为直观表达 sql 层次结构的的 model RelNode：SqlNode 转化而成，可以理解为将 SqlNode 转化为关系代数，表达关系代数层次结构的 model 举个例子来说明下，下面这条 flink sql，经过解析之后的 SqlNode，RelNode 如下图： 123456789101112131415SELECT sum(part_pv) as pv, window_startFROM ( SELECT count(1) as part_pv, cast(tumble_start(rowtime, INTERVAL &#x27;60&#x27; SECOND) as bigint) * 1000 as window_start FROM source_db.source_table GROUP BY tumble(rowtime, INTERVAL &#x27;60&#x27; SECOND) , mod(id, 1024))GROUP BY window_start 可以看到 SqlNode 包含的内容是 sql 的层次结构，包括 selectList，from，where，group by 等。 RelNode 包含的是关系代数的层次结构，每一层都有一个 input 来承接。结合上面优化案例的树状结构一样。 4.4.calcite 的处理流程（以 flink sql 为例） 如上图所示，此处我们结合上节介绍的 calcite 的 model，以及 flink sql 的实现来走一遍其处理流程： sql 解析阶段（sql –&gt; SqlNode） SqlNode 验证（SqlNode –&gt; SqlNode） 语义分析（SqlNode –&gt; RelNode） 优化阶段（RelNode –&gt; RelNode） 4.4.1.flink sql demo123456789101112131415SELECT sum(part_pv) as pv, window_startFROM ( SELECT count(1) as part_pv, cast(tumble_start(rowtime, INTERVAL &#x27;60&#x27; SECOND) as bigint) * 1000 as window_start FROM source_db.source_table GROUP BY tumble(rowtime, INTERVAL &#x27;60&#x27; SECOND) , mod(id, 1024))GROUP BY window_start 其中前三步解析和转化，都在 在执行 TableEnvironment#sqlQuery 进行。 最后一步优化，在执行 sink 操作时进行，即在这个例子中是 tEnv.toRetractStream(result, Row.class)。 源码公众号后台回复flink sql 知其所以然（六）| flink sql 约会 calcite获取。 4.4.2.sql 解析阶段（sql –&gt; SqlNode）sql 解析阶段使用 Sql Parser 将 sql 解析为 SqlNode。这一步在执行 TableEnvironment#sqlQuery 进行。 可以从上图看到 flink sql 具体实现类是 FlinkSqlParserImpl。 具体 parse 得到 SqlNode 如上图。 4.4.3.SqlNode 验证（SqlNode –&gt; SqlNode）上面的第一步生产的 SqlNode 对象是一个未经验证的，这一步就是语法检查阶段，语法检查前需要知道元数据信息，这个检查会包括表名、字段名、函数名、数据类型的检查。进行语法检查的实现如下： 可以从上图看到 flink sql 校验器的具体实现类是 FlinkCalciteSqlValidator，其中包含了元数据信息，从而可以进行元数据信息检查。 4.4.4.语义分析（SqlNode –&gt; RelNode）这一步就是将 SqlNode 转换成 RelNode，也就是生成相应的关系代数层面的逻辑（这里一般都叫做逻辑计划：Logical Plan）。 4.4.5.优化阶段（RelNode –&gt; RelNode）这一步就是优化阶段。详细内容可以自己 debug 代码查看，此处不赘述。 4.5.calcite 怎么做到这么通用？此处以 calcite parser 举例说明，其模块为什么这通用？其他的模块都是类似的方式。 先说结论：因为 calcite parser 模块提供了接口，具体的 parse 逻辑、规则是可以根据用户自定义进行配置的。大家可以看下图，博主画出了一张图进行详述。 如上图，引擎 sql 解析器的生成是有一个输入的，就是 用户自定义语法分析规则变量，具体引擎的 sql 解析器其实也是根据用户自定义的 解析规则 去生成的 解析器。其 解析器 的动态生成依赖 javacc 这样的组件。calcite 提供的是统一的 sql AST 模型、优化模型接口等，而具体的解析实现交给了用户自己去决定。 javacc 会根据 calcite 中定义的 Parser.jj 文件，生成具体的 sql parser 代码（如上图），这个 sql parser 的能力就是将 sql 转换成 AST （SqlNode）。关于 calcite 能力的更详细内容见 https://matt33.com/2019/03/07/apache-calcite-process-flow/ 。 上图涉及到的文件大家可以下载 calcite 源码 https://github.com/apache/calcite.git 之后，切换到 core module 之后查看。 4.5.1.javacc 是啥？javacc 是一个用 java 开发的最受欢迎的语法分析生成器。这个分析生成器工具可以读取上下文无关且有着特殊意义的语法并把它转换成可以识别且匹配该语法的 java 程序。它是 100% 的纯 java 代码，可以在多种平台上运行。 简单解释 javacc 就是它是一个通用的语法分析生产器，用户可以使用 javacc 任意定义一套 DSL 及解析器。 举个例子，如果哪天你觉得 sql 也不够简洁通用，你可以使用 javacc 自己定义一套更简洁的 user-define-ql。然后使用 javacc 作为你的 user-define-ql 的解析器。是不是很流批，可以自己去搞编译器了。 4.5.2.跑跑 javacc这里不介绍具体的 javacc 语法，直接以官网的 Simple1.jj 为案例。详细语法和功能可以参考官网（https://javacc.github.io/javacc/） 或者一下博客。 https://www.cnblogs.com/Gavin_Liu/archive/2009/03/07/1405029.html https://www.yangguo.info/2014/12/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Javacc%E4%BD%BF%E7%94%A8/ https://www.engr.mun.ca/~theo/JavaCC-Tutorial/javacc-tutorial.pdf Simple1.jj 是用于识别一系列的 &#123;相同数量的花括号&#125;，之后跟着 0 个或多个行终结符。 下面是合法的字符串例子： &#123;&#125;，&#123;&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;&#125;，etc. 下面是不合法的字符串例子： &#123;&#123;&#123;&#123;`，`&#123;&#125;&#123;&#125;`，`&#123;&#125;&#125;，&#123;&#123;&#125;&#123;&#125;&#125;，etc. 接下来让我们实际将 Simple1.jj 编译生成具体的规则代码。 在 pom 中加入 javacc build 插件： 12345678910111213141516171819202122232425&lt;plugin&gt; &lt;!-- This must be run AFTER the fmpp-maven-plugin --&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;javacc-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;id&gt;javacc&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;javacc&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirectory&gt;$&#123;project.build.directory&#125;/generated-sources/&lt;/sourceDirectory&gt; &lt;includes&gt; &lt;include&gt;**/Simple1.jj&lt;/include&gt; &lt;/includes&gt; &lt;!-- This must be kept synced with Apache Calcite. --&gt; &lt;lookAhead&gt;1&lt;/lookAhead&gt; &lt;isStatic&gt;false&lt;/isStatic&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/generated-sources/&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在 compile 之后，就会在 generated-sources 下生成代码： 然后把代码 copy 到 Sources 路径下： 执行下代码，可以看到 &#123;&#125;，&#123;&#123;&#125;&#125; 都可以校验通过，一旦出现不符合规则的 &#123;&#123; 输入，就会抛出异常。 关于 javacc 基本上就了解个大概了。 感兴趣的可以尝试自定义一个编译器。 4.5.3.fmpp 是啥？ fmpp 就是一个基于 freemarker 的模板生产器。用户可以统一管理自己的变量，然后用 ftl 模板 + 变量 生成对应的最终文件。在 calcite 中使用 fmpp 作为变量 + 模板的统一管理器。然后基于 fmpp 来生成对应的 Parser.jj 文件。 5.原理剖析篇-calcite 在 flink sql 中大展身手博主画了一张图，包含了其中重要组件之间的依赖关系。 你没猜错，还是上面那些流程，fmpp（Parser.jj 模板生成） -&gt; javacc（Parser 生成） -&gt; calcite。 在介绍 Parser 生成流程之前，先看看 flink 最终生成的 Parser：FlinkSqlParserImpl （此处使用 Blink Planner）。 5.1.FlinkSqlParserImpl以下面这个案例出发（代码基于 flink 1.13.1 版本）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ParserTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(10); EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode() .build(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings); DataStream&lt;Tuple3&lt;String, Long, Long&gt;&gt; tuple3DataStream = env.fromCollection(Arrays.asList( Tuple3.of(&quot;2&quot;, 1L, 1627254000000L), Tuple3.of(&quot;2&quot;, 1L, 1627218000000L + 5000L), Tuple3.of(&quot;2&quot;, 101L, 1627218000000L + 6000L), Tuple3.of(&quot;2&quot;, 201L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 86400000 + 7000L))) .assignTimestampsAndWatermarks( new BoundedOutOfOrdernessTimestampExtractor&lt;Tuple3&lt;String, Long, Long&gt;&gt;(Time.seconds(0L)) &#123; @Override public long extractTimestamp(Tuple3&lt;String, Long, Long&gt; element) &#123; return element.f2; &#125; &#125;); tEnv.registerFunction(&quot;mod&quot;, new Mod_UDF()); tEnv.registerFunction(&quot;status_mapper&quot;, new StatusMapper_UDF()); tEnv.createTemporaryView(&quot;source_db.source_table&quot;, tuple3DataStream, &quot;status, id, timestamp, rowtime.rowtime&quot;); String sql = &quot;SELECT\\n&quot; + &quot; count(1),\\n&quot; + &quot; cast(tumble_start(rowtime, INTERVAL &#x27;1&#x27; DAY) as string)\\n&quot; + &quot;FROM\\n&quot; + &quot; source_db.source_table\\n&quot; + &quot;GROUP BY\\n&quot; + &quot; tumble(rowtime, INTERVAL &#x27;1&#x27; DAY)&quot;; Table result = tEnv.sqlQuery(sql); tEnv.toAppendStream(result, Row.class).print(); env.execute(); &#125;&#125; debug 过程如之前分析 sql -&gt; SqlNode 过程所示，如下图直接定位到 SqlParser： 如上图可以看到具体的 Parser 就是 FlinkSqlParserImpl。 定位到具体的代码如下图所示（flink-table-palnner-blink-2.11-1.13.1.jar）。 最终 parse 的结果 SqlNode 如下图。 再来看看 FlinkSqlParserImpl 是怎么使用 calcite 生成的。 具体到 flink 中的实现，位于源码中的 flink-table.flink-sql-parser 模块（源码基于 flink 1.13.1）。 flink 是依赖 maven 插件实现的上面的整体流程。 5.2.FlinkSqlParserImpl 的生成 接下来看看整个 Parser 生成流程。 5.2.1.flink 引入 calcite使用 maven-dependency-plugin 将 calcite 解压到 flink 项目 build 目录下。 123456789101112131415161718192021222324252627&lt;plugin&gt; &lt;!-- Extract parser grammar template from calcite-core.jar and put it under $&#123;project.build.directory&#125; where all freemarker templates are. --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack-parser-template&lt;/id&gt; &lt;phase&gt;initialize&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.apache.calcite&lt;/groupId&gt; &lt;artifactId&gt;calcite-core&lt;/artifactId&gt; &lt;type&gt;jar&lt;/type&gt; &lt;overWrite&gt;true&lt;/overWrite&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/&lt;/outputDirectory&gt; &lt;includes&gt;**/Parser.jj&lt;/includes&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 5.2.2.fmpp 生成 Parser.jj使用 maven-resources-plugin 将 Parser.jj 代码生成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-fmpp-resources&lt;/id&gt; &lt;phase&gt;initialize&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/codegen&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/codegen&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;com.googlecode.fmpp-maven-plugin&lt;/groupId&gt; &lt;artifactId&gt;fmpp-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-fmpp-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;cfgFile&gt;$&#123;project.build.directory&#125;/codegen/config.fmpp&lt;/cfgFile&gt; &lt;outputDirectory&gt;target/generated-sources&lt;/outputDirectory&gt; &lt;templateDirectory&gt;$&#123;project.build.directory&#125;/codegen/templates&lt;/templateDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 5.2.3.javacc 生成 parser使用 javacc 将根据 Parser.jj 文件生成 Parser。 12345678910111213141516171819202122232425&lt;plugin&gt; &lt;!-- This must be run AFTER the fmpp-maven-plugin --&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;javacc-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;id&gt;javacc&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;javacc&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirectory&gt;$&#123;project.build.directory&#125;/generated-sources/&lt;/sourceDirectory&gt; &lt;includes&gt; &lt;include&gt;**/Parser.jj&lt;/include&gt; &lt;/includes&gt; &lt;!-- This must be kept synced with Apache Calcite. --&gt; &lt;lookAhead&gt;1&lt;/lookAhead&gt; &lt;isStatic&gt;false&lt;/isStatic&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/generated-sources/&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 5.2.4.看看 Parser最终生成的 Parser 就是 FlinkSqlParserImpl。 5.2.5.blink planner 引入 flink-sql-parserblink planner（flink-table-planner-blink） 在打包时将 flink-sql-parser、flink-sql-parser-hive 打包进去。 6.总结与展望篇本文主要介绍了 flink sql 与 calcite 之间的依赖关系，以及 flink sql parser 的生成过程。如果觉得对你理解 flink sql 解析有帮助，帮忙点个小爱心（关注 + 点赞 + 再看）三连吧。 7.参考文献https://www.slideshare.net/JordanHalterman/introduction-to-apache-calcite https://arxiv.org/pdf/1802.10233.pdf https://changbo.tech/blog/7dec2e4.html http://www.liaojiayi.com/calcite/ https://www.zhihu.com/column/c_1110245426124554240 https://blog.csdn.net/QuinnNorris/article/details/70739094 https://www.pianshen.com/article/72171186489/ https://matt33.com/2019/03/07/apache-calcite-process-flow/ https://www.jianshu.com/p/edf503a2a1e7 https://blog.csdn.net/u013007900/article/details/78978271 https://blog.csdn.net/u013007900/article/details/78993101 http://www.ptbird.cn/optimization-of-relational-algebraic-expression.html https://book.51cto.com/art/201306/400084.htm https://book.51cto.com/art/201306/400085.htm https://miaowenting.site/2019/11/10/Flink-SQL-with-Calcite/","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"踩坑记| flink state 序列化 java enum 竟然岔劈了","date":"2021-11-13T06:21:58.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/02_flink-datastream/01_踩坑记|flinkstate序列化javaenum竟然岔劈了/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-先说结论本文主要记录博主在生产环境中踩的 flink 针对 java enum serde 时的坑。 结论：在 flink 程序中，如果状态中有存储 java enum，那么添加或者删除 enum 中的一个枚举值时，就有可能导致状态恢复异常，这里的异常可能不是在恢复过程中会实际抛出一个异常，而是有可能是 enum A 的值恢复给 enum B。 我从以下几个章节说明、解决这个问题，希望能抛砖引玉，带给大家一些启发。 踩坑场景篇-这个坑是啥样的 问题排查篇-坑的排查过程 问题原理解析篇-导致问题的机制是什么 避坑篇-如何避免这种问题 总结篇 2.踩坑场景篇-这个坑是啥样的对任务做一个简单的过滤条件修改，任务重新上线之后，从 flink web ui 确认是从 savepoint 重启成功了，但是实际最终产出的数据上来看却像是没有从 savepoint 重启。 逻辑就是计算分维度的当天累计 pv。代码很简单，在后面会贴出来。 如下图： 在 00:04 分重启时出现了当天累计 pv 出现了从零累计的情况。 但是预期正常的曲线应该张下面这样。 任务是使用 DataStream 编写（基于 flink 1.13.1）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class SenerioTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); env.setParallelism(1); env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime); env.addSource(new SourceFunction&lt;SourceModel&gt;() &#123; private volatile boolean isCancel = false; @Override public void run(SourceContext&lt;SourceModel&gt; ctx) throws Exception &#123; // 数据源 &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; &#125;) .keyBy(new KeySelector&lt;SourceModel, Long&gt;() &#123; @Override public Long getKey(SourceModel value) throws Exception &#123; return value.getUserId() % 1000; &#125; &#125;) .timeWindow(Time.minutes(1)) .aggregate( new AggregateFunction&lt;SourceModel, Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;, Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;&gt;() &#123; @Override public Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; createAccumulator() &#123; return new HashMap&lt;&gt;(); &#125; @Override public Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; add(SourceModel value, Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; accumulator) &#123; Lists.newArrayList(Tuple2.of(DimNameEnum.province, value.getProvince()) , Tuple2.of(DimNameEnum.age, value.getAge()) , Tuple2.of(DimNameEnum.sex, value.getSex())) .forEach(t -&gt; &#123; Long l = accumulator.get(t); if (null == l) &#123; accumulator.put(t, 1L); &#125; else &#123; accumulator.put(t, l + 1); &#125; &#125;); return accumulator; &#125; @Override public Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; getResult( Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; accumulator) &#123; return accumulator; &#125; @Override public Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; merge( Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; a, Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt; b) &#123; return null; &#125; &#125;, new ProcessWindowFunction&lt;Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;, SinkModel, Long, TimeWindow&gt;() &#123; private transient ValueState&lt;Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;&gt; todayPv; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.todayPv = getRuntimeContext().getState(new ValueStateDescriptor&lt;Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;&gt;( &quot;todayPv&quot;, TypeInformation.of( new TypeHint&lt;Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;&gt;() &#123; &#125;))); &#125; @Override public void process(Long aLong, Context context, Iterable&lt;Map&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;&gt; elements, Collector&lt;SinkModel&gt; out) throws Exception &#123; // 将 elements 数据 merge 到 todayPv 中 // 每天零点将 state 清空重新累计 // 然后 out#collect 出去即可 &#125; &#125;); env.execute(); &#125; @Data @Builder private static class SourceModel &#123; private long userId; private String province; private String age; private String sex; private long timestamp; &#125; @Data @Builder private static class SinkModel &#123; private String dimName; private String dimValue; private long timestamp; &#125; enum DimNameEnum &#123; province, age, sex, ; &#125;&#125; 3.问题排查篇-坑的排查过程3.1.愚蠢的怀疑引擎首先怀疑是状态没有正常恢复。 但是查看 flink web ui 以及 tm 日志，都显示是从 savepoint 正常恢复了。 还怀疑是不是出现了 flink web ui 展示的内容和实际的执行不一致的情况。 但是发现任务的 ck 大小是正常的，复合预期的。 3.2.老老实实打 log 吧既然能从 savepoint 正常恢复，那么就把状态值用 log 打出来看看到底发生了什么事情呗。 如下列代码，在 ProcessWindowFunction 中加上 log 日志。 12345678this.todayPv.value() .forEach(new BiConsumer&lt;Tuple2&lt;DimNameEnum, String&gt;, Long&gt;() &#123; @Override public void accept(Tuple2&lt;DimNameEnum, String&gt; k, Long v) &#123; log.info(&quot;key 值：&#123;&#125;，value 值：&#123;&#125;&quot;, k.toString(), v); &#125; &#125;); 发现结果如下： 123...key 值：(uv_type,男)，value 值：1000... 发现状态中存储的 DimNameEnum.province，DimNameEnum.age 的数据都是正确的，但是缺缺少了 DimNameEnum.sex，多了 (uv_type,男) 这样的数据，于是查看代码，发现之前多加了一种枚举类型 DimNameEnum.uv_type。代码如下： 1234567enum DimNameEnum &#123; province, age, uv_type, sex, ;&#125; 于是怀疑 flink 针对枚举值的 serde 不是按照枚举值名称来进行匹配的，而是按照枚举值下标来进行匹配的。因此就出现了 DimNameEnum.uv_type 将 DimNameEnum.sex 的位置占了的情况。 4.问题原理解析篇-导致问题的机制是什么来看看源码吧。 测试代码如下： 12345678910111213141516171819202122232425262728public class EnumsStateTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); env.setParallelism(1); env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime); TypeInformation&lt;StateTestEnums&gt; t = TypeInformation.of(StateTestEnums.class); EnumSerializer&lt;StateTestEnums&gt; e = (EnumSerializer&lt;StateTestEnums&gt;) t.createSerializer(env.getConfig()); DataOutputSerializer d = new DataOutputSerializer(10000); e.serialize(StateTestEnums.A, d); env.execute(); &#125; enum StateTestEnums &#123; A, B, C ; &#125;&#125; debug 结果如下： 首先看看对应的 TypeInformation 和 TypeSerializer。 发现 enum 类型的序列化器是 EnumSerializer， 看看 EnumSerializer 的 serde 实现，如图所示： 最关键的两个变量： 序列化时用 valueToOrdinal 反序列化时用 values 从而印证了上面的说法。flink enum 序列化时使用的是枚举值下标进行 serde，因此一旦枚举值顺序发生改变，或者添加、删除一个枚举值，就会导致其他枚举值的下标出现错位的情况。从而导致数据错误。 5.避坑篇-如何避免这种问题5.1.枚举解决在上述场景中，如果又想要把新枚举值加进去，又需要状态能够正常恢复，正常产出数据。 那么可以把新的枚举值在尾部添加，比如下面这样。 1234567enum DimNameEnum &#123; province, age, sex, uv_type, // 添加在尾部 ;&#125; 5.2.非枚举解决还有一种方法如标题，就是别用枚举值，直接用 string 就 vans 了。 6.总结篇本文主要介绍了 flink 枚举值 serde 中的坑，当在 enum 中添加删除枚举值时，就有可能导致状态岔劈。随后给出了原因是由于 enum serde 器的实现导致的这种情况，最后给出了解决方案。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（五）| 自定义 protobuf format","date":"2021-11-13T06:21:57.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/06_flinksql知其所以然（五）：sql自定义protobuf_format/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构protobuf 作为目前各大公司中最广泛使用的高效的协议数据交换格式工具库，会大量作为流式数据传输的序列化方式，所以在 flink sql 中如果能实现 protobuf 的 format 会非常有用（目前社区已经有对应的实现，不过目前还没有 merge，预计在 1.14 系列版本中能 release）。 issue 见：https://issues.apache.org/jira/browse/FLINK-18202?filter=-4&amp;jql=project%20%3D%20FLINK%20AND%20issuetype%20%3D%20%22New%20Feature%22%20AND%20text%20~%20protobuf%20order%20by%20created%20DESC pr 见：https://github.com/apache/flink/pull/14376 这一节主要介绍 flink sql 中怎么自定义实现 format，其中以最常使用的 protobuf 作为案例来介绍。 背景篇-为啥需要 protobuf format 目标篇-protobuf format 预期效果 难点剖析篇-此框架建设的难点、目前有哪些实现 维表实现篇-实现的过程 总结与展望篇 如果想在本地直接测试下： 在公众号后台回复 flink sql 知其所以然（五）| sql 自定义 protobuf format获取源码（源码基于 1.13.1 实现） flink sql 知其所以然（五）| sql 自定义 protobuf format获取源码（源码基于 1.13.1 实现） flink sql 知其所以然（五）| sql 自定义 protobuf format获取源码（源码基于 1.13.1 实现） 执行源码包中的 flink.examples.sql._05.format.formats.SocketWriteTest 测试类来制造 protobuf 数据 然后执行源码包中的 flink.examples.sql._05.format.formats.ProtobufFormatTest 测试类来消费 protobuf 数据，并且打印在 console 中，然后就可以在 console 中看到结果。 2.背景篇-为啥需要 protobuf format关于为什么选择 protobuf 可以看这篇文章，写的很详细： http://hengyunabc.github.io/thinking-about-grpc-protobuf/?utm_source=tuicool&amp;utm_medium=referral 在实时计算的领域中，为了可读性会选择 json，为了效率以及一些已经依赖了 grpc 的公司会选择 protobuf 来做数据序列化，那么自然而然，日志的序列化方式也会选择 protobuf。 而官方目前已经 release 的版本中是没有提供 flink sql api 的 protobuf format 的。如下图，基于 1.13 版本。 https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/connectors/table/overview/ 因此本文在介绍怎样自定义一个 format 的同时，实现一个 protobuf format 来给大家使用。 3.目标篇-protobuf format 预期效果预期效果是先实现几种最基本的数据类型，包括 protobuf 中的 message（自定义 model）、map（映射）、repeated（列表）、其他基本数据类型等，这些都是我们最常使用的类型。 预期 protobuf message 定义如下： 测试数据源数据如下，博主把 protobuf 的数据转换为 json，以方便展示，如下图： 预期 flink sql： 数据源表 DDL： 123456789101112CREATE TABLE protobuf_source ( name STRING , names ARRAY&lt;STRING&gt; , si_map MAP&lt;STRING, INT&gt;)WITH ( &#x27;connector&#x27; = &#x27;socket&#x27;, &#x27;hostname&#x27; = &#x27;localhost&#x27;, &#x27;port&#x27; = &#x27;9999&#x27;, &#x27;format&#x27; = &#x27;protobuf&#x27;, &#x27;protobuf.class-name&#x27; = &#x27;flink.examples.sql._04.format.formats.protobuf.Test&#x27;) 数据汇表 DDL： 1234567CREATE TABLE print_sink ( name STRING , names ARRAY&lt;STRING&gt; , si_map MAP&lt;STRING, INT&gt;) WITH ( &#x27;connector&#x27; = &#x27;print&#x27;) Transform 执行逻辑： 123INSERT INTO print_sinkSELECT *FROM protobuf_source 下面是我在本地跑的结果： 可以看到打印的结果，数据是正确的被反序列化读入，并且最终输出到 console。 4.难点剖析篇-目前有哪些实现目前业界可以参考的实现如下：https://github.com/maosuhan/flink-pb， 也就是这位哥们负责目前 flink protobuf 的 format。 这种实现的具体使用方式如下： 其实现有几个特点： 复杂性：用户需要在 flink sql 程序运行时，将对应的 protobuf java 文件引入 classpath，这个特点是复合 flink 这样的通用框架的特点的。但是如果需要在各个公司场景要做一个流式处理平台的场景下，各个 protobuf sdk 可能都位于不同的 jar 包中，那么其 jar 包管理可能是一个比较大的问题。 高效 serde：一般很多场景下为了通用化 serde protobuf message，可能会选择 DynamicMessage 来处理 protobuf message，但是其 serde 性能相比原生 java code 的性能比较差。因为特点 1 引入了 protobuf 的 java class，所以其 serde function 可以基于 codegen 实现，而这将极大提高 serde 效率，效率提高就代表着省钱啊，可以吹逼的。 Notes： 当然博主针对第一点也有一些想法，比如怎样做到不依赖 protobuf java 文件，只依赖 protobuf 的 message 定义即可或者只依赖其 descriptor。目前博主的想法如下： flink 程序在客户端获取到对应的 protobuf message 定义 然后根据这个定义恢复出 proto 文件 客户端本地执行 protoc 将此文件编译为 java 文件 客户端本地动态将此 java 文件编译并 load 到 jvm 中 使用 codegen 然后动态生成执行代码 一气呵成！！！ 具体实现其实可以参考：https://stackoverflow.com/questions/28381659/how-to-compile-protocol-buffers-schema-at-runtime 5.实现篇-实现的过程5.1.flink format 工作原理其实上节已经详细描述了 flink sql 对于 source\\sink\\format 的加载机制。 通过 SPI 机制加载所有的 source\\sink\\format 工厂 Factory 过滤出 DeserializationFormatFactory\\SerializationFormatFactory + format 标识的 format 工厂类 通过 format 工厂类创建出对应的 format 如图 serde format 是通过 TableFactoryHelper.discoverDecodingFormat 和 TableFactoryHelper.discoverEncodingFormat 创建的 12345678// either implement your custom validation logic here ... // or use the provided helper utilityfinal FactoryUtil.TableFactoryHelper helper = FactoryUtil.createTableFactoryHelper(this, context);// discover a suitable decoding formatfinal DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt; decodingFormat = helper.discoverDecodingFormat( DeserializationFormatFactory.class, FactoryUtil.FORMAT); 所有通过 SPI 的 source\\sink\\formt 插件都继承自 Factory。 整体创建 format 方法的调用链如下图。 5.2.flink protobuf format 实现最终实现如下，涉及到了几个实现类： ProtobufFormatFactory ProtobufOptions ProtobufRowDataDeserializationSchema ProtobufToRowDataConverters 具体流程： 定义 SPI 的工厂类 ProtobufFormatFactory implements DeserializationFormatFactory，并且在 resource\\META-INF 下创建 SPI 的插件文件 实现 ProtobufFormatFactory#factoryIdentifier 标识 protobuf 实现 ProtobufFormatFactory#createDecodingFormat 来创建对应的 DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt;，DecodingFormat 是用来封装具体的反序列化器的，实现 DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt;#createRuntimeDecoder，返回 ProtobufRowDataDeserializationSchema 定义 ProtobufRowDataDeserializationSchema implements DeserializationSchema&lt;RowData&gt;，这个就是具体的反序列化器，其实与 datastream api 相同 实现 ProtobufRowDataDeserializationSchema#deserialize 方法，与 datastream 相同，这个方法就是将 byte[] 序列化为 RowData 的具体逻辑 注意这里还实现了一个类 ProtobufToRowDataConverters，其作用就是在客户端创建出具体的将 byte[] 序列化为 RowData 的具体工具类，其会根据用户定义的表字段类型动态生成数据转换的 converter 类（策略模式：https://www.runoob.com/design-pattern/strategy-pattern.html），相当于表的 schema 确定之后，其 converter 也会确定 上述实现类的具体关系如下： 介绍完流程，进入具体实现方案细节： ProtobufFormatFactory 主要创建 format 的逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ProtobufFormatFactory implements DeserializationFormatFactory &#123; public static final String IDENTIFIER = &quot;protobuf&quot;; @Override public DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt; createDecodingFormat(Context context, ReadableConfig formatOptions) &#123; FactoryUtil.validateFactoryOptions(this, formatOptions); // 1.获取到 protobuf 的 class 全路径 final String className = formatOptions.get(PROTOBUF_CLASS_NAME); try &#123; // 2.load class Class&lt;GeneratedMessageV3&gt; protobufV3 = (Class&lt;GeneratedMessageV3&gt;) this.getClass().getClassLoader().loadClass(className); // 3.创建 DecodingFormat return new DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt;() &#123; @Override public DeserializationSchema&lt;RowData&gt; createRuntimeDecoder(DynamicTableSource.Context context, DataType physicalDataType) &#123; // 4.获取到 table schema rowtype final RowType rowType = (RowType) physicalDataType.getLogicalType(); // 5.创建对应的 DeserializationSchema 作为反序列化器 return new ProtobufRowDataDeserializationSchema( protobufV3 , true , rowType); &#125; @Override public ChangelogMode getChangelogMode() &#123; return ChangelogMode.insertOnly(); &#125; &#125;; &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public String factoryIdentifier() &#123; return IDENTIFIER; &#125; ...&#125; resources\\META-INF 文件： ProtobufRowDataDeserializationSchema 主要实现反序列化的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ProtobufRowDataDeserializationSchema extends AbstractDeserializationSchema&lt;RowData&gt; &#123; ... private ProtobufToRowDataConverters.ProtobufToRowDataConverter runtimeConverter; public ProtobufRowDataDeserializationSchema( Class&lt;? extends GeneratedMessageV3&gt; messageClazz , boolean ignoreParseErrors , RowType expectedResultType) &#123; this.ignoreParseErrors = ignoreParseErrors; Preconditions.checkNotNull(messageClazz, &quot;Protobuf message class must not be null.&quot;); this.messageClazz = messageClazz; this.descriptorBytes = null; this.descriptor = ProtobufUtils.getDescriptor(messageClazz); this.defaultInstance = ProtobufUtils.getDefaultInstance(messageClazz); // protobuf 本身的 schema this.protobufOriginalRowType = (RowType) ProtobufSchemaConverter.convertToRowDataTypeInfo(messageClazz); this.expectedResultType = expectedResultType; // 1.根据 table schema 动态创建出对应的反序列化器 this.runtimeConverter = new ProtobufToRowDataConverters(false) .createRowDataConverterByLogicalType(this.descriptor, this.expectedResultType); &#125; @Override public RowData deserialize(byte[] bytes) throws IOException &#123; if (bytes == null) &#123; return null; &#125; try &#123; // 2.将 bytes 反序列化为 protobuf message Message message = this.defaultInstance .newBuilderForType() .mergeFrom(bytes) .build(); // 3.反序列化逻辑，从 protobuf message 中获取字段转换为 RowData return (RowData) runtimeConverter.convert(message); &#125; catch (Throwable t) &#123; if (ignoreParseErrors) &#123; return null; &#125; throw new IOException( format(&quot;Failed to deserialize Protobuf &#x27;%s&#x27;.&quot;, new String(bytes)), t); &#125; &#125; ... 可以注意到上述反序列化的主要逻辑就集中在 runtimeConverter 上，即 ProtobufToRowDataConverters.ProtobufToRowDataConverter。 ProtobufToRowDataConverters.ProtobufToRowDataConverter 就是在 ProtobufToRowDataConverters 中定义的。 ProtobufToRowDataConverters.ProtobufToRowDataConverter 其实就是一个 convertor 接口： 1234@FunctionalInterfacepublic interface ProtobufToRowDataConverter extends Serializable &#123; Object convert(Object object);&#125; 其作用就是将 protobuf message 中的每一个字段转换成为 RowData 中的每一个字段。 ProtobufToRowDataConverters 中就定义了具体转换逻辑，如截图所示，每一个 LogicalType 都定义了 protobuf message 字段转换为 flink 数据类型的逻辑： 源码公众号后台回复flink sql 知其所以然（五）| 自定义 protobuf format获取。 6.总结与展望篇6.1.总结本文主要是针对 flink sql protobuf format 进行了原理解释以及对应的实现。如果你正好需要这么一个 format，直接公众号后台回复flink sql 知其所以然（五）| 自定义 protobuf format获取源码吧。 6.2.展望当然上述只是 protobuf format 一个基础的实现，用于生产环境还有很多方面可以去扩展的。 性能优化、通用化：protobuf java class 本地 codegen 来提高任务性能 数据质量：异常 AOP，alert 等","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（四）| sql api 类型系统","date":"2021-11-13T06:21:56.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/05_flinksql知其所以然（四）：sqlapi类型系统/","text":"https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/%E5%B0%9A%E7%A1%85%E8%B0%B7Flink%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0?id=%E4%BB%A3%E7%A0%813-cep%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0 https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/table/types/ 感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-先说结论protobuf 作为目前各大公司中最广泛使用的高效的协议数据交换格式工具库，会大量作为流式数据传输的序列化方式，所以在 flink sql 中如果能实现 protobuf 的 format 会非常有用（目前社区已经有对应的实现，不过目前还没有 merge，预计在 1.14 系列版本中能 release）。 这一节原本是介绍 flink sql 中怎么自定义实现 protobuf format 类型，但是 format 的实现过程中涉及到了 flink sql 类型系统的知识，所以此节先讲解 flink sql 类型系统的内容作为铺垫。以帮助能更好的理解 flink sql 的类型系统。 flink sql 类型系统并不是一开始就是目前这样的 LogicalType 体系，其最开始也是复用了 datastream 的 TypeInformation，后来才由 TypeInformation 转变为了 LogicalType，因此本节分为以下几个小节，来说明 flink sql api 类型的转变原因、过程以及新类型系统设计。 背景篇 目标篇-预期效果是什么 框架设计篇-具体方案实现 总结篇 2.背景篇熟悉 DataStream API 的同学都知道，DataStream API 的类型系统 TypeInformation 体系。所以初期 SQL API 的类型系统也是完全由 TypeInformation 实现的。但是随着 SQL API 的 feature 增强，用户越来越多的使用 SQL API 之后，发现 TypeInformation 作为 SQL API 的类型系统还是有一些缺陷的。 具体我们参考 Flip-37：https://cwiki.apache.org/confluence/display/FLINK/FLIP-37%3A+Rework+of+the+Table+API+Type+System。 Flip-65：https://cwiki.apache.org/confluence/display/FLINK/FLIP-65%3A+New+type+inference+for+Table+API+UDFs issue：https://issues.apache.org/jira/browse/FLINK-12251 比如一些用户反馈有以下问题： https://docs.google.com/document/d/1zKSY1z0lvtQdfOgwcLnCMSRHew3weeJ6QfQjSD0zWas/edit#heading=h.64s92ad5mb1 在 Flip-37 中介绍到： 1. TypeInformation 不能和 SQL 类型系统很好的集成，并且不同实现语言也会对其类型信息产生影响。 2. TypeInformation 与 SQL 类型系统不一致。 3. 不能为 DECIMAL 等定义精度和小数位数。 4. 不支持 CHAR/VARCHAR 之间的差异（FLINK-10257、FLINK-9559）。 5. 物理类型和逻辑类型是紧密耦合的。 flink sql 类型系统设计文档：https://docs.google.com/document/d/1a9HUb6OaBIoj9IRfbILcMFPrOL7ALeZ3rVI66dvA2_U/edit#heading=h.5qoorezffk0t 2.1.序列化器受执行环境影响怎么理解不同语言的环境会对类型信息产生影响，直接来看一下下面这个例子（基于 flink 1.8）： 1234567891011121314151617181920import org.apache.flink.table.functions.TableFunctioncase class SimpleUser(name: String, age: Int)class TableFunc0 extends TableFunction[SimpleUser] &#123; // make sure input element&#x27;s format is &quot;&lt;string&amp;gt#&lt;int&gt;&quot; def eval(user: String): Unit = &#123; if (user.contains(&quot;#&quot;)) &#123; val splits = user.split(&quot;#&quot;) collect(SimpleUser(splits(0), splits(1).toInt)) &#125; &#125;&#125; TableFunc0 出参（SimpleUser）的 TypeInformation 不仅取决于出参本身，还取决于使用的表环境，而且最终的序列化器也是不同的，这里以 java 环境和 scala 环境做比较： 2.1.1.java 环境在 java 环境中，使用 org.apache.flink.table.api.java.StreamTableEnvironment#registerFunction 注册函数。 Java 类型提取是通过基于反射的 TypeExtractor 提取 TypeInformation。 示例代码如下（基于 flink 1.8 版本）： 12345678910111213141516171819202122232425public class JavaEnvTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment sEnv = StreamExecutionEnvironment.getExecutionEnvironment(); // create a TableEnvironment for streaming queries StreamTableEnvironment sTableEnv = StreamTableEnvironment.create(sEnv); sTableEnv.registerFunction(&quot;table1&quot;, new TableFunc0()); TableSqlFunction tableSqlFunction = (TableSqlFunction) sTableEnv .getFunctionCatalog() .getSqlOperatorTable() .getOperatorList() .get(170); TypeSerializer&lt;?&gt; t = tableSqlFunction.getRowTypeInfo().createSerializer(sEnv.getConfig()); sEnv.execute(); &#125;&#125; java 环境，可以看到，最终使用的是 Kryo 序列化器。 2.1.2.scala 环境在 scala 环境中，使用 org.apache.flink.table.api.scala.StreamTableEnvironment#registerFunction 注册函数。 使用 Scala 类型提取堆栈并通过使用 Scala 宏提取 TypeInformation。 示例代码如下（基于 flink 1.8 版本）： 1234567891011121314151617181920212223242526272829303132object ScalaEnv &#123; def main(args: Array[String]): Unit &#x3D; &#123; val env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment &#x2F;&#x2F; create a TableEnvironment val tableEnv &#x3D; StreamTableEnvironment.create(env) tableEnv.registerFunction(&quot;hashCode&quot;, new TableFunc0()) val config &#x3D; env.getConfig val function &#x3D; new TableFunc0() registerFunction(config, function) &#x2F;&#x2F; execute env.execute() &#125; def registerFunction[T: TypeInformation](config: ExecutionConfig, tf: TableFunction[T]): Unit &#x3D; &#123; val typeInfo: TypeInformation[_] &#x3D; if (tf.getResultType !&#x3D; null) &#123; tf.getResultType &#125; else &#123; implicitly[TypeInformation[T]] &#125; val ty &#x3D; typeInfo.createSerializer(config) &#125;&#125; scala 环境，最终使用的是 Case Class 序列化器。 但是逻辑上同一个 sql 的 model 的序列化方式只应该与 model 本身有关，不应该与不同语言的 env 有关。不同的 env 的 model 序列化器都应该相同。 2.2.类型系统不一致SQL 类型系统与 TypeInformation 系统不一致。如下图 TypeInformation 类型系统的组成，熟悉 datastream 的同学应该都见过： 但是标准的 sql 类型系统的组成应该是由如下组成这样： 可见 TypeInformation 类型系统与标准 SQL 类型系统的对应关系是不太一致的，这也就导致了 flink sql 与 TypeInformation 不能很好的集成。 2.3.TypeInformation 类型信息与序列化器绑定如图 TypeInformation 的具体实现类需要实现 TypeInformation&lt;T&gt;#createSerializer，来指定类型信息的具体序列化器。 举例，旧类型系统中，flink sql api 中是使用 CRow 进行的内部数据的流转， CRowTypeInfo 如下图，其序列化器固定为 CRowSerializer： 再来一个例子， ListTypeInfo 的序列化器固定为 ListSerializer。 可以看到 TypeInformation 的类型体系中，一种 TypeInformation 就和一个 TypeSerializer 是绑定的。 3.目标篇-预期效果是什么博主体感比较深的是： 1. 统一以及标准化 SQL 类型系统 2. 逻辑类型与物理类型解耦 然后来看看 flink 是怎么做这件事情的，下面的代码都基于 flink 1.13.1。 4.框架设计篇-具体方案实现先从最终最上层的角度出发，看看 flink sql 程序运行时数据载体的变化。 1.old planner： 内部数据流的基本数据类型：CRow = Row + 标识（是否回撤数据） 类型信息：CRowTypeInfo，其类型系统使用的完全也是 TypeInformation 那一套 序列化器：CRowSerializer = RowSerializer + 标识序列化 2.blink planner： 内部数据流的基本数据类型：RowData 类型信息：RowType，基于 LogicalType 序列化器：RowDataSerializer 4.1.统一以及标准化 SQL 类型系统先来重温下，SQL 标准类型： 然后开看看，flink sql 的类型系统设计，代码位于 flink-table-common 模块： 新的类型系统是基于 LogicalTypeFamily，LogicalTypeRoot，LogicalType 进行实现的： LogicalTypeFamily： LogicalTypeRoot： LogicalType： 具体 LogicalType 的各类实现类如下图所示： 可以发现其设计（枚举信息、实现等）都是与 SQL 标准进行了对齐的。 具体类型详情可以参考官方文档，这里不过多赘述。https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/table/types/ 4.2.逻辑类型与物理类型解耦解耦这部分的实现比较好理解，博主通过两种方式来解释其解耦方式： 4.2.1.看看解耦的具体实现博主画了一张图来比较下 TypeInformation 与 LogicalType，如下图。 datastream\\old planner：如左图所示，都是基于 TypeInformation 体系，一种 TypeInformation 就和一个 TypeSerializer 是绑定的。 blink planner：如右图所示，都是基于 LogicalType 体系，但是与 TypeSerializer 通过中间的一层映射层进行解耦，这层映射层是 blink planner 独有的，当然如果你也能自定义一个 planner，你也可以自定义对应的映射方式。 LogicalType 只包含类型信息，关于具体的序列化器是在不同的 planner 中实现的。Blink Planner 是 InternalSerializers。 4.2.2.看看包的划分其实我们也可以通过这些具体实现类的在 flink 中所在的包也可以看出其解耦方式。如图所示。 datastream\\old planner：如左图所示，其中的核心逻辑类型、序列化器都是在 flink-core 中实现的。都是基于以及复用了 TypeInformation 体系。 blink planner：如右图所示，LogicalType 体系都是位于 flink-table-common 模块中，作为 sql 基础、标准的体系。而其中具体的序列化器是在 flink-table-runtime-blink 中的，可以说明不同的 planner 是有对应不同的实现的，从而实现了逻辑类型和物理序列化器的解耦。 5.总结篇本文主要介绍了 flink sql 类型系统的内容，从背景、目标以及最终的实现上做了一些思考和分析。 希望能抛砖引玉，让大家能在使用层面之上还能有一些更深层次的思考~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（三）| sql 自定义 redis 数据汇表","date":"2021-11-13T06:21:55.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/04_flinksql知其所以然（三）：sql自定义redis数据汇表/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构 背景篇-为啥需要 redis 数据汇表 目标篇-redis 数据汇表预期效果 难点剖析篇-此框架建设的难点、目前有哪些实现 维表实现篇-实现的过程 总结与展望篇 本文主要介绍了 flink sql redis 数据汇表的实现过程。 如果想在本地测试下： 在公众号后台回复 flink sql 知其所以然（三）| sql 自定义 redis 数据汇表获取源码（源码基于 1.13.1 实现） flink sql 知其所以然（三）| sql 自定义 redis 数据汇表获取源码（源码基于 1.13.1 实现） flink sql 知其所以然（三）| sql 自定义 redis 数据汇表获取源码（源码基于 1.13.1 实现） 在你的本地安装并启动 redis-server。 执行源码包中的 flink.examples.sql._03.source_sink.RedisSinkTest 测试类，然后使用 redis-cli 执行 get a 就可以看到结果了（目前只支持 kv，即 redis set key value）。 如果想直接在集群环境使用： 命令行执行 mvn package -DskipTests=true 打包 将生成的包 flink-examples-0.0.1-SNAPSHOT.jar 引入 flink lib 中即可，无需其它设置。 2.背景篇-为啥需要 redis 数据汇表目前在实时计算的场景中，熟悉 datastream 的同学在很多场景下都会将结果数据写入到 redis 提供数据服务。 举个例子： 外存状态引擎：需要把历史所有的 id 存储下来，但是因为 id 会不断增多，仅仅使用 flink 内部状态引擎的话，状态会越来越大，很难去保障其稳定性。那么这时就会选择外部状态引擎，比如 redis。在我们使用 redis 存储所有设备 id 时，除了使用 redis 作为维表去访问 id 是否出现过，还需要将新增的 id 写入到 redis 中以供后续的去重。这时候就需要使用到 redis sink 表。 数据服务引擎：在某些大促（双十一）的场景下需要将 flink 计算好的结果直接写入到 redis 中以提供高速数据服务引擎，直接提供给大屏查询使用。 而官方是没有提供 flink sql api 的 redis sink connector 的。如下图，基于 1.13 版本。 https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/connectors/table/overview/ 阿里云 flink 是提供了这个能力的。 https://www.alibabacloud.com/help/zh/faq-detail/118038.htm?spm=a2c63.q38357.a3.16.48fa711fo1gVUd 因此本文在介绍怎样自定义一个 sql 数据汇表的同时，实现一个 sql redis sink connector 来给大家使用。 3.目标篇-redis 数据汇表预期效果redis 作为数据汇表在 datastream 中的最常用的数据结构有很多，基本上所有的数据结构都有可能使用到。本文实现主要实现 kv 结构，其他结构大家可以拿到源码之后进行自定义实现。也就多加几行代码就完事了。 预期效果就如阿里云的 flink redis，redis set key value 的预期 flink sql： 123456789CREATE TABLE redis_sink_table ( key STRING, -- redis key，第 1 列为 key `value` STRING -- redis value，第 2 列为 value) WITH ( &#x27;connector&#x27; = &#x27;redis&#x27;, -- 指定 connector 是 redis 类型的 &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, -- redis server ip &#x27;port&#x27; = &#x27;6379&#x27;, -- redis server 端口 &#x27;write.mode&#x27; = &#x27;string&#x27; -- 指定使用 redis `set key value`) 123INSERT INTO redis_sink_tableSELECT o.f0 as key, o.f1 as valueFROM leftTable AS o 下面是我在本地跑的结果： 首先看下我们的测试输入，f0 恒定为 a，f1 恒定为 b，并且每 10ms 写入一次： 预期结果是 key 为 a，value 会为 b，实际结果也相同，使用 redis-cli 查询下，我删除掉也能在 10ms 后写入，所以查询时可以一直查得到： 4.难点剖析篇-目前有哪些实现目前可以从网上搜到的实现、以及可以参考的实现有以下两个： https://github.com/jeff-zou/flink-connector-redis。 但使用起来有比较多的限制，包括需要在建表时就指定 key-column，value-column 等，其实博主觉得没必要指定这些字段，这些都可以动态调整。其实现是对 apache-bahir-flink https://github.com/apache/bahir-flink 的二次开发，但与 bahir 原生实现有割裂感，因为这个项目几乎参考 bahir redis connector 重新实现了一遍，接口与 bahir 不太相同。 阿里云实现 https://www.alibabacloud.com/help/zh/faq-detail/122722.htm?spm=a2c63.q38357.a3.7.a1227a53TBMuSY。 阿里云的实现相对比较动态化，不需要在建表时就指定 hmap 等数据结构的 map key。 因此博主在实现时，定了一个基调。 参考阿里云的 DDL 实现 高度复用性：复用 bahir 提供的 redis connnector 简洁性：目前只实现 kv 结构，后续扩展可以给用户自己实现，扩展其实是非常简单的 5.实现篇-实现的过程在实现 redis 数据汇表之前，不得不谈谈 flink 数据汇表加载和使用机制。 5.1.flink 数据汇表原理其实上节已经详细描述了 flink sql 对于 source\\sink 的加载机制。 通过 SPI 机制加载所有的 source\\sink\\format 工厂 Factory 过滤出 DynamicTableSinkFactory + connector 标识的 sink 工厂类 通过 sink 工厂类创建出对应的 sink 如图 source 和 sink 是通过 FactoryUtil.createTableSource 和 FactoryUtil.createTableSink 创建的 所有通过 SPI 的 source\\sink\\formt 插件都继承自 Factory。 整体创建 sink 方法的调用链如下图。 5.2.flink 数据汇表实现方案先看下博主的最终实现。 由于高度复用了 bahir redis connector，所以需要重点实现就只有两个类： RedisDynamicTableFactory RedisDynamicTableSink 具体流程： 定义 SPI 的工厂类 RedisDynamicTableFactory implements DynamicTableSinkFactory，并且在 resource\\META-INF 下创建 SPI 的插件文件 实现 factoryIdentifier 标识 redis 实现 RedisDynamicTableFactory#createDynamicTableSink 来创建对应的 source RedisDynamicTableSink 定义 RedisDynamicTableSink implements DynamicTableSink 实现 RedisDynamicTableFactory#getSinkRuntimeProvider 方法，创建具体的维表 UDF RichSinkFunction&lt;T&gt;，这里直接服用了 bahir redis 中的 RedisSink&lt;IN&gt; 介绍完流程，进入具体实现方案细节： RedisDynamicTableFactory 主要创建 sink 的逻辑： 1234567891011121314151617181920212223242526272829303132public class RedisDynamicTableFactory implements DynamicTableSinkFactory &#123; ... @Override public String factoryIdentifier() &#123; // 标识 redis return &quot;redis&quot;; &#125; @Override public DynamicTableSink createDynamicTableSink(Context context) &#123; // either implement your custom validation logic here ... // or use the provided helper utility final FactoryUtil.TableFactoryHelper helper = FactoryUtil.createTableFactoryHelper(this, context); // validate all options // 所有 option 配置的校验，比如 write.mode 类参数 helper.validate(); // get the validated options final ReadableConfig options = helper.getOptions(); final RedisWriteOptions redisWriteOptions = RedisOptions.getRedisWriteOptions(options); TableSchema schema = context.getCatalogTable().getSchema(); / 创建 RedisDynamicTableSink return new RedisDynamicTableSink(schema.toPhysicalRowDataType() , redisWriteOptions); &#125;&#125; resources\\META-INF 文件： RedisDynamicTableSource 主要创建 table udf 的逻辑： 123456789101112131415161718192021222324252627282930public class RedisDynamicTableSink implements DynamicTableSink &#123; ... @Override public SinkRuntimeProvider getSinkRuntimeProvider(Context context) &#123; // 初始化 redis 客户端配置 FlinkJedisConfigBase flinkJedisConfigBase = new FlinkJedisPoolConfig.Builder() .setHost(this.redisWriteOptions.getHostname()) .setPort(this.redisWriteOptions.getPort()) .build(); RedisMapper&lt;RowData&gt; redisMapper = null; switch (this.redisWriteOptions.getWriteMode()) &#123; case &quot;string&quot;: // redis key，value 序列化器 // 从 RowData 转换成 redis 的 key value redisMapper = new SetRedisMapper(); break; default: throw new RuntimeException(&quot;其他类型 write mode 请自定义实现&quot;); &#125; // 创建 SinkFunction，注意！！！这里直接复用了 bahir 的实现 return SinkFunctionProvider.of(new RedisSink&lt;&gt;( flinkJedisConfigBase , redisMapper)); &#125;&#125; RedisSink 执行写入 redis 的主要流程，这里是 bahir 的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class RedisRowDataLookupFunction extends TableFunction&lt;RowData&gt; &#123; ... @Override public void invoke(IN input) throws Exception &#123; String key = redisSinkMapper.getKeyFromData(input); String value = redisSinkMapper.getValueFromData(input); // 根据具体的命令执行具体写入 redis 的命令 switch (redisCommand) &#123; case RPUSH: this.redisCommandsContainer.rpush(key, value); break; case LPUSH: this.redisCommandsContainer.lpush(key, value); break; case SADD: this.redisCommandsContainer.sadd(key, value); break; case SET: this.redisCommandsContainer.set(key, value); break; case PFADD: this.redisCommandsContainer.pfadd(key, value); break; case PUBLISH: this.redisCommandsContainer.publish(key, value); break; case ZADD: this.redisCommandsContainer.zadd(this.additionalKey, value, key); break; case ZREM: this.redisCommandsContainer.zrem(this.additionalKey, key); break; case HSET: this.redisCommandsContainer.hset(this.additionalKey, key, value); break; default: throw new IllegalArgumentException(&quot;Cannot process such data type: &quot; + redisCommand); &#125; &#125; @Override public void open(Configuration parameters) throws Exception &#123; try &#123; // 初始化 redis 执行器 this.redisCommandsContainer = RedisCommandsContainerBuilder.build(this.flinkJedisConfigBase); this.redisCommandsContainer.open(); &#125; catch (Exception e) &#123; LOG.error(&quot;Redis has not been properly initialized: &quot;, e); throw e; &#125; &#125;&#125; 5.2.1.复用 bahir connector如图是 bahir redis connector 的实现。 博主在实现过程中将能复用的都尽力复用。如图是最终实现目录。 可以看到实现非常简单。 其中 redis 客户端及其配置、redis 命令执行器 和 redis 命令定义器 是直接复用了 bahir redis 的。如果你想要在生产环境中进行使用，可以直接将两部分代码合并，成本很低。 源码公众号后台回复flink sql 知其所以然（三）| sql 自定义 redis 数据汇表获取。 6.总结与展望篇6.1.总结本文主要是针对 flink sql redis 数据汇表进行了扩展以及实现，并且复用 bahir redis connector 的配置，具有良好的扩展性。如果你正好需要这么一个 connector，直接公众号后台回复flink sql 知其所以然（三）| sql 自定义 redis 数据汇表获取源码吧。 6.2.展望当然上述只是 redis 数据汇表一个基础的实现，用于生产环境还有很多方面可以去扩展的。 jedis cluster 的扩展：目前 bahir datastream 中已经实现了，可以直接参考，扩展起来非常简单 异常 AOP，alert 等","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（二）| sql 自定义 redis 数据维表","date":"2021-11-13T06:21:54.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/03_flinksql知其所以然（二）：sql自定义redis数据维表/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构 背景篇-为啥需要 redis 维表 目标篇-做 redis 维表的预期效果是什么 难点剖析篇-此框架建设的难点、目前有哪些实现 维表实现篇-维表实现的过程 总结与展望篇 本文主要介绍了 flink sql redis 维表的实现过程。 如果想在本地测试下： 在公众号后台回复flink sql 知其所以然（二）| sql 自定义 redis 数据维表获取源码（源码基于 1.13.1 实现） 在你的本地安装并打开 redis-server，然后使用 redis-cli 执行命令 set a &quot;&#123;\\&quot;score\\&quot;:3,\\&quot;name\\&quot;:\\&quot;namehhh\\&quot;,\\&quot;name1\\&quot;:\\&quot;namehhh112\\&quot;&#125;&quot; 执行源码包中的 flink.examples.sql._03.source_sink.RedisLookupTest 测试类，就可以在 console 中看到结果。 如果想直接在集群环境使用： 命令行执行 mvn package -DskipTests=true 打包 将生成的包 flink-examples-0.0.1-SNAPSHOT.jar 引入 flink lib 中即可，无需其它设置。 2.背景篇-为啥需要 redis 维表2.1.啥是维表？事实表？Dimension Table 概念多出现于数据仓库里面，维表与事实表相互对应。 给两个场景来看看： 比如需要统计分性别的 DAU： 客户端上报的日志中（事实表）只有设备 id，只用这个事实表是没法统计出分性别的 DAU 的。 这时候就需要一张带有设备 id、性别映射的表（这就是维表）来提供性别数据。 然后使用事实表去 join 这张维表去获取到每一个设备 id 对应的性别，然后就可以统计出分性别的 DAU。相当于一个扩充维度的操作。 https://blog.csdn.net/weixin_47482194/article/details/105855116?spm=1001.2014.3001.5501 比如目前想要统计整体销售额： 目前已有 “销售统计表”，是一个事实表，其中没有具体销售品项的金额。 “商品价格表” 可以用于提供具体销售品项的金额，这就是销售统计的一个维度表。 事实数据和维度数据的识别必须依据具体的主题问题而定。“事实表” 用来存储事实的度量及指向各个维的外键值。维表用来保存该维的元数据。 参考：https://blog.csdn.net/lindan1984/article/details/96566626 2.2.为啥需要 redis 维表？目前在实时计算的场景中，熟悉 datastream 的同学大多数都使用过 mysql\\Hbase\\redis 作为维表引擎存储一些维度数据，然后在 datastream api 中调用 mysql\\Hbase\\redis 客户端去获取到维度数据进行维度扩充。 而 redis 作为 flink 实时场景中最常用的高速维表引擎，官方是没有提供 flink sql api 的 redis 维表 connector 的。如下图，基于 1.13 版本。 https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/connectors/table/overview/ 阿里云 flink 是提供了这个能力的。但是这个需要使用阿里云的产品才能使用。有钱人可以直接上。 https://www.alibabacloud.com/help/zh/faq-detail/122722.htm?spm=a2c63.q38357.a3.7.a1227a53TBMuSY 因此本文在介绍怎样自定义一个 sql 数据维表的同时，实现一个 sql redis 来给大家使用。 3.目标篇-做 redis 维表预期效果是什么redis 作为维表在 datastream 中的最常用的数据结构就是 kv、hmap 两种。本文实现主要实现 kv 结构，map 结构大家可以拿到源码之后进行自定义实现。也就多加几行代码就完事了。 预期效果就如阿里云的 flink redis： 下面是我在本地跑的结果，先看看 redis 中存储的数据，只有这一条数据，是 json 字符串： 下面是预期 flink sql： 12345678910111213CREATE TABLE dimTable ( name STRING, name1 STRING, score BIGINT -- redis 中存储数据的 schema) WITH ( &#x27;connector&#x27; = &#x27;redis&#x27;, -- 指定 connector 是 redis 类型的 &#x27;hostname&#x27; = &#x27;127.0.0.1&#x27;, -- redis server ip &#x27;port&#x27; = &#x27;6379&#x27;, -- redis server 端口 &#x27;format&#x27; = &#x27;json&#x27; -- 指定 format 解析格式 &#x27;lookup.cache.max-rows&#x27; = &#x27;500&#x27;, -- guava local cache 最大条目 &#x27;lookup.cache.ttl&#x27; = &#x27;3600&#x27;, -- guava local cache ttl &#x27;lookup.max-retries&#x27; = &#x27;1&#x27; -- redis 命令执行失败后重复次数) 12345SELECT o.f0, o.f1, c.name, c.name1, c.scoreFROM leftTable AS o-- 维表 joinLEFT JOIN dimTable FOR SYSTEM_TIME AS OF o.proctime AS cON o.f0 = c.name 结果如下，后面三列就对应到 c.name, c.name1, c.score： 123456789+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3]+I[a, b, namehhh, namehhh112, 3] 4.难点剖析篇-目前有哪些实现目前可以从网上搜到的实现、以及可以参考的实现有以下两个： https://github.com/jeff-zou/flink-connector-redis。 但是其没有实现 flink sql redis 维表，只实现了 sink 表，并且使用起来有比较多的限制，包括需要在建表时就指定 key-column，value-column 等，其实博主觉得没必要指定这些字段，这些都可以动态调整。其实现是对 apache-bahir-flink https://github.com/apache/bahir-flink 的二次开发，但与 bahir 原生实现有割裂感，因为这个项目几乎重新实现了一遍，接口也和 bahir 不同。 阿里云实现 https://www.alibabacloud.com/help/zh/faq-detail/122722.htm?spm=a2c63.q38357.a3.7.a1227a53TBMuSY。 可以参考的只有用法和配置等。但是有些配置项也属于阿里自定义的。 因此博主在实现时，就定了一个基调。 复用 connector：复用 bahir 提供的 redis connnector 复用 format：复用 flink 目前的 format 机制，目前这个上述两个实现都没有做到 简洁性：实现 kv 结构。hget 封装一部分 维表 local cache：为避免高频率访问 redis，维表加了 local cache 作为缓存 5.维表实现篇-维表实现的过程在实现 redis 维表之前，不得不谈谈 flink 维表加载和使用机制。 5.1.flink 维表原理其实上节已经详细描述了 flink sql 对于 source\\sink 的加载机制，维表属于 source 的中的 lookup 表，在具体 flink 程序运行的过程之中可以简单的理解为一个 map，在 map 中调用 redis-client 接口访问 redis 进行扩充维度的过程。 通过 SPI 机制加载所有的 source\\sink\\format 工厂 Factory 过滤出 DynamicTableSourceFactory + connector 标识的 source 工厂类 通过 source 工厂类创建出对应的 source 如图 source 和 sink 是通过 FactoryUtil.createTableSource 和 FactoryUtil.createTableSink 创建的 所有通过 SPI 的 source\\sink\\formt 插件都继承自 Factory。 整体创建 source 方法的调用链如下图。 5.2.flink 维表实现方案先看下博主的最终实现。 总重要的三个实现类： RedisDynamicTableFactory RedisDynamicTableSource RedisRowDataLookupFunction 具体流程： 定义 SPI 的工厂类 RedisDynamicTableFactory implements DynamicTableSourceFactory，并且在 resource\\META-INF 下创建 SPI 的插件文件 实现 factoryIdentifier 标识 redis 实现 RedisDynamicTableFactory#createDynamicTableSource 来创建对应的 source RedisDynamicTableSource 定义 RedisDynamicTableSource implements LookupTableSource 实现 RedisDynamicTableFactory#getLookupRuntimeProvider 方法，创建具体的维表 UDF TableFunction&lt;T&gt;，定义为 RedisRowDataLookupFunction 实现 RedisRowDataLookupFunction 的 eval 方法，这个方法就是用于访问 redis 扩充维度的。 介绍完流程，进入具体实现方案细节： RedisDynamicTableFactory 主要创建 source 的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940public class RedisDynamicTableFactory implements DynamicTableSourceFactory &#123; ... @Override public String factoryIdentifier() &#123; // 标识 redis return &quot;redis&quot;; &#125; @Override public DynamicTableSource createDynamicTableSource(Context context) &#123; // either implement your custom validation logic here ... // or use the provided helper utility final FactoryUtil.TableFactoryHelper helper = FactoryUtil.createTableFactoryHelper(this, context); // discover a suitable decoding format // format 实现 final DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt; decodingFormat = helper.discoverDecodingFormat( DeserializationFormatFactory.class, FactoryUtil.FORMAT); // validate all options // 所有 option 配置的校验，比如 cache 类参数 helper.validate(); // get the validated options final ReadableConfig options = helper.getOptions(); final RedisLookupOptions redisLookupOptions = RedisOptions.getRedisLookupOptions(options); TableSchema schema = context.getCatalogTable().getSchema(); // 创建 RedisDynamicTableSource return new RedisDynamicTableSource( schema.toPhysicalRowDataType() , decodingFormat , redisLookupOptions); &#125;&#125; resources\\META-INF 文件： RedisDynamicTableSource 主要创建 table udf 的逻辑： 1234567891011121314151617181920212223public class RedisDynamicTableSource implements LookupTableSource &#123; ... @Override public LookupRuntimeProvider getLookupRuntimeProvider(LookupContext context) &#123; // 初始化 redis 客户端配置 FlinkJedisConfigBase flinkJedisConfigBase = new FlinkJedisPoolConfig.Builder() .setHost(this.redisLookupOptions.getHostname()) .setPort(this.redisLookupOptions.getPort()) .build(); // redis key，value 序列化器 LookupRedisMapper lookupRedisMapper = new LookupRedisMapper( this.createDeserialization(context, this.decodingFormat, createValueFormatProjection(this.physicalDataType))); // 创建 table udf return TableFunctionProvider.of(new RedisRowDataLookupFunction( flinkJedisConfigBase , lookupRedisMapper , this.redisLookupOptions)); &#125;&#125; RedisRowDataLookupFunction table udf 执行维表关联的主要流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class RedisRowDataLookupFunction extends TableFunction&lt;RowData&gt; &#123; ... /** * 具体 redis 执行方法 */ public void eval(Object... objects) throws IOException &#123; for (int retry = 0; retry &lt;= maxRetryTimes; retry++) &#123; try &#123; // fetch result this.evaler.accept(objects); break; &#125; catch (Exception e) &#123; LOG.error(String.format(&quot;HBase lookup error, retry times = %d&quot;, retry), e); if (retry &gt;= maxRetryTimes) &#123; throw new RuntimeException(&quot;Execution of Redis lookup failed.&quot;, e); &#125; try &#123; Thread.sleep(1000 * retry); &#125; catch (InterruptedException e1) &#123; throw new RuntimeException(e1); &#125; &#125; &#125; &#125; @Override public void open(FunctionContext context) &#123; LOG.info(&quot;start open ...&quot;); // redis 命令执行器，初始化 redis 链接 try &#123; this.redisCommandsContainer = RedisCommandsContainerBuilder .build(this.flinkJedisConfigBase); this.redisCommandsContainer.open(); &#125; catch (Exception e) &#123; LOG.error(&quot;Redis has not been properly initialized: &quot;, e); throw new RuntimeException(e); &#125; // 初始化 local cache this.cache = cacheMaxSize &lt;= 0 || cacheExpireMs &lt;= 0 ? null : CacheBuilder.newBuilder() .recordStats() .expireAfterWrite(cacheExpireMs, TimeUnit.MILLISECONDS) .maximumSize(cacheMaxSize) .build(); if (cache != null) &#123; context.getMetricGroup() .gauge(&quot;lookupCacheHitRate&quot;, (Gauge&lt;Double&gt;) () -&gt; cache.stats().hitRate()); this.evaler = in -&gt; &#123; RowData cacheRowData = cache.getIfPresent(in); if (cacheRowData != null) &#123; collect(cacheRowData); &#125; else &#123; // fetch result byte[] key = lookupRedisMapper.serialize(in); byte[] value = null; switch (redisCommand) &#123; case GET: value = this.redisCommandsContainer.get(key); break; case HGET: value = this.redisCommandsContainer.hget(key, this.additionalKey.getBytes()); break; default: throw new IllegalArgumentException(&quot;Cannot process such data type: &quot; + redisCommand); &#125; RowData rowData = this.lookupRedisMapper.deserialize(value); collect(rowData); cache.put(key, rowData); &#125; &#125;; &#125; ... &#125;&#125; 5.2.1.复用 bahir connector如图是 bahir redis connector 的实现。 博主在实现过程中将能复用的都尽力复用。如图是最终实现目录。 可以看到目录结构是与 bahir redis connector 一致的。 其中 redis 客户端及其配置 是直接复用了 bahir redis 的。由于 bahir redis 基本都是 sink 实现，某些实现没法继承复用，所以这里我单独开辟了目录，redis 命令执行器 和 redis 命令定义器，但是也基本和 bahir 一致。如果你想要在生产环境中进行使用，可以直接将两部分代码合并，成本很低。 5.2.2.复用 format博主直接复用了 flink 本身自带的 format 机制来作为维表反序列化机制。参考 HBase connector 实现将 cache 命中率添加到 metric 中。 1234567891011121314public class RedisDynamicTableFactory implements DynamicTableSourceFactory &#123; ... @Override public DynamicTableSource createDynamicTableSource(Context context) &#123; ... // discover a suitable decoding format // 复用 format 实现 final DecodingFormat&lt;DeserializationSchema&lt;RowData&gt;&gt; decodingFormat = helper.discoverDecodingFormat( DeserializationFormatFactory.class, FactoryUtil.FORMAT); ... &#125;&#125; format 同样也是 SPI 机制加载。 源码公众号后台回复flink sql 知其所以然（二）| sql 自定义 redis 数据维表获取。 5.2.3.维表 local cachelocal cache 在初始化时可以指定 cache 大小，缓存时长等。 12345678910111213141516171819202122232425262728this.evaler = in -&gt; &#123; RowData cacheRowData = cache.getIfPresent(in); if (cacheRowData != null) &#123; collect(cacheRowData); &#125; else &#123; // fetch result byte[] key = lookupRedisMapper.serialize(in); byte[] value = null; switch (redisCommand) &#123; case GET: value = this.redisCommandsContainer.get(key); break; case HGET: value = this.redisCommandsContainer.hget(key, this.additionalKey.getBytes()); break; default: throw new IllegalArgumentException(&quot;Cannot process such data type: &quot; + redisCommand); &#125; RowData rowData = this.lookupRedisMapper.deserialize(value); collect(rowData); cache.put(key, rowData); &#125;&#125;; 6.总结与展望篇6.1.总结本文主要是针对 flink sql redis 维表进行了扩展以及实现，并且复用 bahir redis connector 的配置，具有良好的扩展性。如果你正好需要这么一个 connector，直接公众号后台回复flink sql 知其所以然（二）| sql 自定义 redis 数据维表获取源码吧。 6.2.展望当然上述只是 redis 维表一个基础的实现，用于生产环境还有很多方面可以去扩展的。 jedis cluster 的扩展：目前 bahir datastream 中已经实现了，可以直接参考，扩展起来非常简单 aync lookup 维表的扩展：目前 hbase lookup 表已经实现了，可以直接参考实现 异常 AOP，alert 等","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"flink sql 知其所以然（一）| source\\sink 原理","date":"2021-11-13T06:21:53.000Z","path":"2021/11/13/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/02_source_sink/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-本文结构本文从以下五个小节介绍 flink sql source\\sink\\format 的概念、原理。 背景篇-关于 sql 定义篇-sql source、sink 实战篇-sql source、sink 的用法 原理剖析篇-sql source、sink 是怎么跑起来的 总结与展望篇 2.背景篇-关于 sql关于 flink sql 的定位。 先聊聊使用 sql 的原因，总结来说就是一切从简。 SQL 属于 DSL SQL 易于理解 SQL 内置多种查询优化器 SQL 稳定的语言 SQL 易于管理 SQL 利于流批一体 目前 1.13 版本的 SQL 已经集成了大量高效、易用的 feature。本系列教程也是基于 1.13.1。 3.定义篇-sql source、sink本文会简单介绍一些 flink sql 的 source、sink 的定义、使用方法，会着重切介绍其对应框架设计和实现。详细解析一下从一条 create table sql 到具体的算子层面的整个流程。 Notes：在 flink sql 中，source 有两种表，一种是数据源表，一种是数据维表。数据源表就是有源源不断的数据的表。比如 mq。数据维表就是用来给某些数据扩充维度使用的。比如 redis，mysql，一般都是做扩容维度的维表 join 使用。 本节主要介绍数据源表，数据维表的整个流程和数据源表几乎一样。下文中的 source 默认都为数据源表。 首先在介绍 sql 之前，我们先来看看 datastream 中定义一个 source 需要的最基本的内容。 source、sink 的 connector 连接配置信息。比如 datastream api kafka connector 的 properties，topic 名称。 source、sink 的序列化方式信息。比如 datastream api kafka connector 的 DeserializationSchema，SerializationSchema。 source、sink 的字段信息。比如 datastream api kafka connector 的序列化或者反序列化出来的 Model 所包含的字段信息。 source、sink 对象。比如 datastream api kafka connector source 对应的具体 java 对象。 sql 中的 source、sink 所包含的基本点其实和 datastream 都是相同的，可以将 sql 中的一些语法给映射到 datastream 中来帮助快速理解 sql： sql source、sink connector\\properties。可以对应到 datastream api kafka connector 的 properties，topic 名称。 sql source、sink format。可以对应到 datastream api kafka connector 的 DeserializationSchema，SerializationSchema。 sql source、sink field。可以对应到 datastream api kafka connector 的序列化或者反序列化出来的 Model 所包含的字段信息。 sql source、sink catalog_name、db_name、table_name。可以对应到 datastream api kafka connector source 对应的具体 java 对象。 sql 本身的特性。比如某些场景下需要将 sql schema 持久化，会用到 hive catalog 等，这个可以说是 sql 目前比 datastream api 多的一个特性。但是仔细想想，其实 datastream 也能够拓展这样的能力，其实就是将某个 datastream 注册到外部存储中（可以，但对 datastream 来说没必要）。 来看看官网的文档 create table schema 的描述，可以发现就是围绕着上面这五点展开的。 https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/dev/table/sql/create/#create-table。 12345678910111213141516171819202122232425262728293031323334353637CREATE TABLE [IF NOT EXISTS] [catalog_name.][db_name.]table_name ( &#123; &lt;physical_column_definition&gt; | &lt;metadata_column_definition&gt; | &lt;computed_column_definition&gt; &#125;[ , ...n] [ &lt;watermark_definition&gt; ] [ &lt;table_constraint&gt; ][ , ...n] ) [COMMENT table_comment] [PARTITIONED BY (partition_column_name1, partition_column_name2, ...)] WITH (key1=val1, key2=val2, ...) [ LIKE source_table [( &lt;like_options&gt; )] ] &lt;physical_column_definition&gt;: column_name column_type [ &lt;column_constraint&gt; ] [COMMENT column_comment] &lt;column_constraint&gt;: [CONSTRAINT constraint_name] PRIMARY KEY NOT ENFORCED&lt;table_constraint&gt;: [CONSTRAINT constraint_name] PRIMARY KEY (column_name, ...) NOT ENFORCED&lt;metadata_column_definition&gt;: column_name column_type METADATA [ FROM metadata_key ] [ VIRTUAL ]&lt;computed_column_definition&gt;: column_name AS computed_column_expression [COMMENT column_comment]&lt;watermark_definition&gt;: WATERMARK FOR rowtime_column_name AS watermark_strategy_expression&lt;source_table&gt;: [catalog_name.][db_name.]table_name&lt;like_options&gt;:&#123; &#123; INCLUDING | EXCLUDING &#125; &#123; ALL | CONSTRAINTS | PARTITIONS &#125; | &#123; INCLUDING | EXCLUDING | OVERWRITING &#125; &#123; GENERATED | OPTIONS | WATERMARKS &#125; &#125;[, ...] 结合我们刚刚说的 sql source、sink 中主要包含 5 点解释一下： 12345678CREATE TABLE [IF NOT EXISTS] -- sql source、sink catalog_name、db_name、table_name( -- sql source、sink field 字段信息) WITH ( -- sql source、sink connector\\properties 连接配置 -- sql source、sink format) 来个 kafka source 的例子： 12345678910CREATE TABLE KafkaTable ( -- sql source、sink catalog_name、db_name、table_name `f0` STRING, -- sql source、sink 的字段信息 `f1` STRING) WITH ( &#x27;connector&#x27; = &#x27;kafka&#x27;, -- sql source、sink 的 connector 连接配置 &#x27;topic&#x27; = &#x27;topic&#x27;, -- sql source、sink 的 connector 连接配置 &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;, -- sql source、sink 的 connector 连接配置 &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;, -- sql source、sink 的 connector 连接配置 &#x27;format&#x27; = &#x27;json&#x27; -- sql source、sink 的序列化方式信息) 其对应的 datastream 写法如下： 1234567891011121314Properties properties = new Properties();properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);properties.setProperty(&quot;group.id&quot;, &quot;testGroup&quot;);DeserializationSchema&lt;Tuple2&lt;String, String&gt;&gt; d = new AbstractDeserializationSchema&lt;Tuple2&lt;String, String&gt;&gt;() &#123; @Override public Tuple2&lt;String, String&gt; deserialize(byte[] message) throws IOException &#123; return json 解析为 tuple2 此处省略; &#125;&#125;;DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = env .addSource(new FlinkKafkaConsumer&lt;&gt;(&quot;topic&quot;, d, properties)); 将 sql source 和 datastream source 的组成部分互相映射起来可以得到下图，其中 datastream、sql 中颜色相同的属性互相对应： 可以看到，将所有的 sql 关系代数都映射到 datastream api 上，会有助于我们快速理解。 4.实战篇-sql source、sink 的用法直接见官网 Table API Connectors。已经描述的非常详细了，本文侧重原理，所以此处不多赘述。 https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/connectors/table/overview/ https://www.alibabacloud.com/help/zh/faq-list/62516.htm?spm=a2c63.p38356.b99.212.3c1a1442x9AY7m 5.原理剖析篇-sql source、sink 是怎么跑起来的关于 sql 具体工作原理可以参考 https://zhuanlan.zhihu.com/p/157265381。 但是很多刚接触 flink sql 的读者看完这篇文章，会感觉到还没准备好就来了这么大一堆密集的信息。那么 我到底应该从哪里看起呢？ 能理解 sql 会映射到具体的算子执行。但是它具体是怎么对应到具体的算子上的呢？ 博主会从以下两个角度去帮大家理清楚整个流程。 先抛开 flink sql、datastream 提供的能力来说，如果你在自己的一个程序中去接入一个数据源，你最关心的是哪些组件？ 答：消费一个数据源最重要的就是 connector（负责链接外部组件，消费数据） + serde（负责序列化成 flink 认识的变量形式）。 结合第一个问题 + 一段简单的 flink sql 代码来看看 flink 是怎么去做这件事情的。 代码（基于 1.13.1）： 1234567891011121314151617181920212223242526272829303132333435public class KafkaSourceTest &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration()); env.setParallelism(1); EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode().build(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings); tEnv.executeSql( &quot;CREATE TABLE KafkaSourceTable (\\n&quot; + &quot; `f0` STRING,\\n&quot; + &quot; `f1` STRING\\n&quot; + &quot;) WITH (\\n&quot; + &quot; &#x27;connector&#x27; = &#x27;kafka&#x27;,\\n&quot; + &quot; &#x27;topic&#x27; = &#x27;topic&#x27;,\\n&quot; + &quot; &#x27;properties.bootstrap.servers&#x27; = &#x27;localhost:9092&#x27;,\\n&quot; + &quot; &#x27;properties.group.id&#x27; = &#x27;testGroup&#x27;,\\n&quot; + &quot; &#x27;format&#x27; = &#x27;json&#x27;\\n&quot; + &quot;)&quot; ); Table t = tEnv.sqlQuery(&quot;SELECT * FROM KafkaSourceTable&quot;); tEnv.toAppendStream(t, Row.class).print(); env.execute(); &#125;&#125; 可以看到这段代码很简单，就是创建一个数据源表之后 select 数据 print。 通过上面这段 sql 映射出的 transformations 中发现，其实 flink 中最关键变量的也就是我们刚刚提出的第一个问题中的那两点： sql source connector 是 FlinkKafkaConsumer sql source format 是 JsonRowDataDeserializationSchema 所以我们就可以从下面这三个方向（多出来的一个是配置信息）的问题去了解具体是怎么对应到具体的算子上的。 sql source connector：用户指定了 connector = kafka，flink 是怎么自动映射到 FlinkKafkaConsumer 的？ sql source format：用户指定了 format = json，字段信息，flink 是怎么自动映射到 JsonRowDataDeserializationSchema，以及字段解析的？ sql source properties：flink 是怎么自动将配置加载到 FlinkKafkaConsumer 中的？ 5.1.connector 怎样映射到具体算子？引用官网图： Notes：其中 LookupTableSource 为数据维表。 先说下结论，再跟一遍源码。 结论： MetaData：将 sql create source table 转化为实际的 CatalogTable、翻译为 RelNode Planning：创建 RelNode 的过程中使用 SPI 将所有的 source（DynamicTableSourceFactory）\\sink（DynamicTableSinkFactory） 工厂动态加载，获取到 connector = kafka，然后从所有 source 工厂中过滤出名称为 kafka + 继承自 DynamicTableSourceFactory.class 的工厂类 KafkaDynamicTableFactory，使用 KafkaDynamicTableFactory 创建出 KafkaDynamicSource Runtime：KafkaDynamicSource 创建出 FlinkKafkaConsumer，负责 flink 程序实际运行。 源码： debug 代码，既然创建的是 FlinkKafkaConsumer，那我们就将断点打在 FlinkKafkaConsumer 的构造函数中。 如图可以发现当 debug 到当前断点时，已经进入 FlinkKafkaConsumer source 的创建阶段了，执行到这里的时候已经是完成了 sql connector 和具体实际 connector 的映射了。那么 connector 怎样映射到具体算子的过程呢？ 我们往前回溯一下，定位到 CatalogSourceTable 中的 82 行（源码基于 1.13.1），发现 tableSource 已经是 KafkaDynamicSource，因此可以确定就是这一行代码将 connector = kafka 映射到 FlinkKafkaConsumer 的。 可以发现这段代码将包含了所有 sql create source table 中信息的 catalogTable 变量传入了。 进入这个方法后，可以看到是使用了 FactoryUtil 创建了 DynamicTableSource。 进入 FactoryUtil.createTableSource 后可以看到，就是最重要的两步操作。 先获取 kafka 工厂对象。 使用 kafka 工厂对象创建出 kafka source。 进入 FactoryUtil.getDynamicTableFactory 后： flink 是使用了 SPI 机制动态（SPI 机制天然插件化）的加载到了所有继承了 Factory 的工厂实例。通过截图可以看到有好多 source\\sink\\format Factory。关于 SPI 可以参考 https://www.jianshu.com/p/3a3edbcd8f24 通过 connector = kafka + DynamicTableSourceFactory.class 的标识去过滤出 KafkaDynamicTableFactory。 然后 KafkaDynamicTableFactory.createDynamicTableSource 去创建对应的 source。 可以看到 KafkaDynamicTableFactory.createDynamicTableSource 中调用 KafkaDynamicTableFactory.createKafkaTableSource 来创建 KafkaDynamicSource。 基本上整个创建 Source 的流程就结束了。 5.2.format 怎样映射到具体 serde？结论： MetaData：和 connector 都一样 Planning：format 是在创建 RelNode 的过程中，使用 KafkaDynamicTableFactory 创建出 KafkaDynamicSource 时，通过 SPI 去动态过滤出 format = json 并且继承自 DeserializationFormatFactory.class 的 format 工厂类 JsonFormatFactory。 Runtime：KafkaDynamicSource 创建出 FlinkKafkaConsumer 时，实例化 serde 即 JsonRowDataDeserializationSchema，负责 flink 程序实际运行时的反序列化。 源码： KafkaDynamicTableFactory.createDynamicTableSource 中获取反序列化 schema 定义。 flink 是使用了 SPI 机制动态（SPI 机制天然插件化）的加载到了所有继承了 Factory 的 format 工厂实例。 通过 format = json 的标识并且继承自 DeserializationFormatFactory.class 去过滤出 JsonFormatFactory。 5.3.其他配置属性怎么加载？结论： 在 KafkaDynamicTableFactory 创建 KafkaDynamicTable 的过程中初始化。 源码： 6.总结与展望篇本文作为 flink sql 知其然系列的第一节，基于 1.13.1 版本 flink 介绍了 flink sql 的 source\\sink\\format 从 sql 变为可执行代码的原理。带大家过了一下源码。希望可以喜欢。 下节预告：flink sql 自定义 source\\sink。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"踩坑记 | flink sql count_retract 还有这种坑！","date":"2021-11-12T06:21:53.000Z","path":"2021/11/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/01_one-data/03_踩坑记_count_distinct_负值/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇通过本文你可了解到 踩坑场景篇-这个坑是啥样的 问题排查篇-坑的排查过程 问题原理解析篇-导致问题的机制是什么 避坑篇-如何避免这种问题 展望篇-有什么机制可以根本避免这种情况 先说下结论：在非窗口类 flink sql 任务中，会存在 retract 机制，即上游会向下游发送撤回消息（做减法），最新的结果消息（做加法）两条消息来计算结果，保证结果正确性。 而如果我们在上下游中间使用了映射类 udf 改变了撤回消息（做减法）的一些字段值时，就可能会导致撤回消息（做减法）不能被正常处理，最终导致结果的错误。 2.踩坑场景篇-这个坑是啥样的在介绍坑之前我们先介绍下我们的需求、实现方案的背景。 2.1.背景在各类游戏中都会有一种场景，一个用户可以从 A 等级升级到 B 等级，用户可以不断的升级，但是一个用户同一时刻只会在同一个等级。需求指标就是当前分钟各个等级的用户数。 2.2.预期效果 2.3.解决思路 获取到当前所有用户的最新等级 一个用户同一时刻只会在一个等级，所以对每一个等级的用户做 count 操作 2.4.解决方案 获取到当前所有用户的最新等级：flink sql row_number() 就可以实现，按照数据的 rowtime 进行逆序排序就可以获取到用户当前最新的等级 对每一个等级的用户做 count 操作：对 row_number() 的后的明细结果进行 count 操作 2.4.1.sql具体实现 sql 如下，非常简单： 1234567891011121314151617181920212223242526272829303132333435363738394041WITH detail_tmp AS ( SELECT 等级, id, `timestamp` FROM ( SELECT 等级, id, `timestamp`, -- row_number 获取最新状态 row_number() over( PARTITION by id ORDER BY `timestamp` DESC ) AS rn FROM source_db.source_table ) WHERE rn = 1)SELECT DIM.中文等级 as 等级, sum(part_uv) as uvFROM ( SELECT 等级, count(id) as part_uv FROM detail_tmp GROUP BY 等级, mod(id, 1024) )-- 上游数据的等级名称是数字，需求方要求给转换成中文，所以这里加了一个 udf 映射LEFT JOIN LATERAL TABLE(等级中文映射_UDF(等级)) AS DIM(中文等级) ON TRUEGROUP BY DIM.中文等级 2.4.2.参数配置使用 minibatch 参数方式控制数据输出频率。 1234table.exec.mini-batch.enabled : true-- 设定 60s 的触发间隔table.exec.mini-batch.allow-latency : 60stable.exec.mini-batch.size : 10000000000 任务 plan。 2.5.问题场景这段 SQL 跑了 n 年都没有问题，但是有一天运营在配置【等级中文映射_UDF】时，不小心将一个等级的中文名给映射错了，虽然马上恢复了，但是当天的实时数据和离线数据对比后却发现，实时产出的数值比离线大很多！！！而之前都是保持一致的。 3.问题排查篇-坑的排查过程首先我们想一下，这个指标是算 uv 的，运营将等级中文名配置错了，也应该是把原有等级的最终结果算少啊，怎么会算多呢？？？ 然后我们将场景复现了下，来看看代码： 任务代码，大家可以直接 copy 到本地运行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Test &#123; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); EnvironmentSettings settings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode().build(); StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings); // 模拟输入 DataStream&lt;Tuple3&lt;String, Long, Long&gt;&gt; tuple3DataStream = env.fromCollection(Arrays.asList( Tuple3.of(&quot;2&quot;, 1L, 1627218000000L), Tuple3.of(&quot;2&quot;, 101L, 1627218000000L + 6000L), Tuple3.of(&quot;2&quot;, 201L, 1627218000000L + 7000L), Tuple3.of(&quot;2&quot;, 301L, 1627218000000L + 7000L))); // 分桶取模 udf tEnv.registerFunction(&quot;mod&quot;, new Mod_UDF()); // 中文映射 udf tEnv.registerFunction(&quot;status_mapper&quot;, new StatusMapper_UDF()); tEnv.createTemporaryView(&quot;source_db.source_table&quot;, tuple3DataStream, &quot;status, id, timestamp&quot;); String sql = &quot;WITH detail_tmp AS (\\n&quot; + &quot; SELECT\\n&quot; + &quot; status,\\n&quot; + &quot; id,\\n&quot; + &quot; `timestamp`\\n&quot; + &quot; FROM\\n&quot; + &quot; (\\n&quot; + &quot; SELECT\\n&quot; + &quot; status,\\n&quot; + &quot; id,\\n&quot; + &quot; `timestamp`,\\n&quot; + &quot; row_number() over(\\n&quot; + &quot; PARTITION by id\\n&quot; + &quot; ORDER BY\\n&quot; + &quot; `timestamp` DESC\\n&quot; + &quot; ) AS rn\\n&quot; + &quot; FROM source_db.source_table&quot; + &quot; )\\n&quot; + &quot; WHERE\\n&quot; + &quot; rn = 1\\n&quot; + &quot;)\\n&quot; + &quot;SELECT\\n&quot; + &quot; DIM.status_new as status,\\n&quot; + &quot; sum(part_uv) as uv\\n&quot; + &quot;FROM\\n&quot; + &quot; (\\n&quot; + &quot; SELECT\\n&quot; + &quot; status,\\n&quot; + &quot; count(distinct id) as part_uv\\n&quot; + &quot; FROM\\n&quot; + &quot; detail_tmp\\n&quot; + &quot; GROUP BY\\n&quot; + &quot; status,\\n&quot; + &quot; mod(id, 100)\\n&quot; + &quot; )\\n&quot; + &quot;LEFT JOIN LATERAL TABLE(status_mapper(status)) AS DIM(status_new) ON TRUE\\n&quot; + &quot;GROUP BY\\n&quot; + &quot; DIM.status_new&quot;; Table result = tEnv.sqlQuery(sql); tEnv.toRetractStream(result, Row.class).print(); env.execute(); &#125;&#125; UDF 代码： 12345678910111213public class StatusMapper_UDF extends TableFunction&lt;String&gt; &#123; public void eval(String activityRound) &#123; if (activityRound == &quot;1&quot;) &#123; collector.collect(&quot;等级1&quot;); &#125; else if (activityRound == &quot;2&quot;) &#123; collector.collect(&quot;等级2&quot;); &#125; else if (activityRound == &quot;3&quot;) &#123; collector.collect(&quot;等级3&quot;); &#125; &#125;&#125; 在正确情况（模拟 UDF 没有任何变动的情况下）的输出结果： 1234567(true,等级2,1)(false,等级2,1)(true,等级2,2)(false,等级2,2)(true,等级2,3)(false,等级2,3)(true,等级2,4) 最终等级2 的 uv 数为 4，结果复合预期✅。 模拟下用户修改了 udf 配置之后，UDF 代码如下： 123456789101112131415161718192021public class StatusMapper_UDF extends TableFunction&lt;String&gt; &#123; private int i = 0; public void eval(String activityRound) &#123; if (i == 5) &#123; collect(&quot;等级4&quot;); &#125; else &#123; if (&quot;1&quot;.equals(activityRound)) &#123; collector.collect(&quot;等级1&quot;); &#125; else if (&quot;2&quot;.equals(activityRound)) &#123; collector.collect(&quot;等级2&quot;); &#125; else if (&quot;3&quot;.equals(activityRound)) &#123; collector.collect(&quot;等级3&quot;); &#125; &#125; i++; &#125;&#125; 得到的结果如下： 1234567(true,等级2,1)(false,等级2,1)(true,等级2,2)(false,等级2,2)(true,等级2,3)(false,等级2,3)(true,等级2,7) 最终等级2 的 uv 数为 7，很明显这是错误结果❌。 因此可以确定是由于这个 UDF 的处理逻辑变换而导致的结果出现错误。 下文就让我们来分析下其中缘由。 问题原理解析篇-导致问题的机制是什么我们首先来分析下上述 SQL，可以发现整个 flink sql 任务是使用了 unbounded + minibatch 实现的，在 minibatch 触发条件触发时，上游算子会将之前的结果撤回，然后将最新的结果发出。 这个任务的 execution plan 如图所示。 可以从算子图中的一些计算逻辑可以看到，整个任务都是基于 retract 机制运行（count_retract、sum_retract 等）。 而涉及到 udf 的核心逻辑是在 Operator(ID = 7)，和 Operator(ID = 12) 之间。当 Operator(ID = 7) GroupAggregate 结果发生改变之后，会发一条撤回消息（做减法），一条最新的结果消息（做加法）到 Operator(ID = 12) GroupAggregate。 Notes：简单解释下上面说的撤回消息（做减法），最新的结果消息（做加法）。举个算 count 的例子：当整个任务的第一条数据来之后，之前没有数据，所以不用撤回，结果就是 0（没有数据） + 1（第一条数据） = 1（结果），当第二条结果来之后，就要将上次发的 1 消息（可以理解为是整个任务的一个中间结果）撤回，将最新的结果 2 发下去。那么计算方法就是 1（上次的结果） - 1（撤回） + 2（当前最新的结果消息）= 2（结果）。 通过算子图可以发现，【中文名称映射】UDF 是处于两个 GroupAggregate 之间的。也就是说 Operator(ID = 7) GroupAggregate 发出的撤回消息（做减法），最新的结果消息（做加法）都会执行这个 UDF，那么就有可能撤回消息（做减法）中的某个作为下游 GroupAggregate 算子 key 的字段会被更改成其他值，那么这条消息就不会发到原来下游 GroupAggregate 算子的原始 key 中，那么原来的 key 的历史结果就撤回不了了。。。但是最新的结果消息（做加法）的字段没有被更改时，那么这个消息依然被发到了下游 GroupAggregate 算子，这就会导致没做减法，却做了加法，就会导致结果增加。 从这个角度出发，我们来分析下上面的 case，从内层发给外层的消息一条一条来分析。 内层消息怎么来看呢？其实就是将上面的 SQL 中的 left join 删除，重新跑一遍就可以得到结果，结果如下： 1234567(true,等级2,1)(false,等级2,1)(true,等级2,2)(false,等级2,2)(true,等级2,3)(false,等级4,3)(true,等级2,4) 来分析下内层消息发出之后对应到外层消息的操作： 内层 外层 (true,等级2,1) (true,等级2,1) (false,等级2,1) (false,等级2,1) (true,等级2,2) (true,等级2,2) (false,等级2,2) (false,等级2,2) (true,等级2,3) (true,等级2,3) 前五条消息不会导致错误，不用详细说明。 内层 外层 (true,等级2,1) (true,等级2,1) (false,等级2,1) (false,等级2,1) (true,等级2,2) (true,等级2,2) (false,等级2,2) (false,等级2,2) (true,等级2,3) (true,等级2,3) (false,等级4,3) 第六条消息发出之后，经过 udf 的处理之后，中文名被映射成了【等级4】，而其再通过 hash partition 策略向下发送消息时，就不能将这条撤回消息发到原本 key 为【等级2】的算子中了，这条撤回消息也无法被处理了。 内层 外层 (true,等级2,1) (true,等级2,1) (false,等级2,1) (false,等级2,1) (true,等级2,2) (true,等级2,2) (false,等级2,2) (false,等级2,2) (true,等级2,3) (true,等级2,3) (false,等级4,3) (true,等级2,4) (false,等级2,3) (true,等级2,7) 第七条消息 (true,等级2,4) 发出后，外层 GroupAggregate 算子首先会将上次发出的记过撤回，即(false,等级2,3)，然后将(true,等级2,4)累加到当前的记过上，即 3（上次结果）+ 4（这次最新的结果）= 7（结果）。就导致了上述的错误结果。 定位到问题原因之后，我们来看看怎么避免上述错误。 6.避坑篇-如何避免这种问题6.1.从源头避免udf 这种映射维度的 udf 尽量在上线前就固定下来，避免后续更改造成的数据错误。 6.2.替换为 ScalarFunction 进行映射12345678910111213141516171819202122232425262728293031323334353637383940414243444546WITH detail_tmp AS ( SELECT status, id, `timestamp` FROM ( SELECT status, id, `timestamp`, row_number() over( PARTITION by id ORDER BY `timestamp` DESC ) AS rn FROM ( SELECT status, id, `timestamp` FROM source_db.source_table ) t1 ) t2 WHERE rn = 1)SELECT -- 在此处进行中文名称映射 等级中文映射_UDF(status) as status, sum(part_uv) as uvFROM ( SELECT status, count(distinct id) as part_uv FROM detail_tmp GROUP BY status, mod(id, 100) )GROUP BY status 1234567891011121314151617181920212223public class StatusMapper_UDF extends ScalarFunction &#123; private int i = 0; public String eval(String activityRound) &#123; if (i == 5) &#123; i++; return &quot;等级4&quot;; &#125; else &#123; i++; if (&quot;1&quot;.equals(activityRound)) &#123; return &quot;等级1&quot;; &#125; else if (&quot;2&quot;.equals(activityRound)) &#123; return &quot;等级2&quot;; &#125; else if (&quot;3&quot;.equals(activityRound)) &#123; return &quot;等级3&quot;; &#125; &#125; return &quot;未知&quot;; &#125;&#125; 还是刚刚的逻辑，刚刚的配方，我们先来看一下结果。 1234567(true,等级2,1)(false,等级2,1)(true,等级2,2)(false,等级2,2)(true,等级2,3)(false,等级4,3)(true,等级2,4) 发现虽然依然会有 (false,等级4,3) 这样的错误撤回数据（这是 udf 决定的，没法避免），但是我们可以发现最终的结果是 (true,等级2,4)，结果依然是正确的。 再来分析下问什么这种方式可以解决，如图 plan。 发现映射 udf 算子所处的位置不在两个 GroupAggregrate 之间了，因此在 retract 消息发送之后，不会被映射到错误其他 key 中，因此所有的 retract 消息都会正常处理。 7.展望篇-有什么机制可以根本避免这种情况可以将撤回消息（做减法），最新的结果消息（做加法）做成一个原子消息从上游发给下游，下游统一进行原子性处理，关联 udf 时，也只对 group key 关联一次即可。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"揭秘字节跳动埋点数据实时动态处理引擎","date":"2021-11-12T06:21:53.000Z","path":"2021/11/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/01_one-data/05_揭秘字节跳动埋点数据实时动态处理引擎/","text":"感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 1.序篇-先说结论宝贝们，还记得前几天博主去的火山引擎大数据场嘛，其中比较令大家感兴趣的就是最后一讲，字节一站式埋点平台的 flink 标准化清洗及拆流任务。 其中大家感觉比较流啤的就是的就是字节做到了： 不重启任务可以上下线新的拆流及清洗规则，所有的规则变更都不需要涉及到任务的重启。 清洗 udf，rpc 接口热加载 总的来说就是任务永不停，不可能停止的，好么，beiber。 字节火山引擎 PPT。公众号回复 20210724 获取。 本文博主就主要介绍第一点，即做到规则动态变化，可以做到动态添加一个 sink kafka topic，动态删除一个 sink kafka topic，而不重启任务。相信能抛砖引玉，给大家一些启发。 本文从以下几个章节详细介绍框架实现： 背景篇-为啥需要这么个框架 定义、目标篇-做这个框架的目标、预期效果是什么 难点剖析篇-此框架建设的难点、业界目前的实现 数据建设篇-框架具体方案设计 数据保障篇-框架的保障方案 总结与展望篇 2.背景篇-为啥需要这么个框架首先来看看字节他们做这件事情的背景： 任务重启造成数据的延迟：对于字节这种企业来说且每天都会新上线很多的埋点，把这些新的埋点拆流条件加入 flink 任务就要重启，但是字节客户端日志流量都是千万级别 qps 的，就意味着这个 flink 任务一旦重启耗时肯定是很长的，这对时延敏感的业务是不可接受的。 减少对于原始客户端日志的烟囱式消费，节约资源 统一标准化的埋点平台：用户能通过埋点平台用到正确的数据 与埋点平台联动的、统一化的、标准化的流式数据处理平台：用户能通过这个平台去获取想要的统一标准化的数据 数据的分级保障能力：Dump 日志，日志的产出需要分优先级进行保障（死保、尽力保…），用户能放心的用数据 如图： 因此诞生了这个框架。 3.定义、目标篇-做这个框架的目标、预期效果是什么上述的痛点很多，本节就从最痛的任务重启的延迟角度出发解决问题，揭秘字节动态配置化的 flink 任务的实现。 预期效果如下： 即在任务不停止的情况下可以动态的上线一个动态规则、一个 sink kafka topic，上线某个、某类埋点对应的流数据的 kafka topic 如图左边是修改配置，添加了一个拆流规则以及对应 topic，右边这个规则 topic 就开始产出数据，对应的 console consumer 就消费到了复合规则的数据。 即在任务不停止的情况下可以动态的下线一个动态规则、一个 sink kafka topic，下线某个、某类埋点对应的流数据的 kafka topic 如图左边是修改配置，删除了一个拆流规则以及对应 topic，右边这个规则 topic 就不产出数据了，对应的 console consumer 就没有新数据可以消费了。 4.难点剖析篇-此框架建设的难点、业界目前的实现首先带大家分析下，实现这个框架，最基本的模块都需要包含什么： flink 任务：本身就是一个 Map 任务，逻辑简单 动态上下线规则配置：肯定得有一个动态配置中心去告诉 flink 任务需要新上下线一个 kafka topic 动态规则过滤引擎：flink 任务监听到规则发生动态变化之后，要热更新规则，将新的规律规则应用起来。需要一个动态代码执行引擎 动态上下线 Kafka topic：目前大多数公司用的是 flink 自带的 kafka-connector，一旦涉及到需要添加一个下游，就需要添加一个 kafka producer operator，因为涉及到多加了一个 operator，那肯定得重启任务。需要动态添加删除 producer 的能力。 5.数据建设篇-框架具体方案设计5.1.方案设计5.1.1.方案先说说方案选择的结论： flink 入口任务：Map 模型使用 ProcessFunction 底层算子 动态上下线规则配置：配置中心开源的有很多，这里为了实现轻量化，实现简单，使用 zookeeper 作为动态规则配置中心。当然如果对 zk 压力大，也可以使用广播配置实现。 动态规则引擎：规则引擎很多，比如常见的可以使用 JavaScript、Groovy、jython、mvel2、freemarker 等等，太多了。考虑到性能、易用性选用 janino 将动态规则动态编译出 class。然后作为动态规则引擎使用。后面会详述选用 janino 的原因。 动态上下线 Kafka topic：去除 flink-kafka-connector，直接在 ProcessFunction 中使用原生 kafka-clients 输出数据，维护一个 producer 池。 整体方案架构图如图所示： 项目代码、在博主公众号回复【揭秘字节跳动埋点数据实时动态处理引擎】获取： 5.1.2.预期效果5.1.2.1.上线配置 5.1.2.2.下线配置 5.2.具体实现整个任务的实现非常简单。 本地运行，可以参考下面两篇安装 zk 和 kafka。 zk：https://www.jianshu.com/p/5491d16e6abd kafka：https://www.jianshu.com/p/dd2578d47ff6 5.2.1.flink 任务入口逻辑首先来看看整个任务的入口逻辑，ProcessFunction 的功能很简单： 针对数据源的每一条日志数据，遍历动态规则引擎池 只要这条数据满足某一条规则的条件，就将这条日志数据写出到规则对应的 topic 中 项目代码、在博主公众号回复【揭秘字节跳动埋点数据实时动态处理引擎】获取： 12345678910111213141516171819202122232425262728293031323334353637383940414243 env.addSource(new UserDefinedSource()) .process(new ProcessFunction&lt;ClientLogSource, ClientLogSink&gt;() &#123; // 动态规则配置中心 private ZkBasedConfigCenter zkBasedConfigCenter; // kafka producer 管理中心 private KafkaProducerCenter kafkaProducerCenter; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.zkBasedConfigCenter = ZkBasedConfigCenter.getInstance(); this.kafkaProducerCenter = KafkaProducerCenter.getInstance(); &#125; @Override public void processElement(ClientLogSource clientLogSource, Context context, Collector&lt;ClientLogSink&gt; collector) throws Exception &#123; // 遍历所有的动态规则 this.zkBasedConfigCenter.getMap().forEach(new BiConsumer&lt;Long, DynamicProducerRule&gt;() &#123; @Override public void accept(Long id, DynamicProducerRule dynamicProducerRule) &#123; // 验证该条数据是否符合该条规则 if (dynamicProducerRule.eval(clientLogSource)) &#123; // 将符合规则的数据发向对应规则的 topic 中 kafkaProducerCenter.send(dynamicProducerRule.getTargetTopic(), clientLogSource.toString()); &#125; &#125; &#125;); &#125; @Override public void close() throws Exception &#123; super.close(); // 关闭规则池 this.zkBasedConfigCenter.close(); // 关闭 producer 池 this.kafkaProducerCenter.close(); &#125; &#125;);env.execute(); 5.2.2.动态上下线规则配置来看 flink ProcessFunction 中的核心点，第一部分就是 ZkBasedConfigCenter。其功能包含： 任务启动时，初始化加载 zk 配置，初始化规则池，将规则池中的配置规则编译成 class 可执行规则 监听 zk 配置变更，将新增配置加入规则池，将下线配置从规则池删除 5.2.2.1.动态规则 schema 设计动态规则包含的内容与用户需求息息相关： 举例：用户需要将在首页上报 + id &gt; 300 用户的客户端日志都写入 topic_id_bigger_than_300_and_main_page 的 kafka topic 中。 那么针对这个 flink 任务来说就有以下三项用户的输入： 动态规则的过滤条件：即上游每一条数据过来之后检验这条数据是否满足规则条件。上面这个例子的条件就是 clientLogSource.getId() &gt; 300 &amp;&amp; clientLogSource.getPage().equals(&quot;首页&quot;)；其中 clientLogSource 是原始日志 model 动态规则要写入的 topic 名称：这条规则过滤出来的数据要写入哪个 topic。上面这个例子的 topic 就是 topic_id_bigger_than_300_and_main_page 动态规则的唯一 id：唯一标识一个过滤规则的 id 针对上述要求设计动态规则配置的 schema 如下： 1234567891011121314&#123; &quot;id-数值类型 string&quot;: &#123; &quot;condition-过滤条件&quot;: &quot;1==1&quot;, &quot;targetTopic-目标 topic 名称&quot;: &quot;tuzisir1&quot; &#125; &quot;1&quot;: &#123; &quot;condition&quot;: &quot;clientLogSource.getId() &gt; 300 &amp;&amp; clientLogSource.getPage().equals(\\&quot;首页\\&quot;)&quot;, &quot;targetTopic&quot;: &quot;topic_id_bigger_than_300_and_main_page&quot; &#125;, &quot;2&quot;: &#123; &quot;condition&quot;: &quot;clientLogSource.getPage().equals(\\&quot;个人主页\\&quot;)&quot;, &quot;targetTopic&quot;: &quot;topic_profile_page&quot; &#125;&#125; 对应动态规则 model 设计如下： 项目代码、在博主公众号回复【揭秘字节跳动埋点数据实时动态处理引擎】获取： 123456789101112131415161718192021222324252627public class DynamicProducerRule implements Evaluable &#123; // 具体过滤规则 private String condition; // 具体写入 topic private String targetTopic; // 使用 janino 编译的规则过滤器 private Evaluable evaluable; public void init(Long id) &#123; try &#123; // 使用 janino 初始化规则 Class&lt;Evaluable&gt; clazz = JaninoUtils.genCodeAndGetClazz(id, targetTopic, condition); this.evaluable = clazz.newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public boolean eval(ClientLogSource clientLogSource) &#123; return this.evaluable.eval(clientLogSource); &#125;&#125; 重点在于 Evaluable 接口，动态生成代码就是继承了这个接口，用于执行过滤规则的基础接口。 代码动态生成下面会详细介绍。 123456public interface Evaluable &#123; // 动态规则接口过滤方法 boolean eval(ClientLogSource clientLogSource);&#125; 5.2.2.2.基于 zk 的动态配置中心使用了 zk 作为动态配置中心，来动态监听规则配置以及更新规则池。 项目代码、在博主公众号回复【揭秘字节跳动埋点数据实时动态处理引擎】获取： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ZkBasedConfigCenter &#123; // zk config 变化监听器 private TreeCache treeCache; // zk 客户端 private CuratorFramework zkClient; private ZkBasedConfigCenter() &#123; try &#123; open(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; // ！！！规则池！！！规则池！！！规则池 private ConcurrentMap&lt;Long, DynamicProducerRule&gt; map = new ConcurrentHashMap&lt;&gt;(); private void open() throws Exception &#123; // 初始化规则 // 初始化 zk config 监听器 // 当有配置变更时 // 调用 private void update(String json) 更新规则 &#125; public void close() &#123; this.treeCache.close(); this.zkClient.close(); &#125; private void update(String json) &#123; Map&lt;Long, DynamicProducerRule&gt; result = getNewMap(json); // 1.将新增规则添加进规则池 // 2.将下线规则从规则池删除 &#125; private Map&lt;Long, DynamicProducerRule&gt; getNewMap(String json) &#123; // 将新规则解析，并使用 janino 进行初始化 &#125;&#125; 可以使用一个固定路径的配置，如图博主使用的是 /kafka-config 5.2.3.动态规则引擎目前字节使用的引擎是 Groovy，但是博主常用 flink sql，sql 中的代码生成是使用 janino 做的，因此就比较了 janino 和 groovy 的性能差异，janino 编译出的原生 class 性能接近原生 class，是 Groovy 的 4 倍左右。其他的引擎不考虑，要么易用性差，要么性能差。 Notes：性能这一点真的是很重要，1：4 的差距可以说是差别很大了。如果你的场景也是大流量，非常耗费性能的场景，建议直接入手 janino！！！ 来看看具体的 benchmark case 代码： 1234// ClientLogSource 是原始日志boolean eval(flink.examples.datastream._01.bytedance.split.model.ClientLogSource clientLogSource) &#123; return String.valueOf(clientLogSource.getId()).equals(&quot;1&quot;);&#125; 上面这段代码，在博主 mac 本地执行，每次循环执行 5kw 次，总计执行 5 次 得出的结果如下： 12345678910111213141516171819java:847 msjanino:745 msgroovy:4110 msjava:1097 msjanino:1170 msgroovy:4052 msjava:916 msjanino:1117 msgroovy:4311 msjava:915 msjanino:1112 msgroovy:4382 msjava:921 msjanino:1104 msgroovy:4321 ms 重复执行了很多次：java object : janino 编译原生 class ： groovy ：几乎都是 1：1：4 的耗时。所以此处我们选择性能更好的 janino。 项目代码、在博主公众号回复【揭秘字节跳动埋点数据实时动态处理引擎】获取： 12345678public class JaninoUtils &#123; public static Class&lt;Evaluable&gt; genCodeAndGetClazz(Long id, String topic, String condition) throws Exception &#123; // 动态生成代码 // 初始化 Class&lt;Evaluable&gt; 并返回 &#125;&#125; 5.2.4.动态上下线 Kafka topic来看入口类中的第二个核心点，就是 KafkaProducerCenter。其功能包含： 维护所有的 producer 池 提供消息发送接口 项目代码、在博主公众号回复【揭秘字节跳动埋点数据实时动态处理引擎】获取： 12345678910111213141516171819202122232425262728public class KafkaProducerCenter &#123; // kafka producer 池 private final ConcurrentMap&lt;String, Producer&lt;String, String&gt;&gt; producerConcurrentMap = new ConcurrentHashMap&lt;&gt;(); private Producer&lt;String, String&gt; getProducer(String topicName) &#123; // 如果 kafka producer 池中有当前 topic 的 producer，则直接返回 // 如果没有，则初始化一个新的 producer 然后返回 &#125; public void send(String topicName, String message) &#123; final ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(topicName, &quot;&quot;, message); try &#123; RecordMetadata metadata = getProducer(topicName).send(record).get(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public void close() &#123; // 关闭所有 producer 连接 &#125;&#125; 上面就是所有的代码、逻辑实现方案。其实整体看下来是非常简单的。 6. 数据保障篇-框架的保障方案 配置中心挂了怎么办？ 为这个任务分配独立的队列资源，每当这个任务加载到最新配置时，都将配置在本地存储一份。当配置中心挂了的时候，还可以直接加载机器本地的配置，不至于什么都产出不了。 怎么保障用户的配置是无误的？ 上线前审批：有专门的埋点管理人员进行逻辑验证及管理 上线前自动化测试：在埋点管理平台自动化验证逻辑正确性，保障上线到 flink 任务里的配置都是正确的 AOP 异常处理、报警：在环境中做 AOP 异常处理，将异常数据 dump 到专用异常 topic 中，也需要自动化把报警信息透出 结果验证：针对最终的结果需要有数据准确性验证机制 7. 总结与展望篇7.1.总结本文主要揭秘、实现了字节跳动埋点数据实时动态处理引擎。 7.2.展望 本文主要实现了拆流的动态化，输出数据和输入数据完全相同，但是很多情况下，下游只需要其中的一些字段。因此之后还可以做到对于 sink message 字段、消息的个性化。比如可以加一个动态化的 Map 逻辑，将数据源中的 ClientLogSource 转化为任何用户想要的 Model。 目前过滤条件完全是 java 语法，之后可以扩展成为 sql 语法，提高可读性 函数、rpc 热加载","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"测试","date":"2021-10-12T06:21:53.000Z","path":"2021/10/12/wechat-blog/test/","text":"前沿 | 流批一体的一些理解 每家数字化企业在目前遇到流批一体概念的时候，都会对这个概念抱有一些疑问，到底什么是流批一体？这个概念的来源？这个概念能为用户、开发人员以及企业带来什么样的好处？跟随着博主的理解和脑洞出发吧。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实战 | flink sql 计算 top n - 1","date":"2021-10-12T06:21:53.000Z","path":"2021/10/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/01_one-data/01_topn/","text":"感谢您的点赞 + 再看！！！ 1.序篇通过本文你可以 get 到： 背景篇 定义篇-属于哪类特点的指标 数据应用篇-预期效果是怎样的 难点剖析篇-此类指标建设、保障的难点 数据建设篇-具体实现方案详述 数据服务篇-数据服务选型 数据保障篇-数据时效监控以及保障方案 效果篇-上述方案最终的效果 现状以及展望篇 2.背景篇根据微博目前站内词条消费情况，计算 top 50 消费热度词条，每分钟更新一次，并且按照列表展现给用户。 3.定义篇-属于哪类特点的指标这类指标可以统一划分到 topN 类别的指标中。即输入是具体词条消费日志，输出是词条消费排行榜。 4.数据应用篇-预期效果是怎样的预期效果如下。 5.难点剖析篇-此类指标建设、保障的难点5.1.数据建设5.1.1.难点 榜单类的指标有一个特点，就是客户端获取到的数据必须是同一分钟当时的词条消费热度，这就要求我们产出的每一条数据需要包含 topN 中的所有数据。这样才能保障用户获取到的数据的一致性。 flink 任务大状态：词条多，状态大；词条具有时效性，所以对于低热词条需要进行删除 flink 任务大流量、高性能：数据源是全站的词条消费流量，得扛得住突发流量的暴揍 5.1.2.业界方案调研5.1.2.1.Flink DataStream api 实时计算 topN 热榜Flink DataStream api 实时计算topN热榜 优点：可以按照用户自定义逻辑计算排名，基于 watermark 推动整个任务的计算，具备数据可回溯性。 缺点：开发成本高，而本期主要介绍 flink sql 的方案，这个方案可以供大家进行参考。 结论：虽可实现，但并非 sql api 实现。 5.1.2.2.Flink SQL api 实时计算 topN 热榜Flink SQL TopN语句 Flink SQL 功能解密系列 —— 流式 TopN 挑战与实现 优点：用户理解、开发成本低 缺点：只有排名发生变化的词条才会输出，排名未发生变化数据不会输出（后续会在数据建设模块进行解释），不能做到每一条数据包含目前 topN 的所有数据的需求。 结论：不满足需求。 5.1.2.3.结论我们需要制定自己的 flink sql 解决方案，以实现上述需求。这也是本节重点要讲述的内容，即在数据建设篇-具体实现方案详述详细展开。 5.2.数据保障5.2.1.难点 flink 任务高可用 榜单数据可回溯性 5.2.2.业界方案调研 flink 任务高可用：宕机之后快速恢复；有异地多活热备链路可随时切换 榜单数据可回溯性：任务失败之后，按照词条时间数据的进行回溯 5.3.数据服务保障5.3.1.难点 数据服务引擎高可用 数据服务 server 高可用 5.3.2.业界方案调研 数据服务引擎高可用：数据服务引擎本身的高可用，异地双活实现 数据服务 server 高可用：异地双活实现；上游不更新数据，数据服务 server 模块也能查询出上一次的结果进行展示，至少不会什么数据都展示不了 6.数据建设篇-具体实现方案详述6.1.整体数据服务架构首先，我们最初的方案是如下图所示，单机房的服务端，但是很明显基本没有高可用保障。我们本文主要介绍 flink sql 方案，所以下文先介绍 flink sql，后文 6.6 介绍各种高可用、高性能优化及保障。 6.2.flink 方案设计从本节开始，正式介绍 flink sql 相关的方案设计。 我们会从以下三个角度去介绍： 数据源：了解数据源的 schema 数据汇：从数据应用角度出发设计数据汇的 schema 数据建设：从数据源、数据汇从而推导出我们要实现的 flink sql 方案 6.3.数据源数据源即安装在各位的手机微博客户端上报的用户消费明细日志，即用户消费一次某个词条，就会上报一条对应的日志。 6.3.1.schema 字段名 备注 user_id 消费词条的用户 热搜词条_name 消费词条名称 timestamp 消费词条时间戳 … … 6.4 数据汇6.4.1.schema最开始设计的 schema 如下： 字段名 字段类型 备注 timestamp bigint 当前分钟词条时间戳 热搜词条_name string 词条名 rn bigint 排名 1 - 50 但是排名展示时，需要将这一分钟的前 50 名的数据全部查询到展示。而 flink 任务输出排名数据到外部存储时，保障前 50 名的词条数据事务性的输出（要么同时输出到数据服务中，要么一条也不输出）是一件比较复杂事情。所以我们索性将前 50 名的数据全部收集到同一条数据当中，时间戳最新的一条数据就是最新的结果数据。 重新设计的 schema 如下： 字段名 字段类型 备注 timestamp bigint 当前分钟词条时间戳 热搜榜单 string 热搜榜单，schema 如 {“排名第一的词条1” : “排名第一的词条消费量”, “排名第二的词条1” : “排名第二的词条消费量”, “排名第三的词条1” : “排名第三的词条消费量”…} 前 50 名 6.5.数据建设6.5.1.方案1 - 内层 rownum + 外层自定义 udf 从排名的角度出发，自然可以想到 rownum 进行排名（阿里云也有对应的实现案例） 最终要把排行榜合并到一条数据进行输出，那就必然会涉及到自定义 udf 将排名数据进行合并 6.5.1.1.sql12345678910111213141516171819202122232425262728293031323334INSERT INTO target_db.target_tableSELECT max(timestamp) AS timestamp, 热搜_top50_json(热搜词条_name, cnt) AS data -- 外层 udaf 将所有数据进行 mergeFROM ( SELECT 热搜词条_name, cnt, timestamp, row_number() over( PARTITION by 热搜词条_name ORDER BY cnt ASC ) AS rn -- 内层 rownum 进行排名 FROM ( SELECT 热搜词条_name, count(1) AS cnt, max(timestamp) AS timestamp FROM source_db.source_table GROUP BY 热搜词条_name -- 如果有热点词条导致数据倾斜，可以加一层打散层 ) )WHERE rn &lt;= 100GROUP BY 0; 6.5.1.2.udf udaf 开发参考： https://www.alibabacloud.com/help/zh/doc-detail/69553.htm?spm=a2c63.o282931.b99.244.4ad11889wWZiHL top50_udaf：作用是将已经经过上游处理的消费量排前 100 名词条拿到进行排序后，合并成一个 top50 排行榜 json 字符串产出。 Accumulator：由需求可以知道，当前 udaf 是为了计算前 50 名的消费词条，所以 Accumulator 应该存储截止当前时间按照消费 cnt 数排名的前 100 名的词条。我们由此就可以想到使用 最小堆 来当做 Accumulator，Accumulator 中只存储消费 cnt 前 100 的数据。 最小堆的实现：https://blog.csdn.net/jiutianhe/article/details/41441881 topN 设计伪代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class 热搜_top50_json extends AggregateFunction&lt;Map&lt;String, Long&gt;, TopN&lt;Pair&lt;String, Long&gt;&gt;&gt; &#123; @Override public TopN&lt;Pair&lt;String, Long&gt;&gt; createAccumulator() &#123; // 创建 acc -&gt; 最小堆实现的 Top 50 &#125; @Override public String getValue(TopN&lt;Pair&lt;String, Long&gt;&gt; acc) &#123; // 1.将最小堆 acc 中列表数据拿到 // 2.然后将列表按照从大到小进行排序 // 3.产出结果数据 &#125; public void accumulate(TopN&lt;Pair&lt;String, Long&gt;&gt; acc, String 词条名称, long cnt) &#123; // 1.获取到当前最小堆中的最小值 // 如果当前词条的消费量 cnt 小于最小堆的堆顶 // 则直接进行过滤 // 2.如果最小堆中不存在当前词条 // 则直接将当前词条放入最小堆中 // 3.如果最小堆中已经存在当前词条存在 // 那么将最小堆中这个词条的消费 cnt 与 // 当前词条的 cnt 作比较，将大的那个放入最小堆中 &#125; public void retract(TopN&lt;Pair&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; // 不需要实现 retract 方法 // 由于 topn 具有特殊性：即我们只取每一个词条的最大值 // 进行排名，所以可以不需要实现 retract 方法 // 比较排名都在 accumulate 方法中已经实现完成 &#125;&#125; Notes： 上述 udf 最好设计成一个固定大小排行榜的 udf，比如一个 udf 实现类就只能用于处理一个固定大小的排行，防止用户进行】、误用； sql 内层计算的排行榜大小一定要比 sql 外层（聚合）排行榜大小大。举反例：假如内层计算前 30 名，外层计算前 50 名，内层 A 分桶第 31 名可能比 B 分桶第 1 名的值还大，但是 A 桶的第 31 名就不会被输出。反之则正确。 6.5.1.3.flink-conf.yaml 参数配置由于上述 sql 是在无限流上的操作，所以上游数据每更新一次都会向下游发送一次 retract 消息以及最新的数据的消息进行计算。 那么就会存在这样一个问题，即 source qps 为 x 时，任务内的吞吐就为 x * n 倍，sink qps 也为 x，这会导致性能大幅下降的同时也会导致输出结果数据量非常大。 而我们只需要每分钟更新一次结果即可，所以可以使用 flink sql 自带的 minibatch 参数来控制输出结果的频次。 minibatch 具体参考可参考下面两篇文章： https://www.alibabacloud.com/help/zh/doc-detail/182012.htm?spm=a2c63.p38356.b99.288.698a785cSiDhEG https://www.jianshu.com/p/aa2e94628e24 1234567table.exec.mini-batch.enabled : true-- minibatch 是下面两个任意一个符合条件就会起触发计算-- 60s 一次table.exec.mini-batch.allow-latency : 60 s-- 数量达到 10000000000 触发一次-- 设置为 10000000000 是为了让上面的 allow-latency 触发，每 60s 输出一次来满足我们的需求table.exec.mini-batch.size : 10000000000 状态过期，如果不设置的话，词条状态会越来越大，对非高热词条进行清除。 http://apache-flink.147419.n8.nabble.com/Flink-sql-state-ttl-td10158.html 123-- 设置 1 天的 ttl，如果一天过后-- 这个词条还没有更新，则直接删除table.exec.state.ttl : 86400 s 6.5.2.方案2 - 自定义 udf 自定义排名 udf 6.5.2.1.sql1234567891011121314151617181920212223INSERT INTO target_db.target_tableSELECT max(timestamp) AS timestamp, -- udf 计算每一个分桶的前 100 名列表 热搜_top50_json(cast(热搜词条_name AS string), cnt) AS bucket_top100FROM ( SELECT 热搜词条_name AS 热搜词条_name, count(1) AS cnt, max(timestamp) AS timestamp FROM source_db.source_table GROUP BY 热搜词条_name -- 如果有热点词条导致数据倾斜 -- 可以加一层打散层 )GROUP BY 0-- 由于这里是 group by 0-- 所以可能会到导致热点，所以如果需要也可以加一层打散层-- 在内部先算 top50，在外层将内部分桶的 top50 榜单进行 merge 6.5.2.2.udf此 udf 与 方案1 的 udf（见 6.5.1.2.udf） 完全相同。 6.5.2.3.flink-conf.yaml 参数配置参数同 6.5.1.3 flink-conf.yaml 参数配置 6.6.高可用、高性能6.6.1.整体高可用保障异地双链路热备如下图： 可能会发现图中有异地机房，但是我们目前只画出了 A 地区机房的数据链路，B 地区机房还没有画全，接着我们一步一步将这个图进行补全。 Notes： 异地双机房只是双链路的热备的一种案例。如果有同城双机房、双集群也可进行同样的服务部署。 为什么说异地机房的保障能力 &gt; 同城异地机房 &gt; 同城同机房双集群容灾能力？ 同城同机房：只要这个机房挂了，即使你有两套链路也没救。同城异地机房：很小几率情况会同城异地两个机房都挂了。。异地机房：几乎不可能同时异地两个机房都被炸了。。。 6.6.1.1.数据源日志高可用 数据源日志 server 服务高可用：异地机房，当一个机房挂了之后，在客户端可以自动将日志发送到另一个机房的 webserver 数据源日志 kafka 服务高可用：kafka 使用异地机房 topic，其实就是两个 topic，每个机房一个 topic，两个 topic 互为热备，producer 在向下游两个机房的 topic 写数据时，可以将 50% 的流量写入一个机房，另外 50% 的流量写入另一个机房，一旦一个机房的 kafka 集群宕机，则 producer 端可以自动将 100% 的流量切换到另一个机房的 kafka。 正常情况下如图所示： 当发生 A 地机房 webserver 宕机时，客户端自动切换上报日志至 B 地机房 webserver。如下图所示： kafka 也相同。如下图所示： 6.6.1.2.flink 任务高可用flink 任务以 A 地机房做主链路，B 地机房启动相同的任务做热备双跑链路。 当 A 地机房 flink 任务宕机且无法恢复时，则 B 地机房的任务做热备替换。 正常情况下如图所示： 当 A 地机房 flink 任务宕机且无法恢复时，热备链路 flink 任务就可以顶上。如下图所示： 6.6.1.3.数据服务高可用正常情况如下： 当 A 地 OLAP 或者 KV 存储挂了之后，webserver 可以自动切换至 B 地 OLAP 或者 KV 存储。如下图所示： 当 A 地 webserver 挂了之后，客户端可以自动拉取 B 地 webserver 数据，如下图所示： 6.6.2.大流量、高性能6.6.2.1.数据源 数据源、汇反序列化性能提升：静态反序列化性能 &gt; 动态反序列化性能。举例 ProtoBuf。可以在 source 端先进行代码生成，然后用生成好的代码去反序列化源消息的性能会远好于使用 ProtoBuf Dynamic Message。flink 官方实现 6.6.3.缩减状态大小 将状态中的 string 长度做映射之后变小 rocksdb 增量 checkpoint，减小任务做 checkpoint 的压力 7.数据服务篇-数据服务选型7.1.kv 存储根据我们上述设计的数据汇 schema 来看，最适合存储引擎就是 kv 引擎，因为前端只需要展示最新的排行榜数据即可。所以我们可以使用 redis 等 kv 存储引擎来存储最新的数据。 7.2.OLAP如果用户有需求需要记录上述数据的历史记录，我们也可以使用时序数据库或者 OLAP 引擎直接进行存储。 8.数据保障篇-数据时效监控以及保障方案8.1.数据时效保障见下文。 8.2.数据质量保障数据质量保障篇楼主正在 gang… 9.效果篇-上述方案最终的效果9.1.输出结果示例123456&#123; &quot;黄子韬 杨紫是我哥们&quot;: 1672825, &quot;延乔墓前的来信破防了&quot;: 1087416, &quot;孟子义 张翰同学站起来&quot;: 747703 // ...&#125; 9.2.应用产品示例 10.现状以及展望篇 虽然上述 udf 是通用的 udf，但是是否能够脱离自定义 udf，直接计算出 top 50 的值？ 我目前的一个想法就是将结果 schema 拍平。举例： 字段名 字段类型 备注 timestamp bigint 当前分钟事件时间戳 热搜词条_1 string 第一名的热搜词条名称 热搜词条_2 string 第二名的热搜词条名称 热搜词条_3 string 第三名的热搜词条名称 热搜词条_4 string 第四名的热搜词条名称 热搜词条_5 string 第五名的热搜词条名称 … … … 热搜词条_n string 第 n 名的词条名称 每一次输出都将目前每一个排名的数据产出。但是目前在 flink sql 的实现思路上不太明了。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实战 | flink sql 计算多维 puv","date":"2021-10-12T06:21:53.000Z","path":"2021/10/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/01_one-data/02_dau-rownum/","text":"前沿 | 流批一体的一些理解 每家数字化企业在目前遇到流批一体概念的时候，都会对这个概念抱有一些疑问，到底什么是流批一体？这个概念的来源？这个概念能为用户、开发人员以及企业带来什么样的好处？跟随着博主的理解和脑洞出发吧。 通过本文你可以 get 到： 1. 2. 3. 4. 1.背景多维 dau 相关指标。 2.指标拆解多维 dau。 3.数据应用3.1.应用层展示 3.2.数据服务架构 4.数据建设4.1.数据源数据源即安装在各位的手机微博客户端上报的用户消费明细日志，即用户消费一次某个事件，就会上报一条对应的日志。 4.1.1.schema 字段名 备注 user_id 消费事件的用户 event_name 消费事件名称 timestamp 消费事件时间戳 … … 4.2 数据汇4.2.1.schema最开始设计的 schema 如下： 字段名 字段类型 备注 timestamp bigint 当前分钟事件时间戳 event_name string 事件名 rn bigint 排名 1 - 50 但是排名展示时，需要将这一分钟前 50 名的数据全部查询到展示。而 flink 任务输出排名数据到外部存储时，保障前 50 名的事件数据事务性的输出是一件比较复杂事情。所以我们索性将前 50 名的数据全部收集到同一条数据当中，时间戳最新的一条数据就是最新的结果数据。 重新设计的 schema 如下： 字段名 字段类型 备注 timestamp bigint 当前分钟事件时间戳 top50_list string top50 榜单，scheam 如 {1 : “排名第一的事件1”, 2 : “排名第二的事件1”, 3 : “排名第三的事件1”…} 前 50 名 4.3.数据建设4.3.1.方案1 - 内层 rownum + 外层自定义 udf4.3.1.1.sql12345678910111213141516171819202122232425262728293031323334353637383940414243INSERT INTO target_db.target_tableSELECT max(timestamp) AS timestamp, top50_udaf(event_name, cnt) AS dataFROM ( SELECT event_name, cnt, timestamp, row_number() over( PARTITION by event_name ORDER BY cnt ASC ) AS rn FROM ( SELECT event_name, sum(cnt) AS cnt, max(timestamp) AS timestamp FROM ( SELECT event_name, count(1) AS cnt, max(timestamp) AS timestamp FROM source_db.source_table GROUP BY event_name, hash_mod_bucket(user_id, 2048) ) GROUP BY event_name ) )WHERE rn &lt;= 100GROUP BY 0; 4.3.1.2.udf udaf 开发参考： https://www.alibabacloud.com/help/zh/doc-detail/69553.htm?spm=a2c63.o282931.b99.244.4ad11889wWZiHL top50_udaf：作用是将已经经过上游处理的消费量排前 100 名事件拿到进行排序后，合并成一个排行榜 json 字符串产出。 Accumulator：由需求可以知道，当前 udaf 是为了计算前 50 名的消费事件，所以 Accumulator 应该存储截止当前时间按照消费 cnt 数排名的前 100 名的事件。我们由此就可以想到使用 最小堆 来当做 Accumulator，Accumulator 中只存储消费 cnt 前 100 的数据。 最小堆的实现参考：https://blog.csdn.net/jiutianhe/article/details/41441881 1234567891011121314151617181920212223242526272829303132public class TopN&lt;T&gt; implements Serializable &#123; private final PriorityQueue&lt;T&gt; queue; private final int maxSize; private final Comparator&lt;T&gt; comparator; public PriorityQueue&lt;T&gt; getQueue() &#123; return queue; &#125; public TopN(int maxSize, Comparator&lt;T&gt; comparator) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(); &#125; this.maxSize = maxSize; this.queue = new PriorityQueue&lt;T&gt;(maxSize, comparator); this.comparator = comparator; &#125; public void add(T e) &#123; if (queue.size() &lt; this.maxSize) &#123; queue.add(e); &#125; else &#123; // 如果队列已经超过 maxSize，则与最小堆堆顶的元素（最小值）进行比较判断 T peek = queue.peek(); if (comparator.compare(e, peek) &gt; 0) &#123; queue.poll(); queue.add(e); &#125; &#125; &#125;&#125; topN 通用基类实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public abstract class TopN_UDAF extends AggregateFunction&lt;Map&lt;String, Long&gt;, TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; &#123; private int topN; public TopN_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public TopN&lt;Tuple2&lt;String, Long&gt;&gt; createAccumulator() &#123; // 创建 acc -&gt; 最小堆实现的 TopN return new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); &#125; @Override public Map&lt;String, Long&gt; getValue(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc) &#123; // 将最小堆中数据拿到，然后排序之后放入结果 map 中传出 PriorityQueue&lt;Tuple2&lt;String, Long&gt;&gt; p = acc.getQueue(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = p.stream() .collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); Map&lt;String, Long&gt; map = Maps.newLinkedHashMap(); top100List.forEach(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; map.put(t.f0, t.f1); &#125; &#125;); return map; &#125; public void accumulate(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; // 获取到当前结果中的最小值，如果当前时间的消费 cnt 小于最小堆中的结果，直接进行过滤 long min = CollectionUtils.isNotEmpty(acc.getQueue()) ? acc.getQueue().peek().f1 : 0L; if (cnt &gt; min) &#123; // 1.如果最小堆中不存在当前事件，则直接将当前时间放入最小堆中； // 2.如果最小堆中已经存在当前事件存在，那么将消费 cnt 大的那个放入最小堆中 Tuple2&lt;String, Long&gt; t = Tuple2.of(id, cnt); Map&lt;String, Long&gt; idCntMap = acc.getQueue() .stream() .collect(Collectors.toMap(tInner -&gt; tInner.f0, tInner -&gt; tInner.f1)); Long oldCnt = idCntMap.get(id); if (null == oldCnt) &#123; acc.add(t); &#125; else &#123; if (cnt &gt; oldCnt) &#123; acc.getQueue().remove(Tuple2.of(id, oldCnt)); acc.add(t); &#125; &#125; &#125; &#125; public void retract(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; // 由于 topn 具有特殊性：即我们只取每一个事件的最大值进行排名，所以可以不需要实现 retract 方法，比较排名都在 accumulate 方法中已经实现完成 &#125; @Override public TypeInformation&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;Map&lt;String, Long&gt;&gt; getResultType() &#123; return TypeInformation.of(new TypeHint&lt;Map&lt;String, Long&gt;&gt;() &#123; &#125;); &#125;&#125; top100 实现类如下： 123456public class Top100_UDAF extends TopN_UDAF &#123; public Top100_UDAF() &#123; super(100); &#125;&#125; 或者也可以通过 open 方法动态获取到 topN 的配置参数，具体方式实现如下： 12345@Overridepublic void open(FunctionContext context) throws Exception &#123; super.open(context); this.topN = Integer.parseInt(context.getJobParameter(&quot;TopN_UDAF.topN&quot;, &quot;100&quot;));&#125; 4.3.1.3.flink-conf.yaml 参数配置由于上述 sql 是在 unbounded 流上的操作，所以上游数据每更新一次都会向下游发送一次 retract 消息以及最新的数据的消息进行计算。 举例即 source qps 为 x 时，任务内的吞吐就为 x * n 倍，sink qps 为 x，这样会导致性能大幅下降的同时也会导致输出结果数据量非常大。而我们只需要每分钟更新一次结果即可，所以可以使用 flink sql 自带的 minibatch 参数来控制输出结果的频次。 minibatch 具体参考可参考下面两篇文章： https://www.alibabacloud.com/help/zh/doc-detail/182012.htm?spm=a2c63.p38356.b99.288.698a785cSiDhEG https://www.jianshu.com/p/aa2e94628e24 1234table.exec.mini-batch.enabled : truetable.exec.mini-batch.allow-latency : 60 s-- 设置为 10000000000 是为了让上面的 allow-latency 起作用，每 60s 输出一次table.exec.mini-batch.size : 10000000000 状态过期，如果不设置的话，事件状态会越来越大。 12-- 设置 1 天的 ttl，如果一天过后这个事件还没有更新，则直接删除table.exec.state.ttl : 86400 s 4.3.2.方案2 - 内外层自定义 udf4.3.2.1.sql12345678910111213141516171819202122232425262728293031323334353637INSERT INTO target_db.target_tableSELECT -- 计算整体的前 50 名列表 top50_aggr_udaf(bucket_top100) AS top50_list, max(timestamp) AS timestampFROM ( SELECT max(timestamp) AS timestamp, -- udf 计算每一个分桶的前 100 名列表 top100_udaf(cast(event_name AS string), cnt) AS bucket_top100 FROM ( SELECT event_name, sum(cnt) AS cnt, -- 计算消费 cnt 数 max(timestamp) AS timestamp FROM ( SELECT event_name AS event_name, count(1) AS cnt, max(timestamp) AS timestamp FROM source_db.source_table GROUP BY event_name, -- 将数据打散，防止数据倾斜 hash_mod_bucket(user_id, 2048) ) GROUP BY event_name ) GROUP BY -- 将数据打散，防止数据倾斜 hash_mod_bucket(event_name, 2048) )GROUP BY 0; 4.3.2.2.udf4.3.2.2.1.top100_udaf此 udf 与 方案1 的 topN udf（见 4.2.1.2.udf） 完全相同。 4.3.2.2.2.top50_aggr_udaf Accumulator：依然同 top100_udaf 的实现，使用 最小堆 来当做 Accumulator； accmulate：接受上游分桶中的数据，然后将每个桶中的事件获取到之后按照消费 cnt 与当前的 Accumulator 进行 merge 操作； getValue：将 Accumulator 结果获取到之后放在 map 中并将结果输出； retract：同上，也不需要实现，将各个分桶的结果做 merge 即可； 基类实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public abstract class TopNAggr_UDAF extends AggregateFunction&lt;String, TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; &#123; // topN private int topN; public TopNAggr_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public TopN&lt;Tuple2&lt;String, Long&gt;&gt; createAccumulator() &#123; return new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); &#125; @Override public String getValue(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc) &#123; // 将结果从 acc 中拿到之后，其结果是乱序的，所以要把结果列表拿到之后进行再进行一遍排序 LinkedHashMap&lt;String, Map&lt;String, Long&gt;&gt; map = Maps.newLinkedHashMap(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = acc .getQueue() .stream() .collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o2.f1.compareTo(o1.f1); &#125; &#125;); int i = 1; for (Tuple2&lt;String, Long&gt; t : topNList) &#123; map.put(i + &quot;&quot;, ImmutableMap.of(t.f0, t.f1)); i++; &#125; return ObjectMapperUtils.toJSON(map); &#125; public void accumulate(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, Map&lt;String, Long&gt; map) &#123; // 将 Accumulator 与分桶数据按照消费 cnt merge Map&lt;String, Long&gt; idCntMap = new HashMap&lt;&gt;(); acc.getQueue().forEach(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; Long cnt = idCntMap.get(t.f0); if (null == cnt) &#123; idCntMap.put(t.f0, t.f1); &#125; else &#123; idCntMap.put(t.f0, cnt &gt; t.f1 ? cnt : t.f1); &#125; &#125; &#125;); map.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Long cnt = idCntMap.get(s); if (null == cnt) &#123; idCntMap.put(s, l); &#125; else &#123; idCntMap.put(s, cnt &gt; l ? cnt : l); &#125; &#125; &#125;); acc.getQueue().clear(); idCntMap.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; acc.add(Tuple2.of(s, l)); &#125; &#125;); &#125; public void retract(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, Map&lt;String, Long&gt; map) &#123; // 无需实现 &#125; @Override public TypeInformation&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;String&gt; getResultType() &#123; return TypeInformation.of(String.class); &#125;&#125; top50 实现类如下： 12345public class Top50Aggr_UDAF extends TopNAggr_UDAF &#123; public Top50Aggr_UDAF() &#123; super(50); &#125;&#125; 或者也可以通过 open 方法动态获取到 topN 的配置参数，具体方式实现如下： 12345@Overridepublic void open(FunctionContext context) throws Exception &#123; super.open(context); this.topN = Integer.parseInt(context.getJobParameter(&quot;TopNAggr_UDAF.topN&quot;, &quot;50&quot;));&#125; 4.3.2.3.flink-conf.yaml 参数配置参数同 4.2.1.3 flink-conf.yaml 参数配置 4.3.3.方案3 - cumulate window4.3.3.1.sql12345678910111213141516171819202122232425262728INSERT INTO target_db.target_tableSELECT top50_aggr_udaf(bucket_top100, cast(10 AS bigint)) AS top50_list, cast(TUMBLE_START(timestamp, INTERVAL &#x27;60&#x27; SECOND) AS bigint) * 1000 AS timestampFROM ( SELECT top100_udaf(cast(event_name AS string), cnt) AS bucket_top100, TUMBLE_ROWTIME(timestamp, INTERVAL &#x27;60&#x27; SECOND) AS timestamp FROM ( SELECT event_name, count(1) AS cnt, cumulate_rowtime(timestamp, INTERVAL &#x27;60&#x27; SECOND, INTERVAL &#x27;1&#x27; DAY) AS timestamp FROM source_db.source_table GROUP BY event_name, CUMULATE(timestamp, INTERVAL &#x27;60&#x27; SECOND, INTERVAL &#x27;1&#x27; DAY) ) GROUP BY hash_mod_bucket(event_name), TUMBLE(window_start, INTERVAL &#x27;60&#x27; SECOND) )GROUP BY TUMBLE(window_start, INTERVAL &#x27;60&#x27; SECOND) 4.3.3.2.udf4.3.3.2.1.top100_udaf Accumulator：由需求可以知道，当前 udaf 是为了计算前 100 名的消费事件，所以 Accumulator 应该存储截止当前时间按照消费 cnt 数排名的前 100 名的事件。我们由此就可以想到使用 最小堆 来当做 Accumulator，Accumulator 中只存储消费 cnt 前 100 的数据。 getValue：将 Accumulator 中的数据转换为 map 格式输出； acumulate：将事件以及消费 cnt 存入 topN Accumulator 中； merge：将所有 topN Accumulator 进行 merge 操作，取所有 topN 最大的； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public abstract class TopN_UDAF extends AggregateFunction&lt;Map&lt;String, Long&gt;, TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; &#123; private int topN; public TopN_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public TopN&lt;Tuple2&lt;String, Long&gt;&gt; createAccumulator() &#123; return new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); &#125; @Override public Map&lt;String, Long&gt; getValue(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc) &#123; PriorityQueue&lt;Tuple2&lt;String, Long&gt;&gt; p = acc.getQueue(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = p.stream().collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); Map&lt;String, Long&gt; map = Maps.newLinkedHashMap(); topNList.forEach(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; map.put(t.f0, t.f1); &#125; &#125;); return map; &#125; public void accumulate(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; Tuple2&lt;String, Long&gt; t = Tuple2.of(id, cnt); acc.add(t); &#125; public void merge(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, Iterable&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; its) &#123; its.forEach(new Consumer&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; @Override public void accept(TopN&lt;Tuple2&lt;String, Long&gt;&gt; topN) &#123; topN.getQueue().iterator().forEachRemaining(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; acc.add(t); &#125; &#125;); &#125; &#125;); &#125; @Override public TypeInformation&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;Map&lt;String, Long&gt;&gt; getResultType() &#123; return TypeInformation.of(new TypeHint&lt;Map&lt;String, Long&gt;&gt;() &#123; &#125;); &#125;&#125; 4.3.3.2.2.top50Aggr_udaf getValue：将 Accumulator 结果获取到之后，拿到 top50 之后放在 map 中并将结果输出； acumulate：将内层桶的数据合并到当前 Acumulator 中，即将内层分桶的所有事件的数据以及消费 cnt 拿到之后进行累加； merge：将 Accumulator 合并，相同事件的消费 cnt 相加； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public abstract class TopNAggr_UDAF extends AggregateFunction&lt;String, Map&lt;String, Long&gt;&gt; &#123; private int topN; public TopNAggr_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public Map&lt;String, Long&gt; createAccumulator() &#123; return Maps.newHashMap(); &#125; @Override public String getValue(Map&lt;String, Long&gt; acc) &#123; TopN&lt;Tuple2&lt;String, Long&gt;&gt; topN = new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); acc.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Tuple2&lt;String, Long&gt; t = Tuple2.of(s, l); topN.add(t); &#125; &#125;); LinkedHashMap&lt;String, Map&lt;String, Long&gt;&gt; map = Maps.newLinkedHashMap(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = topN .getQueue() .stream() .collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o2.f1.compareTo(o1.f1); &#125; &#125;); int i = 1; for (Tuple2&lt;String, Long&gt; t : topNList) &#123; map.put(i + &quot;&quot;, ImmutableMap.of(t.f0, t.f1)); i++; &#125; return ObjectMapperUtils.toJSON(map); &#125; public void accumulate(Map&lt;String, Long&gt; acc, Map&lt;String, Long&gt; map) &#123; map.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Long history = acc.get(s); if (null != history) &#123; acc.put(s, l + history); &#125; else &#123; acc.put(s, l); &#125; &#125; &#125;); &#125; public void merge(Map&lt;String, Long&gt; acc, Iterable&lt;Map&lt;String, Long&gt;&gt; its) &#123; its.forEach(new Consumer&lt;Map&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Map&lt;String, Long&gt; map) &#123; map.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Long history = acc.get(s); if (null != history) &#123; acc.put(s, l + history); &#125; else &#123; acc.put(s, l); &#125; &#125; &#125;); &#125; &#125;); &#125; @Override public TypeInformation&lt;Map&lt;String, Long&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;Map&lt;String, Long&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;String&gt; getResultType() &#123; return TypeInformation.of(String.class); &#125;&#125; 4.3.3.2.3.flink-conf.yaml 参数配置时间戳的时区设置，注意需要我们将时区设置为本地的时区。 12-- 北京时区table.local-time-zone : GMT+08:00 4.3.4.方案4 - 不使用自定义 UDF4.3.5.UDF 设计注意项 上述 udf 最好设计成一个固定大小排行榜的 udf，比如一个 udf 实现类就只能用于处理一个固定大小的排行，防止用户误用； sql 内层计算的排行榜大小一定要比 sql 外层（聚合）排行榜大小大。举反例：假如内层计算前 30 名，外层计算前 50 名，内层 A 分桶第 31 名可能比 B 分桶第 1 名的值还大，但是 A 桶的第 31 名就不会被输出。反之则正确。 5.数据服务5.1.kv 存储根据我们上述设计的数据汇 schema 来看，最适合存储引擎就是 kv 引擎，因为前端只需要展示最新的排行榜数据即可。所以我们可以使用 redis 等 kv 存储引擎来存储最新的数据。 5.2.OLAP如果用户有需求需要记录上述数据的历史记录，我们也可以使用时序数据库或者 OLAP 引擎直接进行存储。 6.数据保障6.1.数据时延保障6.1.1.整体时延整体时延等于下面三个时延加和： 数据源时延（日志 webserver 本地时间戳 - 数据时间戳） 数据处理时延（flink 任务的整体处理时延） 数据传输时延（数据在中间层写入消息队列以及读出消息队列的时延） 整体时延 = 数据应用层服务端本地时间戳 - 结果数据的事件时间戳 6.1.1.数据源时延指数据本身上报就会存在的时延。 举例：从用户发生消费事件 -&gt; 产生消费日志 -&gt; 将日志上报到日志服务器，这期间存在的时延。 6.1.1.1.监控方式在 ods -&gt; dwd 层处理过程中，添加处理任务系统当前时间 - 服务端时间戳的监控（P99 等）。 那么这里衍生出一个问题，为什么不用客户端时间戳呢？ 因为客户端的软件版本、网络环境、机型、地区都是各种各样的，从而会导致上报上来的日志的客户端时间戳（用户操作时间戳）的准确性是参差不齐的。因此这里我们采用服务端时间戳（日志上报到服务端时，服务端的本地时间戳）来避免这种问题。 6.1.2.数据处理时延指 flink 处理计算的耗时。 6.1.2.1.监控方式flink 本身自带有 latency marker 机制（详见 flink latency marker），但是这个机制会有性能损耗，官方建议只在测试阶段进行使用。 这其实已经足够，因为我们在测试阶段就可以基本测试出，flink 任务处理计算的耗时情况。 或者也可以大致通过 flink 处理逻辑推算出处理延迟。 6.2.数据质量保障6.3.数据服务保障","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实战 | flink sql 计算 top n - 1","date":"2021-10-12T06:21:53.000Z","path":"2021/10/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/01_one-data/01_topn_code_pdf/","text":"每家数字化企业在目前遇到流批一体概念的时候，都会对这个概念抱有一些疑问，到底什么是流批一体？这个概念的来源？这个概念能为用户、开发人员以及企业带来什么样的好处？跟随着博主的理解和脑洞出发吧。 1.序篇通过本文你可以 get 到： 背景篇 定义篇-属于哪类特点的指标 数据应用篇-预期效果是怎样的 难点剖析篇-此类指标建设、保障的难点 数据建设篇-具体实现方案详述 数据服务篇-数据服务选型 数据保障篇-数据时效监控以及保障方案 效果篇-上述方案最终的效果 现状以及展望篇 2.背景篇根据目前站内词条消费情况，计算 top 50 消费热度词条，每分钟更新一次，并且按照列表展现给用户。 其实就是类似于微博的热搜榜。 3.定义篇-属于哪类特点的指标这类指标可以统一划分到 topN 类别的指标中。即输入是具体词条消费日志，输出是词条消费排行榜。 4.数据应用篇-预期效果是怎样的预期效果如下，即与微博热搜榜相同，都属于实时热点，一分钟更新一次。 5.难点剖析篇-此类指标建设、保障的难点5.1.数据建设5.1.1.难点 榜单类的指标有一个特点，就是客户端获取到的数据必须是同一分钟当时的词条消费热度，这就要求我们产出的每一条数据需要包含 topN 中的所有数据。这样才能保障用户获取到的数据的一致性。 flink 任务大状态：词条多，状态大；词条具有时效性，所以对于低热词条需要进行删除 flink 任务大流量、高性能：数据源是全站的词条消费流量，得扛得住突发流量的暴揍 5.1.2.业界方案调研5.1.2.1.Flink DataStream api 实时计算 topN 热榜Flink DataStream api 实时计算topN热榜 优点：可以按照用户自定义逻辑计算排名，基于 watermark 推动整个任务的计算，具备数据可回溯性。 缺点：开发成本高，而本期主要介绍 flink sql 的方案，这个方案可以供大家进行参考。 结论：虽可实现，但并非 sql api 实现。 5.1.2.2.Flink SQL api 实时计算 topN 热榜Flink SQL TopN语句 Flink SQL 功能解密系列 —— 流式 TopN 挑战与实现 优点：用户理解、开发成本低 缺点：只有排名发生变化的词条才会输出，排名未发生变化数据不会输出（后续会在数据建设模块进行解释），不能做到每一条数据包含目前 topN 的所有数据的需求。 结论：不满足需求。 5.1.2.3.结论我们需要制定自己的 flink sql 解决方案，以实现上述需求。这也是本节重点要讲述的内容，即在数据建设篇-具体实现方案详述详细展开。 5.2.数据保障5.2.1.难点 flink 任务高可用 榜单数据可回溯性 5.2.2.业界方案调研 flink 任务高可用：宕机之后快速恢复；有异地多活热备链路可随时切换 榜单数据可回溯性：任务失败之后，按照词条时间数据的进行回溯 5.3.数据服务保障5.3.1.难点 数据服务引擎高可用 数据服务 server 高可用 5.3.2.业界方案调研 数据服务引擎高可用：数据服务引擎本身的高可用，异地双活实现 数据服务 server 高可用：异地双活实现；上游不更新数据，数据服务 server 模块也能查询出上一次的结果进行展示，至少不会什么数据都展示不了 6.数据建设篇-具体实现方案详述6.1.整体数据服务架构首先，我们最初的方案是如下图所示，单机房的服务端，但是很明显基本没有高可用保障。我们本文主要介绍 flink sql 方案，所以下文先介绍 flink sql，后文 6.6 介绍各种高可用、高性能优化及保障。 6.2.flink 方案设计从本节开始，正式介绍 flink sql 相关的方案设计。 我们会从以下三个角度去介绍： 数据源：了解数据源的 schema 数据汇：从数据应用角度出发设计数据汇的 schema 数据建设：从数据源、数据汇从而推导出我们要实现的 flink sql 方案 6.3.数据源数据源即安装在各位的手机微博客户端上报的用户消费明细日志，即用户消费一次某个词条，就会上报一条对应的日志。 6.3.1.schema 字段名 备注 user_id 消费词条的用户 热搜词条_name 消费词条名称 timestamp 消费词条时间戳 … … 6.4 数据汇6.4.1.schema最开始设计的 schema 如下： 字段名 字段类型 备注 timestamp bigint 当前分钟词条时间戳 热搜词条_name string 词条名 rn bigint 排名 1 - 50 但是排名展示时，需要将这一分钟的前 50 名的数据全部查询到展示。而 flink 任务输出排名数据到外部存储时，保障前 50 名的词条数据事务性的输出（要么同时输出到数据服务中，要么一条也不输出）是一件比较复杂事情。所以我们索性将前 50 名的数据全部收集到同一条数据当中，时间戳最新的一条数据就是最新的结果数据。 重新设计的 schema 如下： 字段名 字段类型 备注 timestamp bigint 当前分钟词条时间戳 top50_list string top50 榜单，scheam 如 {1 : “排名第一的词条1”, 2 : “排名第二的词条1”, 3 : “排名第三的词条1”…} 前 50 名 6.5.数据建设6.5.1.方案1 - 内层 rownum + 外层自定义 udf 从排名的角度出发，自然可以想到 rownum 进行排名 最终要把排行榜合并到一条数据进行输出，那就必然会涉及到自定义 udf 将排名数据进行合并 6.5.1.1.sql12345678910111213141516171819202122232425262728293031323334353637383940414243INSERT INTO target_db.target_tableSELECT max(timestamp) AS timestamp, top50_udaf(热搜词条_name, cnt) AS data -- 外层 udaf 将所有数据进行 mergeFROM ( SELECT 热搜词条_name, cnt, timestamp, row_number() over( PARTITION by 热搜词条_name ORDER BY cnt ASC ) AS rn -- 内层 rownum 进行排名 FROM ( SELECT 热搜词条_name, sum(cnt) AS cnt, max(timestamp) AS timestamp FROM ( SELECT 热搜词条_name, count(1) AS cnt, max(timestamp) AS timestamp FROM source_db.source_table GROUP BY 热搜词条_name, hash_mod_bucket(user_id, 2048) ) GROUP BY 热搜词条_name ) )WHERE rn &lt;= 100GROUP BY 0; 6.5.1.2.udf udaf 开发参考： https://www.alibabacloud.com/help/zh/doc-detail/69553.htm?spm=a2c63.o282931.b99.244.4ad11889wWZiHL top50_udaf：作用是将已经经过上游处理的消费量排前 100 名词条拿到进行排序后，合并成一个 top50 排行榜 json 字符串产出。 Accumulator：由需求可以知道，当前 udaf 是为了计算前 50 名的消费词条，所以 Accumulator 应该存储截止当前时间按照消费 cnt 数排名的前 100 名的词条。我们由此就可以想到使用 最小堆 来当做 Accumulator，Accumulator 中只存储消费 cnt 前 100 的数据。 最小堆的实现参考：https://blog.csdn.net/jiutianhe/article/details/41441881 1234567891011121314151617181920212223242526272829303132public class TopN&lt;T&gt; implements Serializable &#123; private final PriorityQueue&lt;T&gt; queue; private final int maxSize; private final Comparator&lt;T&gt; comparator; public PriorityQueue&lt;T&gt; getQueue() &#123; return queue; &#125; public TopN(int maxSize, Comparator&lt;T&gt; comparator) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(); &#125; this.maxSize = maxSize; this.queue = new PriorityQueue&lt;T&gt;(maxSize, comparator); this.comparator = comparator; &#125; public void add(T e) &#123; if (queue.size() &lt; this.maxSize) &#123; queue.add(e); &#125; else &#123; // 如果队列已经超过 maxSize，则与最小堆堆顶的元素（最小值）进行比较判断 T peek = queue.peek(); if (comparator.compare(e, peek) &gt; 0) &#123; queue.poll(); queue.add(e); &#125; &#125; &#125;&#125; topN 通用基类实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public abstract class TopN_UDAF extends AggregateFunction&lt;Map&lt;String, Long&gt;, TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; &#123; private int topN; public TopN_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public TopN&lt;Tuple2&lt;String, Long&gt;&gt; createAccumulator() &#123; // 创建 acc -&gt; 最小堆实现的 TopN return new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); &#125; @Override public Map&lt;String, Long&gt; getValue(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc) &#123; // 将最小堆中数据拿到，然后排序之后放入结果 map 中传出 PriorityQueue&lt;Tuple2&lt;String, Long&gt;&gt; p = acc.getQueue(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = p.stream() .collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); Map&lt;String, Long&gt; map = Maps.newLinkedHashMap(); top100List.forEach(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; map.put(t.f0, t.f1); &#125; &#125;); return map; &#125; public void accumulate(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; // 获取到当前结果中的最小值，如果当前时间的消费 cnt 小于最小堆中的结果，直接进行过滤 long min = CollectionUtils.isNotEmpty(acc.getQueue()) ? acc.getQueue().peek().f1 : 0L; if (cnt &gt; min) &#123; // 1.如果最小堆中不存在当前词条，则直接将当前时间放入最小堆中； // 2.如果最小堆中已经存在当前词条存在，那么将消费 cnt 大的那个放入最小堆中 Tuple2&lt;String, Long&gt; t = Tuple2.of(id, cnt); Map&lt;String, Long&gt; idCntMap = acc.getQueue() .stream() .collect(Collectors.toMap(tInner -&gt; tInner.f0, tInner -&gt; tInner.f1)); Long oldCnt = idCntMap.get(id); if (null == oldCnt) &#123; acc.add(t); &#125; else &#123; if (cnt &gt; oldCnt) &#123; acc.getQueue().remove(Tuple2.of(id, oldCnt)); acc.add(t); &#125; &#125; &#125; &#125; public void retract(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; // 由于 topn 具有特殊性：即我们只取每一个词条的最大值进行排名，所以可以不需要实现 retract 方法，比较排名都在 accumulate 方法中已经实现完成 &#125; @Override public TypeInformation&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;Map&lt;String, Long&gt;&gt; getResultType() &#123; return TypeInformation.of(new TypeHint&lt;Map&lt;String, Long&gt;&gt;() &#123; &#125;); &#125;&#125; top100 实现类如下： 123456public class Top100_UDAF extends TopN_UDAF &#123; public Top100_UDAF() &#123; super(100); &#125;&#125; 或者也可以通过 open 方法动态获取到 topN 的配置参数，具体方式实现如下： 12345@Overridepublic void open(FunctionContext context) throws Exception &#123; super.open(context); this.topN = Integer.parseInt(context.getJobParameter(&quot;TopN_UDAF.topN&quot;, &quot;100&quot;));&#125; Notes： 上述 udf 最好设计成一个固定大小排行榜的 udf，比如一个 udf 实现类就只能用于处理一个固定大小的排行，防止用户误用； sql 内层计算的排行榜大小一定要比 sql 外层（聚合）排行榜大小大。举反例：假如内层计算前 30 名，外层计算前 50 名，内层 A 分桶第 31 名可能比 B 分桶第 1 名的值还大，但是 A 桶的第 31 名就不会被输出。反之则正确。 6.5.1.3.flink-conf.yaml 参数配置由于上述 sql 是在无限流上的操作，所以上游数据每更新一次都会向下游发送一次 retract 消息以及最新的数据的消息进行计算。 那么就会存在这样一个问题，即 source qps 为 x 时，任务内的吞吐就为 x * n 倍，sink qps 也为 x，这会导致性能大幅下降的同时也会导致输出结果数据量非常大。 而我们只需要每分钟更新一次结果即可，所以可以使用 flink sql 自带的 minibatch 参数来控制输出结果的频次。 minibatch 具体参考可参考下面两篇文章： https://www.alibabacloud.com/help/zh/doc-detail/182012.htm?spm=a2c63.p38356.b99.288.698a785cSiDhEG https://www.jianshu.com/p/aa2e94628e24 1234567table.exec.mini-batch.enabled : true-- minibatch 是下面两个任意一个复合条件就会起触发计算-- 60s 一次table.exec.mini-batch.allow-latency : 60 s-- 数量达到 10000000000 触发一次-- 设置为 10000000000 是为了让上面的 allow-latency 触发，每 60s 输出一次来满足我们的需求table.exec.mini-batch.size : 10000000000 状态过期，如果不设置的话，词条状态会越来越大，对非高热词条进行清除。 http://apache-flink.147419.n8.nabble.com/Flink-sql-state-ttl-td10158.html 12-- 设置 1 天的 ttl，如果一天过后这个词条还没有更新，则直接删除table.exec.state.ttl : 86400 s 6.5.2.方案2 - 内外层自定义 udf 自定义内层排名 udf 自定义 udf 将排名数据进行合并 6.5.2.1.sql12345678910111213141516171819202122232425262728293031323334353637INSERT INTO target_db.target_tableSELECT -- 计算整体的前 50 名列表 top50_aggr_udaf(bucket_top100) AS top50_list, max(timestamp) AS timestampFROM ( SELECT max(timestamp) AS timestamp, -- udf 计算每一个分桶的前 100 名列表 top100_udaf(cast(热搜词条_name AS string), cnt) AS bucket_top100 FROM ( SELECT 热搜词条_name, sum(cnt) AS cnt, -- 计算消费 cnt 数 max(timestamp) AS timestamp FROM ( SELECT 热搜词条_name AS 热搜词条_name, count(1) AS cnt, max(timestamp) AS timestamp FROM source_db.source_table GROUP BY 热搜词条_name, -- 将数据打散，防止数据倾斜 hash_mod_bucket(user_id, 2048) ) GROUP BY 热搜词条_name ) GROUP BY -- 将数据打散，防止数据倾斜 hash_mod_bucket(热搜词条_name, 2048) )GROUP BY 0; 6.5.2.2.udf6.5.2.2.1.top100_udaf此 udf 与 方案1 的 topN udf（见 4.2.1.2.udf） 完全相同。 6.5.2.2.2.top50_aggr_udaf Accumulator：依然同 top100_udaf 的实现，使用 最小堆 来当做 Accumulator； accmulate：接受上游分桶中的数据，然后将每个桶中的词条获取到之后按照消费 cnt 与当前的 Accumulator 进行 merge 操作； getValue：将 Accumulator 结果获取到之后放在 map 中并将结果输出； retract：同上，也不需要实现，将各个分桶的结果做 merge 即可； 基类实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public abstract class TopNAggr_UDAF extends AggregateFunction&lt;String, TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; &#123; // topN private int topN; public TopNAggr_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public TopN&lt;Tuple2&lt;String, Long&gt;&gt; createAccumulator() &#123; return new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); &#125; @Override public String getValue(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc) &#123; // 将结果从 acc 中拿到之后，其结果是乱序的，所以要把结果列表拿到之后进行再进行一遍排序 LinkedHashMap&lt;String, Map&lt;String, Long&gt;&gt; map = Maps.newLinkedHashMap(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = acc .getQueue() .stream() .collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o2.f1.compareTo(o1.f1); &#125; &#125;); int i = 1; for (Tuple2&lt;String, Long&gt; t : topNList) &#123; map.put(i + &quot;&quot;, ImmutableMap.of(t.f0, t.f1)); i++; &#125; return ObjectMapperUtils.toJSON(map); &#125; public void accumulate(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, Map&lt;String, Long&gt; map) &#123; // 将 Accumulator 与分桶数据按照消费 cnt merge Map&lt;String, Long&gt; idCntMap = new HashMap&lt;&gt;(); acc.getQueue().forEach(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; Long cnt = idCntMap.get(t.f0); if (null == cnt) &#123; idCntMap.put(t.f0, t.f1); &#125; else &#123; idCntMap.put(t.f0, cnt &gt; t.f1 ? cnt : t.f1); &#125; &#125; &#125;); map.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Long cnt = idCntMap.get(s); if (null == cnt) &#123; idCntMap.put(s, l); &#125; else &#123; idCntMap.put(s, cnt &gt; l ? cnt : l); &#125; &#125; &#125;); acc.getQueue().clear(); idCntMap.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; acc.add(Tuple2.of(s, l)); &#125; &#125;); &#125; public void retract(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, Map&lt;String, Long&gt; map) &#123; // 无需实现 &#125; @Override public TypeInformation&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;String&gt; getResultType() &#123; return TypeInformation.of(String.class); &#125;&#125; top50 实现类如下： 12345public class Top50Aggr_UDAF extends TopNAggr_UDAF &#123; public Top50Aggr_UDAF() &#123; super(50); &#125;&#125; 或者也可以通过 open 方法动态获取到 topN 的配置参数，具体方式实现如下： 12345@Overridepublic void open(FunctionContext context) throws Exception &#123; super.open(context); this.topN = Integer.parseInt(context.getJobParameter(&quot;TopNAggr_UDAF.topN&quot;, &quot;50&quot;));&#125; 6.5.2.3.flink-conf.yaml 参数配置参数同 4.2.1.3 flink-conf.yaml 参数配置 6.5.3.方案3 - cumulate window如果你需要计算的是每天的排行榜，也可以使用 1.13 版本中最新的 cumulate window 进行计算。 6.5.3.1.sql12345678910111213141516171819202122232425262728INSERT INTO target_db.target_tableSELECT top50_aggr_udaf(bucket_top100, cast(10 AS bigint)) AS top50_list, cast(TUMBLE_START(timestamp, INTERVAL &#x27;60&#x27; SECOND) AS bigint) * 1000 AS timestampFROM ( SELECT top100_udaf(cast(热搜词条_name AS string), cnt) AS bucket_top100, TUMBLE_ROWTIME(timestamp, INTERVAL &#x27;60&#x27; SECOND) AS timestamp FROM ( SELECT 热搜词条_name, count(1) AS cnt, cumulate_rowtime(timestamp, INTERVAL &#x27;60&#x27; SECOND, INTERVAL &#x27;1&#x27; DAY) AS timestamp FROM source_db.source_table GROUP BY 热搜词条_name, CUMULATE(timestamp, INTERVAL &#x27;60&#x27; SECOND, INTERVAL &#x27;1&#x27; DAY) ) GROUP BY hash_mod_bucket(热搜词条_name), TUMBLE(window_start, INTERVAL &#x27;60&#x27; SECOND) )GROUP BY TUMBLE(window_start, INTERVAL &#x27;60&#x27; SECOND) 6.5.3.2.udf6.5.3.2.1.top100_udaf Accumulator：由需求可以知道，当前 udaf 是为了计算前 100 名的消费词条，所以 Accumulator 应该存储截止当前时间按照消费 cnt 数排名的前 100 名的词条。我们由此就可以想到使用 最小堆 来当做 Accumulator，Accumulator 中只存储消费 cnt 前 100 的数据。 getValue：将 Accumulator 中的数据转换为 map 格式输出； acumulate：将词条以及消费 cnt 存入 topN Accumulator 中； merge：将所有 topN Accumulator 进行 merge 操作，取所有 topN 最大的； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public abstract class TopN_UDAF extends AggregateFunction&lt;Map&lt;String, Long&gt;, TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; &#123; private int topN; public TopN_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public TopN&lt;Tuple2&lt;String, Long&gt;&gt; createAccumulator() &#123; return new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); &#125; @Override public Map&lt;String, Long&gt; getValue(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc) &#123; PriorityQueue&lt;Tuple2&lt;String, Long&gt;&gt; p = acc.getQueue(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = p.stream().collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); Map&lt;String, Long&gt; map = Maps.newLinkedHashMap(); topNList.forEach(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; map.put(t.f0, t.f1); &#125; &#125;); return map; &#125; public void accumulate(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, String id, long cnt) &#123; Tuple2&lt;String, Long&gt; t = Tuple2.of(id, cnt); acc.add(t); &#125; public void merge(TopN&lt;Tuple2&lt;String, Long&gt;&gt; acc, Iterable&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; its) &#123; its.forEach(new Consumer&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; @Override public void accept(TopN&lt;Tuple2&lt;String, Long&gt;&gt; topN) &#123; topN.getQueue().iterator().forEachRemaining(new Consumer&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Tuple2&lt;String, Long&gt; t) &#123; acc.add(t); &#125; &#125;); &#125; &#125;); &#125; @Override public TypeInformation&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;TopN&lt;Tuple2&lt;String, Long&gt;&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;Map&lt;String, Long&gt;&gt; getResultType() &#123; return TypeInformation.of(new TypeHint&lt;Map&lt;String, Long&gt;&gt;() &#123; &#125;); &#125;&#125; 6.5.3.2.2.top50Aggr_udaf getValue：将 Accumulator 结果获取到之后，拿到 top50 之后放在 map 中并将结果输出； acumulate：将内层桶的数据合并到当前 Acumulator 中，即将内层分桶的所有词条的数据以及消费 cnt 拿到之后进行累加； merge：将 Accumulator 合并，相同词条的消费 cnt 相加； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public abstract class TopNAggr_UDAF extends AggregateFunction&lt;String, Map&lt;String, Long&gt;&gt; &#123; private int topN; public TopNAggr_UDAF(int topN) &#123; this.topN = topN; &#125; @Override public Map&lt;String, Long&gt; createAccumulator() &#123; return Maps.newHashMap(); &#125; @Override public String getValue(Map&lt;String, Long&gt; acc) &#123; TopN&lt;Tuple2&lt;String, Long&gt;&gt; topN = new TopN&lt;&gt;(this.topN, new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o1.f1.compareTo(o2.f1); &#125; &#125;); acc.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Tuple2&lt;String, Long&gt; t = Tuple2.of(s, l); topN.add(t); &#125; &#125;); LinkedHashMap&lt;String, Map&lt;String, Long&gt;&gt; map = Maps.newLinkedHashMap(); List&lt;Tuple2&lt;String, Long&gt;&gt; topNList = topN .getQueue() .stream() .collect(Collectors.toList()); Collections.sort(topNList , new Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123; @Override public int compare(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2) &#123; if (o1.equals(o2)) &#123; return 0; &#125; return o2.f1.compareTo(o1.f1); &#125; &#125;); int i = 1; for (Tuple2&lt;String, Long&gt; t : topNList) &#123; map.put(i + &quot;&quot;, ImmutableMap.of(t.f0, t.f1)); i++; &#125; return ObjectMapperUtils.toJSON(map); &#125; public void accumulate(Map&lt;String, Long&gt; acc, Map&lt;String, Long&gt; map) &#123; map.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Long history = acc.get(s); if (null != history) &#123; acc.put(s, l + history); &#125; else &#123; acc.put(s, l); &#125; &#125; &#125;); &#125; public void merge(Map&lt;String, Long&gt; acc, Iterable&lt;Map&lt;String, Long&gt;&gt; its) &#123; its.forEach(new Consumer&lt;Map&lt;String, Long&gt;&gt;() &#123; @Override public void accept(Map&lt;String, Long&gt; map) &#123; map.forEach(new BiConsumer&lt;String, Long&gt;() &#123; @Override public void accept(String s, Long l) &#123; Long history = acc.get(s); if (null != history) &#123; acc.put(s, l + history); &#125; else &#123; acc.put(s, l); &#125; &#125; &#125;); &#125; &#125;); &#125; @Override public TypeInformation&lt;Map&lt;String, Long&gt;&gt; getAccumulatorType() &#123; return TypeInformation.of(new TypeHint&lt;Map&lt;String, Long&gt;&gt;() &#123; &#125;); &#125; @Override public TypeInformation&lt;String&gt; getResultType() &#123; return TypeInformation.of(String.class); &#125;&#125; 6.5.3.3.flink-conf.yaml 参数配置时间戳的时区设置，注意需要我们将时区设置为本地的时区。 12-- 北京时区table.local-time-zone : GMT+08:00 6.6.高可用、高性能6.6.1.整体高可用保障异地双链路热备如下图： 可能会发现图中有异地机房，但是我们目前只画出了 A 地区机房的数据链路，B 地区机房还没有画全，接着我们一步一步将这个图进行补全。 Notes： 异地双机房只是双链路的热备的一种案例。如果有同城双机房、双集群也可进行同样的服务部署。 为什么说异地机房的保障能力 &gt; 同城异地机房 &gt; 同城同机房双集群容灾能力？ 同城同机房：只要这个机房挂了，即使你有两套链路也没救。同城异地机房：很小几率情况会同城异地两个机房都挂了，除非整个城市被炸了。异地机房：几乎不可能同时异地两个机房都被炸了。。。 6.6.1.1.数据源日志高可用 数据源日志 server 服务高可用：异地机房，当一个机房挂了之后，在客户端可以自动将日志发送到另一个机房 数据源日志 kafka 服务高可用：kafka 使用异地机房，每个机房的 kafka 承担 50% 的流量，一旦一个机房的 kafka 集群宕机，则 producer 端可以自动将 100% 的流量切换到另一个机房的 kafka。 正常情况下如图所示： 当发生 A 地机房 webserver 宕机时，客户端自动切换上报日志至 B 地机房 webserver。如下图所示： kafka 也相同。如下图所示： 6.6.1.2.flink 任务高可用flink 任务以 A 地机房做主链路，B 地机房启动相同的任务做热备双跑链路。 当 A 地机房 flink 任务宕机且无法恢复时，则 B 地机房的任务做热备替换。 正常情况下如图所示： 当 A 地机房 flink 任务宕机且无法恢复时，热备链路 flink 任务就可以顶上。如下图所示： 6.6.1.3.数据服务高可用正常情况如下： 当 A 地 OLAP 或者 KV 存储挂了之后，webserver 可以自动切换至 B 地 OLAP 或者 KV 存储。如下图所示： 当 A 地 webserver 挂了之后，客户端可以自动拉取 B 地 webserver 数据，如下图所示： 6.6.2.大流量、高性能6.6.2.1.数据源 任务数据源反序列化性能提升：静态反序列化性能 &gt; 动态反序列化性能。举例 ProtoBuf。可以在 source 端先进行代码生成，然后用生成好的代码去反序列化源消息的性能会远好于使用 ProtoBuf Dynamic Message。flink 官方实现 6.6.3.缩减状态大小 将状态中的 string 长度做映射之后变小 增量 checkpoint，减小任务做 checkpoint 的压力 7.数据服务篇-数据服务选型7.1.kv 存储根据我们上述设计的数据汇 schema 来看，最适合存储引擎就是 kv 引擎，因为前端只需要展示最新的排行榜数据即可。所以我们可以使用 redis 等 kv 存储引擎来存储最新的数据。 7.2.OLAP如果用户有需求需要记录上述数据的历史记录，我们也可以使用时序数据库或者 OLAP 引擎直接进行存储。 8.数据保障篇-数据时效监控以及保障方案8.1.数据时效保障见下文。 8.2.数据质量保障数据质量保障篇楼主正在 gang… 9.效果篇-上述方案最终的效果9.1.输出结果示例123456789101112&#123; &quot;1&quot;: &#123; &quot;黄子韬 杨紫是我哥们&quot;: 1672825 &#125;, &quot;2&quot;: &#123; &quot;延乔墓前的来信破防了&quot;: 1087416 &#125;, &quot;3&quot;: &#123; &quot;孟子义 张翰同学站起来&quot;: 747703 &#125; // ...&#125; 9.2.应用产品示例 10.现状以及展望篇 虽然上述 udf 是通用的 udf，但是是否能够脱离自定义 udf，直接计算出 top 50 的值？ 我目前的一个想法就是将结果 schema 拍平。举例： 字段名 字段类型 备注 timestamp bigint 当前分钟事件时间戳 热搜词条_1 string 第一名的热搜词条名称 热搜词条_2 string 第二名的热搜词条名称 热搜词条_3 string 第三名的热搜词条名称 热搜词条_4 string 第四名的热搜词条名称 热搜词条_5 string 第五名的热搜词条名称 … … … 热搜词条_n string 第 n 名的词条名称 每一次输出都将目前每一个排名的数据产出。但是目前在 flink sql 的实现思路上不太明显。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"管理 | 实时数仓数据质量保障","date":"2021-10-12T06:21:53.000Z","path":"2021/10/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/03_数据内容管理/01_dqc/01_数据质量管理/01_quality_dqc/","text":"前沿 | 流批一体的一些理解 每家数字化企业在目前遇到流批一体概念的时候，都会对这个概念抱有一些疑问，到底什么是流批一体？这个概念的来源？这个概念能为用户、开发人员以及企业带来什么样的好处？跟随着博主的理解和脑洞出发吧。 通过本文你可以 get 到： 什么是数据质量保障、为什么要做数据质量保障 怎么去做数据时效保障 1.什么是数据质量保障、为什么要做数据质量保障数据质量是一个数据开发人员的生命线，可以想象一下 在业务侧，如果产出的数据是不准确的，甚至是错误的，那业务侧参考这个数据而做出的决策就绝对是错误的。这对依赖数据的决策方式毁灭性打击。 在数据加工链路侧，如果一个核心节点的数据产出是错误的，那么依赖这个数据的下游数据基本都是无效数据了。 所以我称数据质量是数据的生命线。而数据质量保障就是来维护数据质量这条生命线的。 数据质量保障就是对上述数据质量有一个监控以及保障方案的体系的建设。 而对于现在大多数 lambda 架构的实时数仓来说，实时数据质量保障可以分为两块： 实时数据自身同环比：其可以实时反映出数据波动的情况，快速发现数据质量问题，可以快速反映出目前实时数据波动的合理性； 实时离线数据校验：其可以反映出实时数据的准确性，由于实时数据处理过程中的乱序丢数，没有端对端一致性保障的情况下，实时离线数据校验就可以保障实时数据的一个准确性。 2.怎么去做数据时效保障","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"管理 | 实时数仓数据时效保障","date":"2021-10-12T06:21:53.000Z","path":"2021/10/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/03_数据内容管理/01_dqc/02_数据时效管理/01_timeliness_dqc/","text":"我要更快、更快更快！！！ 通过本文你可以 get 到： 起因篇-为什么要做数据时效保障 定义篇-数据时效保障包含哪些内容 目标篇-时效性监控以及保障的目标 机制篇-怎么去做数据时效监控以及保障 效果篇-上述机制帮助用户暴露出过什么问题 现状以及展望篇 1.序篇所有的数据建设都是为了用户更快、更方便、更放心的使用数据。 在用户使用实时数据的过程中，最影响用户体感的指标有两个： 数据质量：实时数据产出的准确性。举个例子：实时数据在某些场景下不能保障端到端 exactly-once，因此实时与离线相同口径的数据会有 diff。而 1% 和 0.01% 的 diff 给用户的体验是完全不同的。 数据时效：实时数据产出的及时性。举个例子：延迟 1min 和 延迟 1ms 的用户体验也是完全不同的。 而本文主要对数据时效保障进行解读。 懒癌患者福利，先说本文结论，通过以下两个指标就已经能监控和判定 90% 数据延迟、乱序问题了。 数据延迟监控：flink 消费上游的 lag（比如看消费 kafka lag 情况） 数据乱序监控：Task/Operator numLateRecordsDropped 可以得到由于乱序导致窗口的丢数情况。 2.起因篇-为什么要做数据时效保障要做一个东西时，我们首要分析的就是用户的痛点是什么，用户想要什么。从以下两个方面的分析入手。 业务侧：首先从正向结果来看，业务侧能拿到第一手准确的实时数据，就能根据准确，快速的数据做出业务策略调整，扩大收益。但是正向结果是我们预期的目标，开发所要做的就是解决达成预期目标过程中的各种不稳定因素，这些不稳定因素就是负向结果。从负向结果看，一旦出现数据产出延迟，数据不准，就有可能让业务错失一个热点，产生巨大损失，两者之间的关系如下图；因此从保障层面出发，这就要求更低的数据延迟、更小的数据乱序（某些对于数据乱序敏感的任务，产出的数据质量强依赖数据乱序情况） 数据加工链路侧：从调研数据源阶段角度出发，DE 需要确定某些原始数据的延迟和乱序情况，确定数据源可用性，从而进行定制化的处理和优化；从保障数据汇结果时效性出发，某些实时数据加工链路是很长的，ods -&gt; dwd -&gt; dws -&gt; ads，当数据产出延迟时，DE 需要快速定位到问题任务进行处理，如下图。数据加工时延越小，数据的乱序情况越小，说明整条处理链路的稳定性也越好，也就有能力提供更高的 SLA 保障；从以上角度出发，也需要我们对整个生产链路的数据延迟、乱序情况有一个全局视角的掌握。 结论：数据时效保障就是对数据产出延迟、数据乱序的监控报警能力的构建、保障方案规范化的建设。 3.定义篇-数据时效保障包含哪些内容如上节场景分析，实时数据时效保障可分为两部分： 数据时延监控、报警、保障：衡量实时数据产出的延迟情况，设定报警阈值，超过阈值触发报警。并且需要对数据产出延迟有一个全链路的视角，保障数据产出延迟在预期范围内； 数据乱序监控、报警、保障：乱序是实时任务处理中要关注的一个重要指标，如果数据源乱序非常严重的话，会影响窗口类任务产出的实时数据质量，所以我们也需要对齐进行监控以及保障。 Notes:乱序的本质其实就是数据的延迟。乱序是一种特殊的延迟，数据延迟导致的一种结果。 4.目标篇-时效性监控以及保障的目标 探查：了解数据源的延迟、乱序情况。针对数据源的延迟、乱序情况可以针对性优化。也对此能提出合理的 SLA 保障； 监控：针对具体延迟、乱序严重程度设定报警阈值，让开发可以快速感知问题； 定位：根据延迟、乱序报警快速定位数据延迟、乱序导致的质量问题； 恢复：问题解决完成之后，可以根据监控查看到实际的效果； 5.机制篇-怎么去做数据时效监控以及保障接下来我们对症（延迟、乱序情况）下药（监控、报警、保障措施），先分析在数据生产、传输、加工的过程中哪些环节会导致数据的延迟以及乱序。 通过分析上述数据生产、传输、加工链路之后，我们可以发现能从数据源、数据处理任务两个不同的维度去分析会导致延迟、乱序的原因。 数据源延迟乱序：属于数据源本身的属性，和下游消费的任务无关。 数据加工延迟乱序：这是和具体的任务绑定。 其对应关系如下。 维度 数据源视角（与具体任务无关） 数据处理任务视角（与具体任务绑定） 延迟 源日志上报的延迟 数据加工过程导致的延迟 乱序 源日志上报的乱序 数据加工过程中 shuffle 导致的乱序 5.1.数据时延监控5.1.1.整体时延整体时延可以从以下两个角度出发进行计算。 用户视角：只关心最终产出结果时延 开发视角：需要关心整个链路处理时延 5.1.2.结果时延监控 5.1.2.1.监控指标以及报警机制从用户体验角度直观的反映出数据的整体时延情况。 监控方式：有数据时效监控中心提供延迟监控 sdk。在看板的 web server 侧将数据时延上报到延迟监控 sdk 中。 监控指标：计算 web-server-system-current-timestamp - message-event-timestamp 计算 P99 等指标。 监控方式优点：能从用户体感角度出发，准确的刻画时延情况。 监控方式缺点：对 web server 有埋点侵入性。 报警机制：定时（比如 1min/次） check 监控指标的 P99 指标。 报警阈值：判断监控指标的 P99 指标是否超过某个阈值（比如 5 min）。 报警接收人：报警反馈给任务链路负责人。 5.1.3.链路时延监控 5.1.3.1.数据源时延 这个时延和处理任务无关，单纯从指数据本身的属性，数据本身上报就存在的时延。 举例：从用户发生消费事件一直到日志进入数据源存储引擎中（比如 kafka），这期间存在的时延。 5.1.3.1.1.监控指标以及报警机制 监控方式：单独有一个任务消费并处理数据源。需要保障这个任务任何时刻都不能有 lag，才能刻画出一个准确的数据源时延情况。 监控指标：使用 system-current-timestamp - message-event-timestamp P99 等指标。 监控方式优点：在数据源角度能准确的刻画出数据源事件时间时延情况。 监控方式缺点：为了监控数据源乱序情况，需要单独启动一个任务耗费资源。不建议这种方式进行，如果要做，可以进行采样。而且会侵入用户代码，需要用户指定时间戳。 报警机制：定时（比如 1min/次） check 监控指标的 P99 指标。 报警阈值：判断监控指标的 P99 指标是否超过某个阈值（比如 5 min）。 报警接收人：报警反馈给任务链路负责人。 上面这种方式是站在数据源视角去精准的衡量出数据延迟情况的，但是很多时候我们只需要在下游任务视角去做这件事会更方便。比如： 监控方式：在下游任务处处理数据源时记录数据延迟情况。 监控指标：使用任务本地 system-current-timestamp - message-event-timestamp P99 等指标。 监控方式优点：节约资源。 监控方式缺点：一旦下游任务消费有延迟，我们就不能准确的衡量出数据源的延迟情况了。而且会侵入用户代码，需要用户指定时间戳。 报警机制：定时（比如 1min/次） check 监控指标的 P99 指标。 报警阈值：判断监控指标的 P99 指标是否超过某个阈值（比如 180s）。 报警接收人：报警反馈给任务链路负责人。 Notes：这里衍生出一个问题，客户端日志数据一般会有以下两种时间戳： 客户端时间戳：用户在客户端操作时的时间戳 服务端时间戳：客户端日志上报到服务端时，日志 server 打上的本地时间戳 因为客户端的软件版本、网络环境、机型、地区的不同，会导致上报的日志客户端时间戳（用户操作时间戳）的准确性参差不齐（你可能会发现有历史、未来的时间戳）。因此事件时间都采用服务端时间戳（日志上报到服务端时，服务端的本地时间戳）来避免这种问题。 当我们采用服务端时间戳时，就基本会发现数据源的时延几乎为 0，因为数据处理链路和日志 server 都是 server 端，因此其之间的数据时延是非常小的，几乎可以忽略不计。 5.1.3.2.数据加工时延 用于衡量实时任务处理链路的时延。定位链路瓶颈问题。 5.1.3.2.1.监控指标以及报警机制第一个就是 flink 消费数据源的延迟。比如 flink 任务性能不足，产生反压就会有大量 lag。 监控方式：在下游任务处处理数据源时记录数据延迟情况。 监控指标：使用任务本地 system-current-timestamp - kafka-timestamp P99 等指标。 监控方式优点：不侵入用户代码。 监控方式缺点：可以衡量出任务消费时延情况。 报警机制：定时（比如 1min/次） check 监控指标的 P99 指标。 报警阈值：判断监控指标的 P99 指标是否超过某个阈值（常用 180s）。 报警接收人：报警反馈给任务链路负责人。 第二部分就是 flink 整个处理过程中的延迟情况。 监控方式：flink 本身自带有 latency marker 机制（详见 flink latency marker）。 监控指标：flink latency marker 官方文档。 监控方式优点：在下游消费任务的角度准确的刻画出整个 flink 任务加工时延。 监控方式缺点：这个机制会有性能损耗，官方建议只在测试阶段进行使用。这其实已经足够，因为我们在测试阶段就可以基本测试出，flink 任务处理计算的耗时情况。 5.2.数据乱序监控数据乱序监控主要是用来监控数据源、处理任务过程中操作的乱序对产出数据的影响。 5.2.1.数据源乱序 指数据本身就存在的乱序，比如客户端网络上报存在的乱序，有的用户在偏远网络较差的地区，所以上报可能就会比很多用户延迟很多，这就造成了数据的乱序。 5.2.1.1.监控指标以及报警机制 监控方式：单独有一个任务消费并处理数据源。需要保障这个任务任何时刻都不能有 lag，才能刻画出一个准确的数据源时延情况。 监控指标： 具体衡量乱序的指标类似于 watermark 分配方式。即为每一个 source consumer 维护一个 max(timestamp)，记为 max_ts，后续来的数据的时间戳记为 cur_tx，如果 cur_tx &gt; max_ts，则说明没有乱序，设置 max_tx = cur_ts，如果出现 cur_ts &lt; max_ts，则说明这条数据发生了乱序，计算出 abs(cur_ts - max_ts) 为具体乱序时长，最终计算乱序时长的 P99 等值。 监控方式优点：在数据源角度能准确的刻画出数据源事件时间乱序情况。 监控方式缺点：为了监控数据源乱序情况，需要单独启动一个任务耗费资源。不建议这种方式进行，如果要做，可以进行采样。 报警机制：定时（比如 1min/次） check 监控指标的 P99 指标。 报警阈值：判断监控指标的 P99 指标是否超过某个阈值（常用 180s）。 报警接收人：报警反馈给任务负责人。 上面这种方式是站在数据源视角去精准的衡量出数据乱序情况的，但是很多时候我们只需要在下游任务视角去做这件事会更方便。比如： 监控方式：在下游任务处处理数据源时记录数据乱序情况。 监控指标：衡量指标同上。 Notes：虽然数据源可能有乱序，但是这个乱序经过 flink 的一些策略处理后，乱序对计算数据的影响就会被消除。比如用户设置 watermark 时调大 max-out-of-orderness 以及设置 allow-lateness 的处理之后就会解决。 5.2.2.数据加工乱序 单个任务消费上游数据后，内部做一些 rebalance shuffle 操作导致或者加剧数据乱序的情况。从而会导致一些开窗类的任务出现丢数的情况，导致最后数据计算出现误差。 举例： 123456789101112131415DataStream&lt;Model&gt; eventTimeResult = SourceFactory .getSourceDataStream(xxx) .uid(&quot;source&quot;) .rebalance() // 这里 rebalance 之后会加剧数据乱序，从而可能会导致后续事件时间窗口丢数 .flatMap(xxx) .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;Model&gt;(Time.minutes(1L)) &#123; @Override public long extractTimestamp(Model model) &#123; return model.getServerTimestamp(); &#125; &#125;) .keyBy(KeySelectorFactory.getRemainderKeySelector(xxx)) .timeWindow(Time.seconds(xxx)) .process(xxx) .uid(&quot;process-event-time&quot;); 5.2.2.1.监控指标以及报警机制 监控方式：我们关心的是乱序最终导致的丢数情况，所以监控丢数条目数即可。 监控指标： Task/Operator numLateRecordsDropped 可以得到由于乱序导致窗口的丢数情况。 监控方式优点：flink 自带此指标。 报警机制：定时（比如 1min/次） check 监控指标的条目数。 报警阈值：判断监控指标的条目数是否超过某个阈值（比如 5w 条）。 报警接收人：报警反馈给任务负责人。 6.效果篇-上述机制帮助用户暴露出过什么问题6.1.数据源探查阶段在数据源探查阶段，通过快速启动数据源消费任务去探查数据源的延迟、乱序程度，确定数据源的可用性。比如发现数据源延迟常年在 5min 以上，那么我们向用户所能保障的数据时延也不会小于 5min。 6.2.暴露延迟、乱序问题通过我们的实践测试之后，我们发现报警和问题原因是符合 2-8 定律的，甚至比例达到了 2 - 9。即 90% 的问题都可以由 20% 的报警发现。 6.2.1.90% 的时延问题是由于 flink 任务性能不足导致 报警项：flink 消费 kafka lag 延迟超过 180s 其他监控项辅助定位：flink 任务 cpu 使用率超过 100%；flink 任务 ygc 每分钟超过 20s 6.2.2.10% 的时延问题是由于数据源延迟导致 报警项：flink 消费 kafka lag 延迟超过 180s；数据源时延超过 180s 其他监控项辅助定位：flink 任务 cpu 使用率正常，每分钟 ygc 时长正常 6.2.3.90% 的乱序问题是由于数据源乱序导致 报警项：flink 任务窗口算子丢数超过 xx 条；数据源乱序 P99 超过 180s（指 99% 的数据乱序情况不超过 180s） 6.2.4.10% 的乱序问题是由于 flink 任务加工乱序导致 报警项：flink 任务窗口算子丢数超过 xx 条 他监控项辅助定位：数据源乱序 P99 处于合理范围；并且代码中有 rebalance 操作之后分配 watermark 6.3.确定延迟、乱序问题恢复情况当我们修复数据延迟、乱序问题之后，我们也需要观察任务的回复情况。上述监控也可以帮助观察问题的恢复情况。比如：延迟、乱序时长变小就说明用户的修复是有效的。 7.现状以及展望篇7.1.现状其实目前很多公司有 flink 消费 kafka lag 时延，Task/Operator numLateRecordsDropped 就已经足够用了。全方位建设上述整个时延监控的成本还是很高的。 7.2.展望7.2.1.实时数据、任务血缘 + 时效性全景图 需求：数仓的上下游链路是很长的，如果想更快快速定位整个数据链路中的时效性问题，就需要一个可视化整体链路时延全局图。 基础能力：需要实时数据、任务血缘（目前想要做到这一点，都已经比较难了，很多大厂的机制都不完善，甚至说没有） 举例：从最终产出的一个 ads 层指标出发，逆推血缘，并展示出时效情况。 7.2.2.实时时效性基线7.2.2.1.基线并且将时延超过阈值的链路使用醒目的颜色标注 需求：不同的指标有不同的产出时延标准，有了 6.2.1 的基础能力之后，我们就可以根据具体时延要求设置时效性基线。比如设置最终指标产出时延不能超过 180s。那么基线就是 180s。只要整个链路的产出时延超过 180s 就报警。也可以对某一层的加工链路设置基线。 举例：从最终产出的一个 ads 层指标出发，设置基线 180s，那么下图的任务就可以根据基线设定的任务，逆推计算出链路中时延过长的任务，直接报警。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"火山引擎开发者社区 Meetup 数据技术专场小记","date":"2021-07-24T06:21:53.000Z","path":"2021/07/24/wechat-blog/01_大数据/02_meetup/01_火山引擎/01_20210724火山引擎大数据/","text":"现场回顾。PPT 公众号回复 20210724 获取。感谢您的关注 + 点赞 + 再看，对博主的肯定，会督促博主持续的输出更多的优质实战内容！！！ 火山 abtest 引擎 问题 实时 abtest 的探索？以及一些应用场景？ 有5分钟，1小时的指标，结合监控报警能力，可以在在某些效果很差的实验下进行及时止损。其他情况下实时指标在 abtest 中的效果并不明显。 abtest 自动化归因能力？ 目前在探索中，结合老虎机算法。但是归因能力还是需要更多业务的输入，以及用户消费数据的特点。 展望 智能化：智能化归因，和算法进行集成 场景化：深入用户场景 被集成：深入集成到各个业务系统中 clickhouse 着重介绍了字节基于 RoaringBitMap 对于人群包圈定或者留存分析上面的优化应用。 人群包圈定流程 将画像维度下的 uid 集成到 bitmap 中 使用 bitmap 的各种 and，or 操作进行人群包圈定 流批数据质量管控 字节跳动数据质量监控平台的能力。包括实时、离线数据的 dqc 能力。 实时数据时效性监控从监控指标上面来分为延迟、乱序；从监控模块：任务，数据源，字节实现了哪些？以及是否有全链路的监控？ 字节数据质量平台更多的是从数据源、数据表角度去监控数据表的数据时效、数据质量。 实时数据 dqc：目前主要是针对数据源角度，有延迟监控，没有乱序监控。但也只是针对单个的数据源有延迟、质量（和离线一直，包括实时数据空值等校验）监控，针对全链路，虽然目前建立了血缘数据，但是没有全链路监控。针对任务角度的监控，全部都是集成在实时数据开发的 IDE 中，不属于 dqc 平台的范畴。 博主理解实时 dqc 更靠近业务侧，而非实时数仓侧。 当用户配置好了实时数据质量监控规则之后（延迟配置方式其实就是在 dqc 平台中配置对应 kafka 的时间戳字段进行延迟监控），其会自动生产 flink sql 任务。当然这个 flink sql 任务也会遇到延迟等问题，所以字节团队也会对这种关键任务配置任务层面的报警。 离线数据 dqc：离线数据是会存在全链路的 dqc 数据质量以及产出时效监控。 实时数据 dqc 目前有调研过算法吗（毕竟算法会比强阈值监控报警准确度高）？ 目前也有自研时序算法来处理流量高峰期的误报过多的情况，但是目前跑下来发现效果没那么好。 离线数据时效性监控保障是怎样做的？ 在字节总共分为两部分，第一部分是基线，第二部分是产出死保协议。这两种工具产品形态是两天，底层能力都是一套。 基线：会逆推进行预警，这个预警目前是会有两套算法进按照历史执行情况进行预估，两套算法相辅相成可以更准确的预估产出时效。 产出死保协议：此工具的能力是和基线一致的，类似于对于重要任务让各个任务节点的 DE 签署一个产出时间协议，保障对应的数据必须在某个时间点进行产出。如果没有按照这个时间点产出，那么你懂的。 埋点流量治理大规模实践 主要介绍了埋点流量治理的整套方法论，包括治理规范、工具链。 拓扑重构：重复消费 kafka 的任务合并到一个任务中，减少 kafka consumer。 将拆流任务和埋点平台进行绑定：拆流任务其实就是一个 mapper 任务，只有 map，这个 map 任务负责清洗、拆流，任务可以做到热加载，rpc 热加载，拆流策略热加载，udf 热加载，可以做到不重启任务就可以更改。并且用户可以自定义产出数据类型（json、protobuf 等）、schema，任务会将热加载 schema 配置，动态生成 sink schema 代码，热 load 后写出。 针对客户端埋点延迟上报的情况，可以自定义配置上报时间以及策略。但是目前针对埋点丢失、重复、上报延迟也没有更好的方式去解决，只能是在客户端添加一些重试策略。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"","date":"2021-07-10T15:08:29.944Z","path":"2021/07/10/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/03_state/05_place-holder/","text":"","tags":[]},{"title":"","date":"2021-07-10T15:08:29.943Z","path":"2021/07/10/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/01_数据内容应用/place-holder/","text":"","tags":[]},{"title":"","date":"2021-07-10T15:08:29.943Z","path":"2021/07/10/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/04_data-sediment/place-holder/","text":"","tags":[]},{"title":"","date":"2021-07-10T15:08:29.943Z","path":"2021/07/10/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/02_one-service/01_OLAP/place-holder/","text":"","tags":[]},{"title":"","date":"2021-07-10T15:08:29.943Z","path":"2021/07/10/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/02_存储引擎/place-holder/","text":"","tags":[]},{"title":"","date":"2021-07-10T15:08:29.943Z","path":"2021/07/10/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/02_flink-datastream/place-holder/","text":"","tags":[]},{"title":"","date":"2021-06-29T14:09:08.920Z","path":"2021/06/29/wechat-blog/a/","text":"Document .not-active { display: inline-block; font-size: 12px; margin: 5px 8px; } span { margin: 0 2px; } ： 不限 不限 清空已选： 备选项1 备选项2 备选项3 备选项1 备选项2 备选项3 var categories = [{ name: '品牌', count: 0, children: [{ name: '联想', }, { name: '小米', }, { name: '苹果', }, { name: '东芝', }] }, { name: 'CPU', count: 0, children: [{ name: 'intel i7 8700K', }, { name: 'intel i7 7700K', }, { name: 'intel i9 9270K', }, { name: 'intel i7 8700', }, { name: 'AMD 1600X', }] }, { name: '内存', count: 0, children: [{ name: '七彩虹8G', }, { name: '七彩虹16G', }, { name: '金士顿8G', }, { name: '金士顿16G', }] }, { name: '显卡', count: 0, children: [{ name: 'NVIDIA 1060 8G', }, { name: 'NVIDIA 1080Ti 16G', }, { name: 'NVIDIA 1080 8G', }, { name: 'NVIDIA 1060Ti 16G', }] }] // 简单封装一个公用组件 Vue.component('my-tag', { template: \"\", methods: { clickChild() { this.$emit(\"click-child\") } } }); var app = new Vue({ el: '#app', data() { return { // categories, // 分类标签，可从外部加载配置 conditions: [], // 已选条件 radio: 3 } }, watch: { // 监听条件变化，按照请求接口拼装请求参数 conditions(val) { let selectedCondition = {}; for (let categorie of this.categories) { let selected_list = []; for (let child of categorie.children) { if (child.active) { selected_list.push(child.name); } } selectedCondition[categorie.name] = selected_list.join(\"|\") } console.log(selectedCondition); } }, methods: { // 处理标签点击事件，未选中则选中，已选中则取消选中 clickChild(category, categoryIndex, child, childIndex) { let uid = `${categoryIndex}-${childIndex}` child.uid = uid; console.log(uid) // 取消选择 if (child.active === true) { category.count--; child.active = false; this.conditions.forEach((conditionChild, index) => { if (conditionChild.uid === child.uid) { this.conditions.splice(index, 1); } }); // 选择 } else { category.count++; child.active = true; this.conditions.push(child); } }, // 清除已选整个类别标签 clearCategory(category, categoryIndex) { category.count = 0; // 可选列表均为未选中状态 category.children.forEach(child => { child.active = false; }) // 清空该类已选元素 for (let index = this.conditions.length - 1; index >= 0; index--) { const conditionChild = this.conditions[index]; if (conditionChild.uid.startsWith(categoryIndex)) { this.conditions.splice(index, 1); } } }, // 移除一个条件 removeCondition(condition, index) { let categoryIndex = condition.uid.split(\"-\")[0]; this.categories[categoryIndex].count--; this.conditions.splice(index, 1) condition.active = false; }, // 清空所有条件 clearCondition() { for (let i = this.conditions.length - 1; i >= 0; i--) { this.removeCondition(this.conditions[i], i); } } } });","tags":[]},{"title":"深入浅出 | flink minicluster 启动流程","date":"2021-04-12T06:21:53.000Z","path":"2021/04/12/wechat-blog/apache-flink:minicluster-start/","text":"目录 目录 flink 怎么判断是本地环境还是集群环境的？ flink 的接口都是声明式的，那么到底把我们的接口解析或者封装成什么样进行执行了？ flink 怎么判断是本地环境还是集群环境的？环境判断 通过 debug StreamExecutionEnvironment.getExecutionEnvironment(); 可以定位到下面的代码 我们可以看注释，解释一下，基本流程如下： 先尝试获取本地环境，即从 threadLocalContextEnvironmentFactory 获取环境配置 获取不到本地环境配置，就获取外部环境配置，即从 contextEnvironmentFactory 获取环境配置 12345678910111213public static StreamExecutionEnvironment getExecutionEnvironment(Configuration configuration) &#123; return Utils.resolveFactory(threadLocalContextEnvironmentFactory, contextEnvironmentFactory) .map(factory -&gt; factory.createExecutionEnvironment(configuration)) .orElseGet(() -&gt; StreamExecutionEnvironment.createLocalEnvironment(configuration));&#125;public static &lt;T&gt; Optional&lt;T&gt; resolveFactory( ThreadLocal&lt;T&gt; threadLocalFactory, @Nullable T staticFactory) &#123; final T localFactory = threadLocalFactory.get(); final T factory = localFactory == null ? staticFactory : localFactory; return Optional.ofNullable(factory);&#125; 那么问题来了，当集群环境时，是如何将 StreamExecutionEnvironmentFactory 到 ThreadLocal 中？ 集群环境通过 bin/flink run ….命令提交jar包到集群运行命令时，该脚本会调用org.apache.flink.client.cli.CliFrontend 来运行用户程序，如下： 12# Add HADOOP_CLASSPATH to allow the usage of Hadoop file systemsexec $JAVA_RUN $JVM_ARGS $FLINK_ENV_JAVA_OPTS &quot;$&#123;log_setting[@]&#125;&quot; -classpath &quot;`manglePathList &quot;$CC_CLASSPATH:$INTERNAL_HADOOP_CLASSPATHS&quot;`&quot; org.apache.flink.client.cli.CliFrontend &quot;$@&quot; 在CliFrontend中依次执行以下方法 main() -&gt;parseParameters() -&gt; run() -&gt;executeProgram() 12345protected void executeProgram(final Configuration configuration, final PackagedProgram program) throws ProgramInvocationException &#123; ClientUtils.executeProgram( new DefaultExecutorServiceLoader(), configuration, program, false, false);&#125; 在org.apache.flink.client.ClientUtils的executeProgram()中调用StreamContextEnvironment.setAsContext(…)，StreamContextEnvironment继承自StreamExecutionEnvironment。setAsContext()代码如下 123456StreamContextEnvironment.setAsContext( executorServiceLoader, configuration, userCodeClassLoader, enforceSingleJobExecution, suppressSysout); 创建生成运行环境的工厂类实例，在initializeContextEnvironment()方法中把实例放到StreamExecutionEnvironment类的静态属性threadLocalContextEnvironmentFactory 中，代码如下 1234protected static void initializeContextEnvironment(StreamExecutionEnvironmentFactory ctx) &#123; contextEnvironmentFactory = ctx; threadLocalContextEnvironmentFactory.set(contextEnvironmentFactory);&#125; 这样在用户程序StreamExecutionEnvironment.getExecutionEnvironment()时，获取到的运行环境就是StreamContextEnvironment类的setAsContext()方法中生成的本地运行环境LocalStreamEnvironment和 独立集群、flink on yarn等运行环境StreamContextEnvironment 的主要区别在于，他们的成员属性 configuration 不同。LocalStreamEnvironment 中是创建的空键值对(new Configuration())，而StreamContextEnvironment 是通过CliFrontend 生成的Configuration对象。 flink 的接口都是声明式的，那么到底把我们的接口解析或者封装成什么样进行执行了？声明式编程https://www.cnblogs.com/sirkevin/p/8283110.html flink runtime 架构概览 从上述整体的架构可以看出来，flink 的架构是区分客户端和服务端的，我们在客户端编写号代码，然后提交代码到服务端进行运行而且 flink 的接口是声明式的，那么这个过程中肯定会涉及到代码的包装执行。具体代码进行了哪些包装，如下图 4 个图的流程就是 flink 从客户端提交代码到服务端具体执行的整个解析过程： 1. StreamGraph：根据用户通过 Stream API 编写的代码生成的最初的图。 StreamNode：用来代表 operator 的类，并具有所有相关的属性，如并发度、入边和出边等。 StreamEdge：表示连接两个 StreamNode 的边。 是在客户端生成的，在 flink 中是一个具体的数据结构。 2. JobGraph：StreamGraph 经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。 JobVertex：经过优化后符合条件的多个 StreamNode 可能会 chain 在一起生成一个 JobVertex，即一个 JobVertex 包含一个或多个 operator，JobVertex 的输入是 JobEdge，输出是 IntermediateDataSet。 IntermediateDataSet：表示 JobVertex 的输出，即经过 operator 处理产生的数据集。producer 是 JobVertex，consumer 是 JobEdge。 JobEdge：代表了 job graph 中的一条数据传输通道。source 是 IntermediateDataSet，target 是 JobVertex。即数据通过 JobEdge 由 IntermediateDataSet 传递给目标 JobVertex。 是在客户端生成的，在 flink 中是一个具体的数据结构。 3. ExecutionGraph：JobManager 根据 JobGraph 生成 ExecutionGraph。ExecutionGraph 是 JobGraph 的并行化版本，是调度层最核心的数据结构。 ExecutionJobVertex：和 JobGraph 中的 JobVertex 一一对应。每一个 ExecutionJobVertex 都有和并发度一样多的 ExecutionVertex。 ExecutionVertex：表示 ExecutionJobVertex 的其中一个并发子任务，输入是 ExecutionEdge，输出是 IntermediateResultPartition。 IntermediateResult：和 JobGraph 中的 IntermediateDataSet 一一对应。一个 IntermediateResult 包含多个 IntermediateResultPartition，其个数等于该 operator 的并发度。 IntermediateResultPartition：表示 ExecutionVertex 的一个输出分区，producer 是 ExecutionVertex，consumer 是若干个 ExecutionEdge。 ExecutionEdge：表示 ExecutionVertex 的输入，source 是 IntermediateResultPartition，target 是 ExecutionVertex。source 和 target 都只能是一个。 Execution：是执行一个 ExecutionVertex 的一次尝试。当发生故障或者数据需要重算的情况下 ExecutionVertex 可能会有多个 ExecutionAttemptID。一个 Execution 通过 ExecutionAttemptID 来唯一标识。JM 和 TM 之间关于 task 的部署和 task status 的更新都是通过 ExecutionAttemptID 来确定消息接受者。 是在服务端生成的，在 flink 中是一个具体的数据结构。 4. 物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。 Task：Execution被调度后在分配的 TaskManager 中启动对应的 Task。Task 包裹了具有用户执行逻辑的 operator。 ResultPartition：代表由一个Task的生成的数据，和ExecutionGraph中的IntermediateResultPartition一一对应。 ResultSubpartition：是ResultPartition的一个子分区。每个ResultPartition包含多个ResultSubpartition，其数目要由下游消费 Task 数和 DistributionPattern 来决定。 InputGate：代表Task的输入封装，和JobGraph中JobEdge一一对应。每个InputGate消费了一个或多个的ResultPartition。 InputChannel：每个InputGate会包含一个以上的InputChannel，和ExecutionGraph中的ExecutionEdge一一对应，也和ResultSubpartition一对一地相连，即一个InputChannel接收一个ResultSubpartition的输出。 是在服务端生成的，不是具体的数据结构，而是实际的物理执行的一个图描述。 那么 Flink 为什么要设计这4张图呢，其目的是什么呢？Spark 中也有多张图，数据依赖图以及物理执行的 DAG。其目的都是一样的，就是解耦，每张图各司其职，每张图对应了 Job 不同的阶段，更方便做该阶段的事情。我们给出更完整的 Flink Graph 的层次图。 首先我们看到，JobGraph 之上除了 StreamGraph 还有 OptimizedPlan。OptimizedPlan 是由 Batch API 转换而来的。StreamGraph 是由 Stream API 转换而来的。为什么 API 不直接转换成 JobGraph？因为，Batch 和 Stream 的图结构和优化方法有很大的区别，比如 Batch 有很多执行前的预分析用来优化图的执行，而这种优化并不普适于 Stream，所以通过 OptimizedPlan 来做 Batch 的优化会更方便和清晰，也不会影响 Stream。JobGraph 的责任就是统一 Batch 和 Stream 的图，用来描述清楚一个拓扑图的结构，并且做了 chaining 的优化，chaining 是普适于 Batch 和 Stream 的，所以在这一层做掉。ExecutionGraph 的责任是方便调度和各个 tasks 状态的监控和跟踪，所以 ExecutionGraph 是并行化的 JobGraph。而“物理执行图”就是最终分布式在各个机器上运行着的tasks了。所以可以看到，这种解耦方式极大地方便了我们在各个层所做的工作，各个层之间是相互隔离的。 如何生成 StreamGraph？ 基于 1.12 源码。 StreamGraph 是在客户端构造的，这意味着我们可以在本地通过调试观察 StreamGraph 的构造过程。StreamGraph 生成的整个入口函数执行顺序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 开始执行代码public JobExecutionResult execute() throws Exception &#123; return execute(getJobName());&#125;public JobExecutionResult execute(String jobName) throws Exception &#123; Preconditions.checkNotNull(jobName, &quot;Streaming Job name should not be null.&quot;); return execute(getStreamGraph(jobName));&#125;// 生成 StreamGraphpublic StreamGraph getStreamGraph(String jobName, boolean clearTransformations) &#123; StreamGraph streamGraph = getStreamGraphGenerator().setJobName(jobName).generate(); ... return streamGraph;&#125;// 获取 StreamGraphGeneratorprivate StreamGraphGenerator getStreamGraphGenerator() &#123; ... return new StreamGraphGenerator(transformations, config, checkpointCfg, getConfiguration()) .setRuntimeExecutionMode(executionMode) .setStateBackend(defaultStateBackend) .setChaining(isChainingEnabled) .setUserArtifacts(cacheFile) .setTimeCharacteristic(timeCharacteristic) .setDefaultBufferTimeout(bufferTimeout);&#125;// 初始化 StreamGraphGeneratorpublic StreamGraphGenerator( List&lt;Transformation&lt;?&gt;&gt; transformations, ExecutionConfig executionConfig, CheckpointConfig checkpointConfig, ReadableConfig configuration) &#123; this.transformations = checkNotNull(transformations); this.executionConfig = checkNotNull(executionConfig); this.checkpointConfig = new CheckpointConfig(checkpointConfig); this.configuration = checkNotNull(configuration);&#125;// 客户端开始执行public JobExecutionResult execute(StreamGraph streamGraph) throws Exception &#123; final JobClient jobClient = executeAsync(streamGraph); ...&#125; 可以看到初始化 StreamGraphGenerator 需要传入四个参数，其中我们最需要关心的参数就是第一个 transformations； Transformation 是用来干啥的？https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/stream/operators/#datastream-transformations Transformation 其实就是我们在代码中定义的各种转换操作，比如 map，filter，flatmap，keyby 等转换操作，经过 flink 的简单包装之后成为 Transformation，其之间的具体关系如下图： 经过这么多层的封装，肯定是为用户自定义算子增强或者填充了一些功能，具体是哪些功能呢？ 举个例子： 1234567891011environment .fromElements(Tuple2.of(1, 1), Tuple2.of(2, 2), Tuple2.of(1, 3), Tuple2.of(2, 4), Tuple2.of(3, 10)) .map(t -&gt; t) .keyBy(new KeySelector&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt;() &#123; @Override public Integer getKey(Tuple2&lt;Integer, Integer&gt; i) throws Exception &#123; return i.f0; &#125; &#125;) .flatMap(new CountWindowAverage()) .print(); 先 debug 到 map(t -> t)，然后我们来看 env 中的变量： 从这个变量来看就可以和上面的图映射上了，分别是 OneInputTransformation -> StreamMap -> UserFunction；我们仔细看这些变量，来查看到底哪些增强了哪些功能。 1. StreamMap ChainingStrategy：flink 的优化策略中有本地性优化，就是会检查前一个算子和后一个算子是否能够 chain 在一起，这样的话就可以把数据的 shuffle 本地化，而 ChainingStrategy 就是这个优化的一个决定条件； 2. OneInputTransformation input：负责将上游 Transformation 进行存储，之后可以利用这个上下游关系串联整个 DAG； stateKeySelector：如果是 keyBy 后接 map，则 map 算子就会作用在具体 key 的数据上，这个就是对应的 KeySelector； stateKeyType：同 stateKeySelector，存储的是具体的 key 的类型信息； outputType：输出数据的类型信息； typeUsed：TODO； parallelism：算子并发度信息； maxParallelism：算子最大并发度信息； minResources，preferredResources：用户自定义细粒度的资源配置（这个 feature 还没有开放给用户）； managedMemoryWeight：TODO uid：状态恢复时的状态唯一标识，恢复时会根据状态中的 uid 和算子中的 uid 进行匹配，匹配不到状态就不能恢复； userProvidedNodeHash：TODO bufferTimeout：TODO slotSharingGroup：可以进行 slot 分享的 group 标识； coLocationGroupKey：TODO 注意不同的 Transformation 做了不同的增强，常见的 Transformation 有以下几类，大家可以自己进行 debug 查看都有哪些增强。 另外，并不是每一个 Transformation 都会转换成 runtime 层中物理操作。有一些只是逻辑概念，比如 union、split/select、partition等。如下图所示的转换树，在运行时会优化成下方的操作图。 union、split/select、partition 中的信息会被写入到 Source –&gt; Map 的边中。通过源码也可以发现，UnionTransformation,SplitTransformation,SelectTransformation,PartitionTransformation 由于不包含具体的操作所以都没有 StreamOperator 成员变量，而其他 Transformation 的子类基本上都有。 Transformation 的作用： 1：用户在编写时定义的上下游算子。即串联用户定义的原始 DAG 上下游信息。 2：用户在编写时定义的输入输出类型。即尝试获取算子输入输出类型信息以及对应的序列化器。 3：用户在编写时定义的算子并行度。即计算出每一个算子的并行度信息。 StreamGraph 是用来干啥的？先来看看 StreamGraph 实例 Transformation -&gt; StreamGraph我们来看看 StreamGraph 构建完成之后最主要的内容包含哪些？ DataStream 上的每一个 Transformation 都对应了一个 StreamOperator，StreamOperator是运行时的具体实现，会决定UDF(User-Defined Funtion)的调用方式。下图所示为 StreamOperator 的类图（点击查看大图）： 可以发现，所有实现类都继承了AbstractStreamOperator。另外除了 project 操作，其他所有可以执行UDF代码的实现类都继承自AbstractUdfStreamOperator，该类是封装了UDF的StreamOperator。UDF就是实现了Function接口的类，如MapFunction,FilterFunction。 我们通过在 DataStream 上做了一系列的转换（map、filter等）得到了 Transformation 集合，然后通过 StreamGraphGenerator.generate 获得 StreamGraph，该方法的源码如下： StreamGraphGenerator 中其实包含的最主要的内容就是各个类型 Transformation 的 Translator。如图所示； 每个 Translator 会将 Transformation 转换为对应的 StreamNode 或者 StreamEdge。 如何生成 JobGraph？我们来看看 JobGraph 构建完成之后最主要的内容包含哪些？ JobGraph 的相关数据结构主要在 org.apache.flink.runtime.jobgraph 包中。构造 JobGraph 的代码主要集中在 StreamingJobGraphGenerator 类中，入口函数是 StreamingJobGraphGenerator.createJobGraph()。我们首先来看下 StreamingJobGraphGenerator 的核心源码： StreamNode 转成 JobVertex，StreamEdge 转成 JobEdge，JobEdge 和 JobVertex 之间创建 IntermediateDataSet 来连接。关键点在于将多个 SteamNode chain 成一个 JobVertex的过程，这部分源码比较绕，有兴趣的同学可以结合源码单步调试分析。下一章将会介绍 JobGraph 提交到 JobManager 后是如何转换成分布式化的 ExecutionGraph 的。 每个 JobVertex 都会对应一个可序列化的 StreamConfig, 用来发送给 JobManager 和 TaskManager。最后在 TaskManager 中起 Task 时,需要从这里面反序列化出所需要的配置信息, 其中就包括了含有用户代码的StreamOperator。 setChaining会对source调用createChain方法，该方法会递归调用下游节点，从而构建出node chains。createChain会分析当前节点的出边，根据Operator Chains中的chainable条件，将出边分成chainalbe和noChainable两类，并分别递归调用自身方法。之后会将StreamNode中的配置信息序列化到StreamConfig中。如果当前不是chain中的子节点，则会构建 JobVertex 和 JobEdge相连。如果是chain中的子节点，则会将StreamConfig添加到该chain的config集合中。一个node chains，除了 headOfChain node会生成对应的 JobVertex，其余的nodes都是以序列化的形式写入到StreamConfig中，并保存到headOfChain的 CHAINED_TASK_CONFIG 配置项中。直到部署时，才会取出并生成对应的ChainOperators，具体过程请见理解 Operator Chains。 如何生成 StreamGraph？参考文章 http://wuchong.me/blog/2016/05/03/flink-internals-overview/ http://wuchong.me/blog/2016/05/04/flink-internal-how-to-build-streamgraph/ https://outofmemory.cn/article-201939.html http://wuchong.me/blog/2016/05/10/flink-internals-how-to-build-jobgraph/","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"深入浅出 | flink minicluster 启动流程","date":"2021-04-12T06:21:53.000Z","path":"2021/04/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/01_flink-sql/01_table-start/","text":"目录1.module 2.catalog 3.view 和 table 区别","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"深入浅出 | flink 全局一致性快照（一）","date":"2021-03-12T06:21:53.000Z","path":"2021/03/12/wechat-blog/apache-flink:state-1/","text":"目录 目录先带大家串一遍本篇文章的思路 什么是状态？发散思维的去思考状态，我们所理解的状态不仅仅只限于 flink 的状态，让大家了解到状态是一个无处不在的东西 什么是全局一致性快照？和状态有什么关系？全局一致性快照的一些生活、工作中应用的例子 为什么需要一致性快照？全局一致性快照和 flink 的关系？jvm GC，分布式应用做故障恢复（比如 flink），死锁检测等 全局一致性快照的分布式应用举例通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（类似拍照片）。flink 做 cp，sp，类似于每隔固定的时间从时间轴上的一个点拿出来这个时间点对应的一个全局一致性状态 全局一致性快照的标准定义假如说有两个事件，a 和 b，在绝对时间下，如果 a 发生在 b 之前，且 b 被包含在快照当中，那么则 a 事件或者其对快照产生的影响也被包含在快照当中 怎么实现全局一致性快照？同步去做，包括时钟同步、Stop-the-world，但是这两种方法都不可接受；既然同步无法做，那如果异步能做出相同的全局一致性状态也可以 分布式应用的全局一致性快照其 Process 状态和 Channel 状态到底需要记录什么？怎么记录 Channel 的状态？不是必须要在同一时刻嘛，为啥还能异步去做？只要异步做出来的状态和同步做出来的状态效果一致也可以。并且详细分析了 process 和 channel 中的状态包括什么，以及记录 channel 状态的方法。 分布式应用全局一致性快照算法流程总结通过第 8 章节的分析，总结出一套分布式应用的通用异步全局一致性快照算法 Chandy-Lamport 算法流程、例子介绍 Chandy-Lamport 算法流程并以一个例子介绍其执行过程，并且说明和第 9 章节分析得出的方法之间的关系，两者之间互相是不冲突的 flink 实现的全局一致性快照介绍大致介绍 flink 的全局一致性快照，并且也说明了和第 9 章节得出的方法之间的关系，两者之间也是不冲突的 分布式应用异步全局一致性快照方法、Chandy-Lamport 算法、flink 全局一致性快照之间的关系Chandy-Lamport 算法、flink 全局一致性快照也满足第 8 章节的结论；并且 Chandy-Lamport 算法、flink 全局一致性快照是分布式应用异步全局一致性快照方法一种特殊形式 参考文章本文编写过程中参考的文章 什么是状态？（了解状态）目标首先想让大家发散思维的去思考状态？我们所理解的状态不仅仅只限于 flink 的状态。让大家了解到状态是一个普遍存在的东西 定义就是当前计算需要依赖到之前计算的结果，那么之前计算的结果就是状态 举例 比如生活中的例子：为什么我知道我的面前放着一台电脑，因为眼睛接收到外界的图案，然后我的大脑接收到这个图案后，拿记忆中存储的图案进行对比，匹配得到这是电脑，那么记忆中存储的图案就是状态；还有比如日久生情，为什么感情会越来越深，因为今天的感情 = 今天积累的感情 + 以前积累的感情，以前积累的感情就是状态。这其中都存在状态 比如 web server 应用中的状态：打开 github 页面，列表展示了我的归属仓库。其中就是 web client 发了查询我的归属仓库请求，web server 接收到请求之后，然后去存储引擎中进行查询匹配返回。那么存储引擎中存储的内容就是状态 比如 flink 应用中的状态：要做当天 uid 去重，就要存储所有的 uid；要获取当前最大值，那么历史最大值就是状态 什么是全局一致性快照？（了解全局一致性快照） 全局：代表是一个分布式的 一致性快照：代表绝对时间的同一时刻的状态 相当于打开上帝视角，去观察同一时刻的应用所有的状态；这里的快照 = 状态，文章之后我可能会把这两个词混用，大家明白他们的意思一致即可 比如生活中的例子：比如拍了一个照片，那么照片的内容就是当时的一个全局一致性快照；每一个首脑都是一个进程，所有的进程的状态在同一时刻的组合就是一个全局一致性快照 比如分布式应用的例子：首先是一个分布式应用，它有多个进程分布在多个服务器上；其次，它在应用内部有自己的处理逻辑和状态；第三，应用间是可以互相通信的；第四，在这种分布式的应用，有内部状态，硬件可以通信的情况下；某一时刻的全局状态，就叫做全局的快照。 分布式应用某一时刻的全局一致性快照 = 各个 process 的本地状态 + channel 中正在传递的消息 介绍完了几个例子之后，我们来看看我们为什么需要一致性快照？ 为什么需要一致性快照？全局一致性快照和 flink 的关系？ 实时案例 做检查点（全局一致性快照）用来故障恢复，重点！！！重点！！！重点！！！就在于我们不必要从历史起点开始重跑所有的数据（其实这就是我们需要检查点的目的！！！）；因为 流式应用的上游存储介质一般都不支持存储历史所有数据（比如上游为 kafka，kafka 不可能存储历史所有数据） 重跑时效性不能满足时效性要求（重跑历史数据的情况下，时效性是达不到要求的） 可以做任务的死锁检测 全局一致性快照和 flink 的关系flink 的 cp 和 sp 实际上就是全局一致性快照在分布式应用中 flink 的一个具体实现。 全局一致性快照的分布式应用案例？通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（可以用拍照片去类比）。 示例下面分布式应用的一个示例： 每时每刻都存在全局一致性快照上面这个只是四个时刻的四个快照，其实应用的每一个时刻都存在一个全局一致性快照。 全局一致性快照的标准定义定义假如说有两个事件，a 和 b，在绝对时间下，如果 a 发生在 b 之前，且 b 被包含在快照当中，那么则 a 也被包含在快照当中。满足这个条件的全局快照，就称为全局一致性快照。 楼主理解就是如果将做了绝对时刻 T 的一个快照，那么这个绝对时刻 T 之前发生的所有事件以及其影响都会被包含在这个快照中 上文已经介绍了全局一致性快照的定义以及为什么我们需要全局一致性快照，那我们来放眼实际应用中，怎么才能做出一个满足生产实际要求的全局一致性快照呢？ 怎么实现全局一致性快照？ 实现方式主要分为同步实现方式和异步实现方式两类。 同步实现方式 NTP: NTP服务器[Network Time Protocol（NTP）]是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒）结论：无法实现 Stop-The-World 结论：不满足需求，无法采用 如果同步实现方式不满足需求，那么能使用异步方式做到同步相同的快照也是可以满足需求的。 异步实现方式 Chandy-Lamport 在介绍 Chandy-Lamport 算法之前，我们先介绍一些理论和数学上的概念铺垫铺垫，帮助我们理解 Chandy-Lamport 算法。这些概念主要就是介绍分布式应用的 Process 和 Channel 应该存储什么内容？以及怎样去存储这些内容？只有我们知道了要存储什么东西才好去设计和介绍具体算法嘛~楼主也是看了很多博客才总结得到了这些条件！！！ 分布式应用的全局一致性快照其 Process 状态和 Channel 状态记录了什么？怎么记录 Channel 的状态？分布式应用要记录的状态如下图案例 Single-Token conservation，是一个分布式应用，有 p 和 q 两个进程，p 可以通过 Channel pq（记为 Cpq） 向 q 发消息，q 可以通过 Channel qp（记为 Cqp） 向 p 发消息，其中有一个叫 token 的消息，在这个系统中一直不停的流转。 如之前所述，分布式应用的全局一致性快照包含 Process 状态和 Channel 状态那么上图 Single-Token conservation 示例中的全局一致性快照 S = S(p) + S(Cpq) + S(q) + S(Cqp) 其中： S：全局一致性快照 S(p)：p 进程的状态 S(Cpq)：p 进程到 q 进程的 Channel 状态 S(q)：q 进程的状态 S(Cqp)：q 进程到 p 进程的 Channel 状态 问题：这里就碰到了我们要分析的关键问题：做全局一致性快照时，其中 S(p)，S(q) 好理解，但是 S(Cpq)，S(Cqp) 到底记录了什么东西？应该记录什么东西？接下来详细讲讲我的理解 Process 状态应该记录什么内容？记录和用户业务需求相关的状态内容，用到了关于状态的地方，进行记录就好了，这部分是好理解的。举例：uid 去重就存储历史所有的 uid 就可以了 Channel 状态应该记录什么内容？Single-Token conservation 的全局一致性快照token 在 p 时（对应第一张图），这时的全局一致性快照为：S(token-in-p) = S(p-token-in-p) + S(Cpq-token-in-p) + S(q-token-in-p) + S(Cqp-token-in-p) 其中： S(token-in-p)：token 在 p 时，做的全局一致性快照 S(p-token-in-p)：token 在 p 时，p 进程的状态 S(Cpq-token-in-p)：token 在 p 时，p 进程到 q 进程的 Channel 状态 S(q-token-in-p)：token 在 p 时，q 进程的状态 S(Cqp-token-in-p)：token 在 p 时，q 进程到 p 进程的 Channel 状态 提出问题注意，上述这个表达式其实是结论，这个结论是很好理解的，但是你有想过站在实际应用的角度去思考下面的问题吗？ 问题1：为什么第一张图的全局一致性状态是 Process 和 Channel 做的快照都有 token-in-p 呢？根据之前的拍照片的类比，当前这个绝对时刻做快照时，token 在 p；那么所有的 process 和 channel 记录状态时，token 都应该在 p。 问题2：S(p-token-in-p) 好理解，在这个时刻 token 还没有从 p 发出去，p 做快照时肯定知道 token 还在 p；但是站在 Cpq 做状态的角度来说： Cpq 做状态时，怎么保障 Cpq 知道 token in p？需要我们探索下有什么方法怎么让 Cpq 在做状态时知道 token in p？ 站在实际在应用中实现的角度时，满足怎样的数学条件（我们要开始实现一个真实的全局一致性快照啦，肯定会涉及到一些数据知识，别急，往后看，用到的数学知识并不复杂）才能做出一个 S(Cpq) ？ 解决问题分析 S(Cpq) 记录了什么内容？这里我们简单先理解下，S(Cpq) 其实就是在 S(p) 和 S(q) 自己的状态做成时，还在 Channel pq 之间发送的那些消息。 那么我们怎么用数学的方式理解 Cpq 记录的这些消息以及 Process 和 Channel 做状态时需要满足的条件呢？让我们往下看 变量定义 n：在 p 的状态记录前，p 记录的 p 发往 Cpq 的 msg 数； n′：在 Cpq 的状态记录前，Cpq 记录的 p 发往 Cpq 的 msg 数； m：在 q 的状态记录前，q 记录的 q 从 Cpq 中接收到的 msg 数； m′：在 Cpq 的状态记录前，Cpq 记录的 q 从 Cpq 中接收到的 msg 数； 结论Cpq 记录 S(Cpq) 时，必然会有 n = n’ ≥ m = m’；（注意这是充分必要条件喔~）即一个 Channel 要记录的状态是，它 sender 记录自己状态之前它所接收到的 msg 列表，再减去 receiver 记录自己状态之前它已经收到的 msg 列表，减去的之后的数据列表就是还在通道中的数据列表，这个列表是需要 Channel 作为状态记录下来的。而如果 n′ = m′，那么 Channel c 中要记录的 msg 列表就是 empty 列表。如果 n′ &gt; m′，那么要记录的列表是 (m′+1),…n′ 号消息对应的 msg 列表。 证明首先是 n = n’，利用反证法：如果 n != n’，则会有两种情况： n &gt; n’ 时： 可能会出现 n = 10（p 记录状态前，p 记录 p 发往 Cpq msg 数为 10（msg 编号 1 - 10））； n’ = 7（Cpq 记录状态前，Cpq 记录 p 发往 Cpq 的 msg 数为 7（msg 编号 1 - 7））； 那么假设 token 的编号为 9，就会出现 p 记录的状态为 S(p-token-in-Cpq)，Cpq 记录的状态为 S(p-token-in-p)，实际是不可能出现的； n &lt; n’ 时： 可能会出现 n = 7（p 记录状态前，p 记录 p 发往 Cpq msg 数为 7（编号 1 - 7））； n’ = 10（Cpq 记录状态前，Cpq 记录 p 发往 Cpq 的 msg 数为 10（编号 1 - 10））； 那么假设 token 的编号为 9，就会出现 p 记录的状态为 S(p-token-in-p)，Cpq 记录的状态为 S(p-token-in-Cpq)，实际是不可能出现的； n = n’ 时：保障了无论什么情况下，只要 p 做出 S(p-token-in-p) 的状态时，因为 n = n’，代表 p 没有把 token 发出去，Cpq 也没有接受到 token，就能让 Cpq 也做出 S(Cpq-token-in-p)； 然后是 m = m’，同样利用反证法 m &gt; m’ 时： 可能会出现 n = n’ = m &gt; m’，q 记录状态前，Cpq 记录 q 从 Cpq 接收到的 msg 数为 10（编号 1 - 10，因为 n = n’ = m 也即 Cpq 记录的 p 发往 Cpq 的那些 msg）； Cpq记录状态前，Cpq 记录的 q 从 Cpq 接收到的 msg 数为 7（编号 1 - 7）； 那么假设 token 的编号为 9，就会出现 Cpq 记录的状态为 S(Cpq-token-in-Cpq)，q 记录的状态为 S(q-token-in-p)，实际是不可能出现的； 最后是 n’ ≥ m’ and n ≥ m：在任何一种情况下，做全局一致性快照时，都会有 Cpq 下游接收到的 msg 数不可能超过 p 发送给 Channel 的 msg 条数，即：n’ ≥ m’ 以及 n ≥ m（也可使用反证法证明） 分析到这里，上节提的两个问题也就被解决了。 为了帮大家更容易的理解全局一致性快照包含的内容，接下来我用伪代码描述一下，会比文字更好理解~ 来段伪代码描述全局一致快照包含的内容伪代码12345678910111213141516171819202122// S_all 即全局一致性快照S_all = null;// 假设总共有 x 个 processfor (int i = 1; i &lt;= x; i++) &#123; // 第 i 个 process 的状态为 S_i，直接按照 += 写，勿喷 S_all += S_i;&#125;// 假设总共有 y 个 channelfor (int i = 1; i &lt;= y; i++) &#123; // 1.S_C_out_in_i：第 i 个 channel 的状态，in 代表第 i 个 channel 的输入，out 含义为第 i 个 channel 的输出 // 2.m_out_in_i 和 n_out_in_i 其实就是上文中的 n 和 m // 2.m_out_in_i：第 i 个 channel 做快照前，发往 in process（下游）的消息个数 // 3.n_out_in_i：第 i 个 channel 做快照前，接受到 out process（上游） 的消息个数 // 4.需要注意，每一个 channel 的 m_out_in_i 和 n_out_in_i 都可能是不一样的，这里是伪代码所以直接按照下面的方式写了 S_C_out_in_i = Message[m_out_in_i + 1] + ... + Message[n_out_in_i]; S_all += S_C_out_in_i;&#125;// 状态做完啦~ 怎样去记录 S(Cpq)？通过上面的分析，我们已经讨论得到了 S(Cpq) 都包含了什么内容，并且其之间要满足什么样的数学关系。但是在现实实际生活中，消息在 Channel 上乱飞时，我们是无法记录这些消息作为 Channel 的状态的。但是这些消息终究会到达目的地，我们可以在消息的目的地去记录这些消息作为 Channel 的状态。即我们可以在 q 中记录 Channel pq 的 S(Cpq)，在 p 中记录 Channel pq 的 S(Cqp)。 伪代码顺便那么上面那段伪代码就可以简化为下面这样： 123456789101112131415161718192021222324252627// S_all 即全局一致性快照S_all = null;// 假设总共有 x 个 processfor (int i = 1; i &lt;= x; i++) &#123; // S_i_all：第 i 个 process 要记录的状态 S_i_all = null; // S_i：第 i 个 process 的状态 S_i_all += S_i; // 【直接按照 += 写，勿喷】 // 第 i 个 process 总共有 y 个 input channel，即有 y 个上游 process，下文中 j 即指代第 j 个 channel，也代指 j channel 的上游 j process for (int j = 1; j &lt;= y; j++) &#123; // 1.S_C_j_i：第 i 个 channel 的状态 // 2.m_j_i 和 n_j_i 其实就是上文中的 n 和 m // 2.m_j_i：第 j 个 channel 做快照前，发往 i（下游）的消息个数 // 3.n_j_i：第 j 个 channel 做快照前，接受到 j（上游） 的消息个数 // 4.需要注意，每一个 channel 的 m_j_i 和 n_j_i 都可能是不一样的，这里是伪代码所以直接按照下面的方式写了 S_C_j_i = Message[m_j_i + 1] + ... + Message[n_j_i]; S_i_all += S_C_j_i; &#125; S_all += S_i_all;&#125;// 状态做完啦~ 记录 S(Cpq) 需要满足的条件重点重点重点！！！分析上面的伪代码后，我们可以发现，要得到 S_all，其中只有一个变量在进程做快照时不知道的，那就是 n_j_i（即第 i 个 channel 做快照前，接受到 j（上游） 的消息个数），别忘了 n = n‘，即也可以定义为 j 做快照前，j 发往 channel 的消息个数。那么实际上这个值 j process 是知道的，就代表 i 进程需要知道 j 告诉他 n_j_i 的值是多少。重点来了，当 i process 做完快照之后，直接发一个 marker 下去，这个 marker 不会对计算有任何影响（即不会对状态产生任何影响），marker 只是一个标识，j process 做完自己的快照之后，直到接收到 marker 之间的消息就是Channel ij 的状态。i 就是通过 marker 来告诉 j process n_j_i 的值是多少的。（其他的变量为什么都知道就不详细分析了，很容易理解） 分布式应用全局一致性快照算法流程总结算法流程总结 发起快照：有一个 manager process（这个 manager 可以是所有 process 中的任意一个 process，也可以是一个单独的中央管理者）告诉所有的 process 说可以开始做状态了； 执行快照：所有 process 就开始记录自己本地的状态（非所有 input channel）了，记录完本地状态，然后发 marker 给下游所有的 channel，然后开始记录上游所有 input channel 的消息（直到接收到上游所有的 marker）； 执行快照：每个 process 对于每一个 input channel 来说，都将自己做完状态后直到收到 marker 之间的消息记录下来，作为这个 input channel 的状态； 执行快照：当收到上游所有 marker 之后，这个 process 要记录的状态就全部得到了，然后告诉 manager process 说做完状态了； 终止快照：manager process 接收到所有 process 做完的消息之后，就标记所有的状态以及完成了。 算法流程示例发起快照 有一个 manager process（这个 manager 可以是所有 process 中的任意一个 process，也可以是一个单独的中央管理者）告诉所有的 process 说可以开始做状态了； 执行快照 所有 process 就开始记录自己本地的状态（非所有 input channel）了，记录完本地状态，然后发 marker 给下游所有的 channel，然后开始记录上游所有 input channel 的消息（直到接收到上游所有的 marker）； 每个 process 对于每一个 input channel 来说，都将自己做完状态后直到收到 marker 之间的消息记录下来，作为这个 input channel 的状态； 当收到上游所有 marker 之后，这个 process 要记录的状态就全部得到了，然后告诉 manager process 说做完状态了； 终止快照 manager process 接收到所有 process 做完的消息之后，就标记所有的状态以及完成了。 Chandy-Lamport 算法流程、示例算法流程 发起快照解读： 本次快照的起始点，先把起始点的快照给做了，然后发出 marker（这个 marker 消息是干啥用的呢？没错，就是我们之前分析的结论），开始记录 input channel 执行快照解读： Pi 记录本地快照，标记 Cki 为空：因为从 Cki 接收到了 marker，这时的状态是 Pk 刚刚做完快照，Pk 做完快照发往 Cki 的消息个数 = Pi 做完快照从 Cki 接收到的消息个数。即 n = n’ = m’ = m；即 Cki = [Empty]； Pi 开始向所有 output channel 发 marker，开始记录除 Cki 之外的 input channel 消息，因为本地快照已经做完了；然后上游还有部分进程没有做完快照，为了记录除 Cki 之外的 input Channel 消息， 解读： 结合前一张图说的开始记录 input channel 消息，Pi 停止记录 Cki 的消息，同时将此前记录所有 Cki 收到的消息作为本次快照中的最终状态；n’ &gt; m’，在 Pi 这里记录了 Cki 的状态，即 Cki = [m‘ + 1, m’ + 2…n] 终止快照 示例 Chandy-Lamport 与上节分布式应用全局一致性快照算法的异同 Chandy-Lamport 就是上节分布式应用全局一致性快照算法的其中一种特殊形式；分布式应用全局一致性快照算法中说的是每个 process 在接收到 manager 做快照的消息之后就直接可以开始记录状态了，而 Chandy-Lamport 其实就是把这个 manager 的消息用接收到的第一个 marker 消息给代替了，用数学表达式表示就是接收到第一个 marker 的 channel 的 n = n’ = m = m’，剩余的 channel 满足 n = n’ ≥ m = m’，并且 Chandy-Lamport 算法也都满足第 8 章节介绍的各种条件。 flink 实现的全局一致性快照介绍（flink 容错机制）Chandy-Lamport 与 Flink之间的关系flink 全局一致性快照论文 Flink 是分布式系统，所以 Flink 会采用全局一致性快照的方式形成检查点，来支持故障恢复。Flink 的异步全局一致性快照算法跟 Chandy-Lamport 算法的区别主要有以下几点： 第一，Chandy-Lamport 支持强连通图，而 Flink支持弱连通图； 第二，Flink采用的是裁剪的（Tailored）Chandy-Lamport 异步快照算法； 第三，Flink的异步快照算法在DAG场景下不需要存储 Channel state，从而极大减少快照的存储空间。 flink 的容错机制 端到端的Exactly onceExactly once 的意思是，作业结果总是正确的，但是很可能产出多次；所以它的要求是需要有可重放的 source。端到端的 Exactly once，是指作业结果正确且只会被产出一次，它的要求除了有可重放的 source 外，还要求有事务型的 sink 和可以接收幂等的产出结果。 flink 的全局一致性快照 Barrier 对齐 flink 的全局一致性快照与上节分布式应用全局一致性快照算法的异同 flink 的全局一致性快照就是上节分布式应用全局一致性快照算法的其中一种特殊形式；分布式应用全局一致性快照算法中说的是每个 process 在接收到 manager 做快照的消息之后就直接可以开始记录状态了，而 flink 其实就是将各个 process 开始做状态的时间点设为了接收到上游 input channel 所有的 barrier，这样一个好处就是由于各个 process 是接收到了上游所有 barrier 之后开始的，用数学表达式表示其实就满足了 n = n’ = m = m’，就没有必要存储 channel 中的状态了；并且 flink 算法也都满足第 8 章节介绍的各种条件。 状态后端JVM Heap第一种，JVM Heap，它里面的数据是以Java对象形式存在的，读写也是以对象形式去完成的，所以速度很快。但是也存在两个弊端：第一个弊端，以对象方式存储所需的空间是磁盘上序列化压缩后的数据大小的很多倍，所以占用的内存空间很大；第二个弊端，虽然读写不用做序列化，但是在形成 snapshot 时需要做序列化，所以它的异步 snapshot 过程会比较慢。 RocksDB第二种，RocksDB，这个类型在读写时就需要做序列化，所以它读写的速度比较慢。但是它有一个好处，基于LSM的数据结构在快照之后会形成 sst 文件，它的异步 checkpoint 过程就是文件拷贝的过程，CPU 消耗会比较低。 分布式应用全局一致性快照算法、Chandy-Lamport 算法、flink 全局一致性快照之间的关系 参考的文章 https://developer.aliyun.com/article/667562 https://matt33.com/2019/10/27/paper-chandy-lamport/ https://developer.aliyun.com/article/448900","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"深入浅出 | flink 全局一致性快照（二）","date":"2021-03-12T06:21:53.000Z","path":"2021/03/12/wechat-blog/apache-flink:state-2/","text":"目录 目录先带大家串一遍本篇文章的思路 什么是状态？发散思维的去思考状态，我们所理解的状态不仅仅只限于 flink 的状态，让大家了解到状态是一个无处不在的东西 什么是全局一致性快照？和状态有什么关系？全局一致性快照的一些生活、工作中应用的例子 为什么需要一致性快照？全局一致性快照和 flink 的关系？jvm GC，分布式应用做故障恢复（比如 flink），死锁检测等 全局一致性快照的分布式应用举例通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（类似拍照片）。flink 做 cp，sp，类似于每隔固定的时间从时间轴上的一个点拿出来这个时间点对应的一个全局一致性状态 全局一致性快照的标准定义假如说有两个事件，a 和 b，在绝对时间下，如果 a 发生在 b 之前，且 b 被包含在快照当中，那么则 a 事件或者其对快照产生的影响也被包含在快照当中 怎么实现全局一致性快照？同步去做，包括时钟同步、Stop-the-world，但是这两种方法都不可接受；既然同步无法做，那如果异步能做出相同的全局一致性状态也可以 分布式应用的全局一致性快照其 Process 状态和 Channel 状态到底需要记录什么？怎么记录 Channel 的状态？不是必须要在同一时刻嘛，为啥还能异步去做？只要异步做出来的状态和同步做出来的状态效果一致也可以。并且详细分析了 process 和 channel 中的状态包括什么，以及记录 channel 状态的方法。 Chandy-Lamport 算法流程、例子介绍 Chandy-Lamport 算法流程并以一个例子介绍其执行过程 flink 实现的全局一致性快照介绍大致介绍 flink 的全局一致性快照 参考文章本文编写过程中参考的文章 什么是状态？（了解状态）","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"深入浅出 | flink 全局一致性快照（一）","date":"2021-03-12T06:21:53.000Z","path":"2021/03/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/03_state/01_apache-flink:state-1/","text":"本系列每篇文章都是从实际生产出发，帮助大家理解全局一致性快照。可能很多小伙伴都知道 flink 是使用 barrier 来做全局一致性快照，但是我提两个问题，为什么 flink 的 barrier 能够保证全局一致性快照的正确性？barrier 到底发挥了怎样的作用？小伙伴们能回答上来么，有想过背后的原因嘛，楼主通过本篇文章抛砖引玉，希望小伙伴们能够喜欢~ 通过本文你可以 get 到 通过本文你可以 get 到 先带大家串一遍本篇文章的思路 什么是状态？ 发散思维的去思考状态，我们所理解的状态不仅仅只限于 flink 的状态，让大家了解到状态是一个无处不在的东西 什么是全局一致性快照？和状态有什么关系？ 全局一致性快照的一些生活、工作中应用的例子 为什么需要一致性快照？全局一致性快照和 flink 的关系？ jvm GC，分布式应用做故障恢复（比如 flink），死锁检测等 全局一致性快照的分布式应用举例 通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（类似拍照片）。flink 做 cp，sp，类似于每隔固定的时间从时间轴上的一个点拿出来这个时间点对应的一个全局一致性状态 全局一致性快照的标准定义 假如说有两个事件，a 和 b，在绝对时间下，如果 a 发生在 b 之前，且 b 被包含在快照当中，那么则 a 事件或者其对快照产生的影响也被包含在快照当中 怎么实现全局一致性快照？ 同步去做，包括时钟同步、Stop-the-world，但是这两种方法都不可接受；既然同步无法做，那如果异步能做出相同的全局一致性状态也可以 分布式应用的全局一致性快照其 Process 状态和 Channel 状态到底需要记录什么？怎么记录 Channel 的状态？ 不是必须要在同一时刻嘛，为啥还能异步去做？只要异步做出来的状态和同步做出来的状态效果一致也可以。并且详细分析了 process 和 channel 中的状态包括什么，以及记录 channel 状态的方法。 分布式应用全局一致性快照算法流程总结 通过第 8 章节的分析，总结出一套分布式应用的通用异步全局一致性快照算法 Chandy-Lamport 算法流程、例子 介绍 Chandy-Lamport 算法流程并以一个例子介绍其执行过程，并且说明和第 9 章节分析得出的方法之间的关系，两者之间互相是不冲突的 flink 实现的全局一致性快照介绍 大致介绍 flink 的全局一致性快照，并且也说明了和第 9 章节得出的方法之间的关系，两者之间也是不冲突的 分布式应用异步全局一致性快照方法、Chandy-Lamport 算法、flink 全局一致性快照之间的关系 Chandy-Lamport 算法、flink 全局一致性快照也满足第 8 章节的结论；并且 Chandy-Lamport 算法、flink 全局一致性快照是分布式应用异步全局一致性快照方法一种特殊形式 参考文章 本文编写过程中参考的文章 什么是状态？（了解状态）目标首先想让大家发散思维的去思考状态？我们所理解的状态不仅仅只限于 flink 的状态。让大家了解到状态是一个普遍存在的东西 定义就是当前计算需要依赖到之前计算的结果，那么之前计算的结果就是状态 举例 比如生活中的例子：为什么我知道我的面前放着一台电脑，因为眼睛接收到外界的图案，然后我的大脑接收到这个图案后，拿记忆中存储的图案进行对比，匹配得到这是电脑，那么记忆中存储的图案就是状态；还有比如日久生情，为什么感情会越来越深，因为今天的感情 = 今天积累的感情 + 以前积累的感情，以前积累的感情就是状态。这其中都存在状态 比如 web server 应用中的状态：打开 github 页面，列表展示了我的归属仓库。其中就是 web client 发了查询我的归属仓库请求，web server 接收到请求之后，然后去存储引擎中进行查询匹配返回。那么存储引擎中存储的内容就是状态 比如 flink 应用中的状态：要做当天 uid 去重，就要存储所有的 uid；要获取当前最大值，那么历史最大值就是状态 什么是全局一致性快照？（了解全局一致性快照） 全局：代表是一个分布式的 一致性快照：代表绝对时间的同一时刻的状态 相当于打开上帝视角，去观察同一时刻的应用所有的状态；这里的快照 = 状态，文章之后我可能会把这两个词混用，大家明白他们的意思一致即可 比如生活中的例子：比如拍了一个照片，那么照片的内容就是当时的一个全局一致性快照；每一个首脑都是一个进程，所有的进程的状态在同一时刻的组合就是一个全局一致性快照 比如分布式应用的例子：首先是一个分布式应用，它有多个进程分布在多个服务器上；其次，它在应用内部有自己的处理逻辑和状态；第三，应用间是可以互相通信的；第四，在这种分布式的应用，有内部状态，硬件可以通信的情况下；某一时刻的全局状态，就叫做全局的快照。 分布式应用某一时刻的全局一致性快照 = 各个 process 的本地状态 + channel 中正在传递的消息 介绍完了几个例子之后，我们来看看我们为什么需要一致性快照？ 为什么需要一致性快照？全局一致性快照和 flink 的关系？ 实时案例 做检查点（全局一致性快照）用来故障恢复，重点！！！重点！！！重点！！！就在于我们不必要从历史起点开始重跑所有的数据（其实这就是我们需要检查点的目的！！！）；因为 流式应用的上游存储介质一般都不支持存储历史所有数据（比如上游为 kafka，kafka 不可能存储历史所有数据） 重跑时效性不能满足时效性要求（重跑历史数据的情况下，时效性是达不到要求的） 可以做任务的死锁检测 全局一致性快照和 flink 的关系flink 的 cp 和 sp 实际上就是全局一致性快照在分布式应用中 flink 的一个具体实现。 全局一致性快照的分布式应用案例？通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（可以用拍照片去类比）。 示例下面分布式应用的一个示例： 每时每刻都存在全局一致性快照上面这个只是四个时刻的四个快照，其实应用的每一个时刻都存在一个全局一致性快照。 全局一致性快照的标准定义定义假如说有两个事件，a 和 b，在绝对时间下，如果 a 发生在 b 之前，且 b 被包含在快照当中，那么则 a 也被包含在快照当中。满足这个条件的全局快照，就称为全局一致性快照。 楼主理解就是如果将做了绝对时刻 T 的一个快照，那么这个绝对时刻 T 之前发生的所有事件以及其影响都会被包含在这个快照中 上文已经介绍了全局一致性快照的定义以及为什么我们需要全局一致性快照，那我们来放眼实际应用中，怎么才能做出一个满足生产实际要求的全局一致性快照呢？ 怎么实现全局一致性快照？ 实现方式主要分为同步实现方式和异步实现方式两类。 同步实现方式 NTP: NTP服务器[Network Time Protocol（NTP）]是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒）结论：无法实现 Stop-The-World 结论：不满足需求，无法采用 如果同步实现方式不满足需求，那么能使用异步方式做到同步相同的快照也是可以满足需求的。 异步实现方式 Chandy-Lamport 在介绍 Chandy-Lamport 算法之前，我们先介绍一些理论和数学上的概念铺垫铺垫，帮助我们理解 Chandy-Lamport 算法。这些概念主要就是介绍分布式应用的 Process 和 Channel 应该存储什么内容？以及怎样去存储这些内容？只有我们知道了要存储什么东西才好去设计和介绍具体算法嘛~楼主也是看了很多博客才总结得到了这些条件！！！ 分布式应用的全局一致性快照其 Process 状态和 Channel 状态记录了什么？怎么记录 Channel 的状态？分布式应用要记录的状态如下图案例 Single-Token conservation，是一个分布式应用，有 p 和 q 两个进程，p 可以通过 Channel pq（记为 Cpq） 向 q 发消息，q 可以通过 Channel qp（记为 Cqp） 向 p 发消息，其中有一个叫 token 的消息，在这个系统中一直不停的流转。 如之前所述，分布式应用的全局一致性快照包含 Process 状态和 Channel 状态那么上图 Single-Token conservation 示例中的全局一致性快照 S = S(p) + S(Cpq) + S(q) + S(Cqp) 其中： S：全局一致性快照 S(p)：p 进程的状态 S(Cpq)：p 进程到 q 进程的 Channel 状态 S(q)：q 进程的状态 S(Cqp)：q 进程到 p 进程的 Channel 状态 问题：这里就碰到了我们要分析的关键问题：做全局一致性快照时，其中 S(p)，S(q) 好理解，但是 S(Cpq)，S(Cqp) 到底记录了什么东西？应该记录什么东西？接下来详细讲讲我的理解 Process 状态应该记录什么内容？记录和用户业务需求相关的状态内容，用到了关于状态的地方，进行记录就好了，这部分是好理解的。举例：uid 去重就存储历史所有的 uid 就可以了 Channel 状态应该记录什么内容？Single-Token conservation 的全局一致性快照token 在 p 时（对应第一张图），这时的全局一致性快照为：S(token-in-p) = S(p-token-in-p) + S(Cpq-token-in-p) + S(q-token-in-p) + S(Cqp-token-in-p) 其中： S(token-in-p)：token 在 p 时，做的全局一致性快照 S(p-token-in-p)：token 在 p 时，p 进程的状态 S(Cpq-token-in-p)：token 在 p 时，p 进程到 q 进程的 Channel 状态 S(q-token-in-p)：token 在 p 时，q 进程的状态 S(Cqp-token-in-p)：token 在 p 时，q 进程到 p 进程的 Channel 状态 提出问题注意，上述这个表达式其实是结论，这个结论是很好理解的，但是你有想过站在实际应用的角度去思考下面的问题吗？ 问题1：为什么第一张图的全局一致性状态是 Process 和 Channel 做的快照都有 token-in-p 呢？根据之前的拍照片的类比，当前这个绝对时刻做快照时，token 在 p；那么所有的 process 和 channel 记录状态时，token 都应该在 p。 问题2：S(p-token-in-p) 好理解，在这个时刻 token 还没有从 p 发出去，p 做快照时肯定知道 token 还在 p；但是站在 Cpq 做状态的角度来说： Cpq 做状态时，怎么保障 Cpq 知道 token in p？需要我们探索下有什么方法怎么让 Cpq 在做状态时知道 token in p？ 站在实际在应用中实现的角度时，满足怎样的数学条件（我们要开始实现一个真实的全局一致性快照啦，肯定会涉及到一些数据知识，别急，往后看，用到的数学知识并不复杂）才能做出一个 S(Cpq) ？ 解决问题分析 S(Cpq) 记录了什么内容？这里我们简单先理解下，S(Cpq) 其实就是在 S(p) 和 S(q) 自己的状态做成时，还在 Channel pq 之间发送的那些消息。 那么我们怎么用数学的方式理解 Cpq 记录的这些消息以及 Process 和 Channel 做状态时需要满足的条件呢？让我们往下看 变量定义 n：在 p 的状态记录前，p 记录的 p 发往 Cpq 的 msg 数； n′：在 Cpq 的状态记录前，Cpq 记录的 p 发往 Cpq 的 msg 数； m：在 q 的状态记录前，q 记录的 q 从 Cpq 中接收到的 msg 数； m′：在 Cpq 的状态记录前，Cpq 记录的 q 从 Cpq 中接收到的 msg 数； 结论Cpq 记录 S(Cpq) 时，必然会有 n = n’ ≥ m = m’；（注意这是充分必要条件喔~）即一个 Channel 要记录的状态是，它 sender 记录自己状态之前它所接收到的 msg 列表，再减去 receiver 记录自己状态之前它已经收到的 msg 列表，减去的之后的数据列表就是还在通道中的数据列表，这个列表是需要 Channel 作为状态记录下来的。而如果 n′ = m′，那么 Channel c 中要记录的 msg 列表就是 empty 列表。如果 n′ &gt; m′，那么要记录的列表是 (m′+1),…n′ 号消息对应的 msg 列表。 证明首先是 n = n’，利用反证法：如果 n != n’，则会有两种情况： n &gt; n’ 时： 可能会出现 n = 10（p 记录状态前，p 记录 p 发往 Cpq msg 数为 10（msg 编号 1 - 10））； n’ = 7（Cpq 记录状态前，Cpq 记录 p 发往 Cpq 的 msg 数为 7（msg 编号 1 - 7））； 那么假设 token 的编号为 9，就会出现 p 记录的状态为 S(p-token-in-Cpq)，Cpq 记录的状态为 S(p-token-in-p)，实际是不可能出现的； n &lt; n’ 时： 可能会出现 n = 7（p 记录状态前，p 记录 p 发往 Cpq msg 数为 7（编号 1 - 7））； n’ = 10（Cpq 记录状态前，Cpq 记录 p 发往 Cpq 的 msg 数为 10（编号 1 - 10））； 那么假设 token 的编号为 9，就会出现 p 记录的状态为 S(p-token-in-p)，Cpq 记录的状态为 S(p-token-in-Cpq)，实际是不可能出现的； n = n’ 时：保障了无论什么情况下，只要 p 做出 S(p-token-in-p) 的状态时，因为 n = n’，代表 p 没有把 token 发出去，Cpq 也没有接受到 token，就能让 Cpq 也做出 S(Cpq-token-in-p)； 然后是 m = m’，同样利用反证法 m &gt; m’ 时： 可能会出现 n = n’ = m &gt; m’，q 记录状态前，Cpq 记录 q 从 Cpq 接收到的 msg 数为 10（编号 1 - 10，因为 n = n’ = m 也即 Cpq 记录的 p 发往 Cpq 的那些 msg）； Cpq记录状态前，Cpq 记录的 q 从 Cpq 接收到的 msg 数为 7（编号 1 - 7）； 那么假设 token 的编号为 9，就会出现 Cpq 记录的状态为 S(Cpq-token-in-Cpq)，q 记录的状态为 S(q-token-in-p)，实际是不可能出现的； 最后是 n’ ≥ m’ and n ≥ m：在任何一种情况下，做全局一致性快照时，都会有 Cpq 下游接收到的 msg 数不可能超过 p 发送给 Channel 的 msg 条数，即：n’ ≥ m’ 以及 n ≥ m（也可使用反证法证明） 分析到这里，上节提的两个问题也就被解决了。 为了帮大家更容易的理解全局一致性快照包含的内容，接下来我用伪代码描述一下，会比文字更好理解~ 来段伪代码描述全局一致快照包含的内容伪代码12345678910111213141516171819202122// S_all 即全局一致性快照S_all = null;// 假设总共有 x 个 processfor (int i = 1; i &lt;= x; i++) &#123; // 第 i 个 process 的状态为 S_i，直接按照 += 写，勿喷 S_all += S_i;&#125;// 假设总共有 y 个 channelfor (int i = 1; i &lt;= y; i++) &#123; // 1.S_C_out_in_i：第 i 个 channel 的状态，in 代表第 i 个 channel 的输入，out 含义为第 i 个 channel 的输出 // 2.m_out_in_i 和 n_out_in_i 其实就是上文中的 n 和 m // 2.m_out_in_i：第 i 个 channel 做快照前，发往 in process（下游）的消息个数 // 3.n_out_in_i：第 i 个 channel 做快照前，接受到 out process（上游） 的消息个数 // 4.需要注意，每一个 channel 的 m_out_in_i 和 n_out_in_i 都可能是不一样的，这里是伪代码所以直接按照下面的方式写了 S_C_out_in_i = Message[m_out_in_i + 1] + ... + Message[n_out_in_i]; S_all += S_C_out_in_i;&#125;// 状态做完啦~ 怎样去记录 S(Cpq)？通过上面的分析，我们已经讨论得到了 S(Cpq) 都包含了什么内容，并且其之间要满足什么样的数学关系。但是在现实实际生活中，消息在 Channel 上乱飞时，我们是无法记录这些消息作为 Channel 的状态的。但是这些消息终究会到达目的地，我们可以在消息的目的地去记录这些消息作为 Channel 的状态。即我们可以在 q 中记录 Channel pq 的 S(Cpq)，在 p 中记录 Channel pq 的 S(Cqp)。 伪代码顺便那么上面那段伪代码就可以简化为下面这样： 123456789101112131415161718192021222324252627// S_all 即全局一致性快照S_all = null;// 假设总共有 x 个 processfor (int i = 1; i &lt;= x; i++) &#123; // S_i_all：第 i 个 process 要记录的状态 S_i_all = null; // S_i：第 i 个 process 的状态 S_i_all += S_i; // 【直接按照 += 写，勿喷】 // 第 i 个 process 总共有 y 个 input channel，即有 y 个上游 process，下文中 j 即指代第 j 个 channel，也代指 j channel 的上游 j process for (int j = 1; j &lt;= y; j++) &#123; // 1.S_C_j_i：第 i 个 channel 的状态 // 2.m_j_i 和 n_j_i 其实就是上文中的 n 和 m // 2.m_j_i：第 j 个 channel 做快照前，发往 i（下游）的消息个数 // 3.n_j_i：第 j 个 channel 做快照前，接受到 j（上游） 的消息个数 // 4.需要注意，每一个 channel 的 m_j_i 和 n_j_i 都可能是不一样的，这里是伪代码所以直接按照下面的方式写了 S_C_j_i = Message[m_j_i + 1] + ... + Message[n_j_i]; S_i_all += S_C_j_i; &#125; S_all += S_i_all;&#125;// 状态做完啦~ 记录 S(Cpq) 需要满足的条件重点重点重点！！！分析上面的伪代码后，我们可以发现，要得到 S_all，其中只有一个变量在进程做快照时不知道的，那就是 n_j_i（即第 i 个 channel 做快照前，接受到 j（上游） 的消息个数），别忘了 n = n‘，即也可以定义为 j 做快照前，j 发往 channel 的消息个数。那么实际上这个值 j process 是知道的，就代表 i 进程需要知道 j 告诉他 n_j_i 的值是多少。重点来了，当 i process 做完快照之后，直接发一个 marker 下去，这个 marker 不会对计算有任何影响（即不会对状态产生任何影响），marker 只是一个标识，j process 做完自己的快照之后，直到接收到 marker 之间的消息就是Channel ij 的状态。i 就是通过 marker 来告诉 j process n_j_i 的值是多少的。（其他的变量为什么都知道就不详细分析了，很容易理解） 分布式应用全局一致性快照算法流程总结算法流程总结 发起快照：有一个 manager process（这个 manager 可以是所有 process 中的任意一个 process，也可以是一个单独的中央管理者）告诉所有的 process 说可以开始做状态了； 执行快照：所有 process 就开始记录自己本地的状态（非所有 input channel）了，记录完本地状态，然后发 marker 给下游所有的 channel，然后开始记录上游所有 input channel 的消息（直到接收到上游所有的 marker）； 执行快照：每个 process 对于每一个 input channel 来说，都将自己做完状态后直到收到 marker 之间的消息记录下来，作为这个 input channel 的状态； 执行快照：当收到上游所有 marker 之后，这个 process 要记录的状态就全部得到了，然后告诉 manager process 说做完状态了； 终止快照：manager process 接收到所有 process 做完的消息之后，就标记所有的状态以及完成了。 算法流程示例发起快照 有一个 manager process（这个 manager 可以是所有 process 中的任意一个 process，也可以是一个单独的中央管理者）告诉所有的 process 说可以开始做状态了； 执行快照 所有 process 就开始记录自己本地的状态（非所有 input channel）了，记录完本地状态，然后发 marker 给下游所有的 channel，然后开始记录上游所有 input channel 的消息（直到接收到上游所有的 marker）； 每个 process 对于每一个 input channel 来说，都将自己做完状态后直到收到 marker 之间的消息记录下来，作为这个 input channel 的状态； 当收到上游所有 marker 之后，这个 process 要记录的状态就全部得到了，然后告诉 manager process 说做完状态了； 终止快照 manager process 接收到所有 process 做完的消息之后，就标记所有的状态以及完成了。 Chandy-Lamport 算法流程、示例算法流程 发起快照解读： 本次快照的起始点，先把起始点的快照给做了，然后发出 marker（这个 marker 消息是干啥用的呢？没错，就是我们之前分析的结论），开始记录 input channel 执行快照解读： Pi 记录本地快照，标记 Cki 为空：因为从 Cki 接收到了 marker，这时的状态是 Pk 刚刚做完快照，Pk 做完快照发往 Cki 的消息个数 = Pi 做完快照从 Cki 接收到的消息个数。即 n = n’ = m’ = m；即 Cki = [Empty]； Pi 开始向所有 output channel 发 marker，开始记录除 Cki 之外的 input channel 消息，因为本地快照已经做完了；然后上游还有部分进程没有做完快照，为了记录除 Cki 之外的 input Channel 消息， 解读： 结合前一张图说的开始记录 input channel 消息，Pi 停止记录 Cki 的消息，同时将此前记录所有 Cki 收到的消息作为本次快照中的最终状态；n’ &gt; m’，在 Pi 这里记录了 Cki 的状态，即 Cki = [m‘ + 1, m’ + 2…n] 终止快照 示例 Chandy-Lamport 与上节分布式应用全局一致性快照算法的异同 Chandy-Lamport 就是上节分布式应用全局一致性快照算法的其中一种特殊形式；分布式应用全局一致性快照算法中说的是每个 process 在接收到 manager 做快照的消息之后就直接可以开始记录状态了，而 Chandy-Lamport 其实就是把这个 manager 的消息用接收到的第一个 marker 消息给代替了，用数学表达式表示就是接收到第一个 marker 的 channel 的 n = n’ = m = m’，剩余的 channel 满足 n = n’ ≥ m = m’，并且 Chandy-Lamport 算法也都满足第 8 章节介绍的各种条件。 flink 实现的全局一致性快照介绍（flink 容错机制）Chandy-Lamport 与 Flink之间的关系flink 全局一致性快照论文 Flink 是分布式系统，所以 Flink 会采用全局一致性快照的方式形成检查点，来支持故障恢复。Flink 的异步全局一致性快照算法跟 Chandy-Lamport 算法的区别主要有以下几点： 第一，Chandy-Lamport 支持强连通图，而 Flink支持弱连通图； 第二，Flink采用的是裁剪的（Tailored）Chandy-Lamport 异步快照算法； 第三，Flink的异步快照算法在DAG场景下不需要存储 Channel state，从而极大减少快照的存储空间。 flink 的容错机制 端到端的Exactly onceExactly once 的意思是，作业结果总是正确的，但是很可能产出多次；所以它的要求是需要有可重放的 source。端到端的 Exactly once，是指作业结果正确且只会被产出一次，它的要求除了有可重放的 source 外，还要求有事务型的 sink 和可以接收幂等的产出结果。 flink 的全局一致性快照 Barrier 对齐 flink 的全局一致性快照与上节分布式应用全局一致性快照算法的异同 flink 的全局一致性快照就是上节分布式应用全局一致性快照算法的其中一种特殊形式；分布式应用全局一致性快照算法中说的是每个 process 在接收到 manager 做快照的消息之后就直接可以开始记录状态了，而 flink 其实就是将各个 process 开始做状态的时间点设为了接收到上游 input channel 所有的 barrier，这样一个好处就是由于各个 process 是接收到了上游所有 barrier 之后开始的，用数学表达式表示其实就满足了 n = n’ = m = m’，就没有必要存储 channel 中的状态了；并且 flink 算法也都满足第 8 章节介绍的各种条件。 状态后端JVM Heap第一种，JVM Heap，它里面的数据是以Java对象形式存在的，读写也是以对象形式去完成的，所以速度很快。但是也存在两个弊端：第一个弊端，以对象方式存储所需的空间是磁盘上序列化压缩后的数据大小的很多倍，所以占用的内存空间很大；第二个弊端，虽然读写不用做序列化，但是在形成 snapshot 时需要做序列化，所以它的异步 snapshot 过程会比较慢。 RocksDB第二种，RocksDB，这个类型在读写时就需要做序列化，所以它读写的速度比较慢。但是它有一个好处，基于LSM的数据结构在快照之后会形成 sst 文件，它的异步 checkpoint 过程就是文件拷贝的过程，CPU 消耗会比较低。 分布式应用全局一致性快照算法、Chandy-Lamport 算法、flink 全局一致性快照之间的关系 参考的文章 https://developer.aliyun.com/article/667562 https://matt33.com/2019/10/27/paper-chandy-lamport/ https://developer.aliyun.com/article/448900","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink x TiDB meetup 小记","date":"2021-03-12T06:21:53.000Z","path":"2021/03/12/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/02_数据内容建设/03_one-engine/01_计算引擎/01_flink/10_meetup/01_apache-flink-meetup-20210710-beijing/","text":"现场回顾。PPT 公众号回复 20210710 获取。 博主是带着一些问题去参加本次 meetup 的。 第一个就是实时数仓的建设经验，不论是引擎、工具链还是数仓层面。 第二个就是实时数仓的数据时效性、质量保障经验。 但是总结来说这次 meetup 博主更多的是得到了开发技术方面的输入，保障层面的输入还是较少。 网易 - JFlink on TiDB 博主在听完分享之后比较感兴趣的几个问题，和林佳老师交流了下。 JFlink-SDK 是干什么的？ 引擎侧支持：提供引擎侧运维能力，metric 采集等功能； 工具链侧支持：在 flink datastream api 能力的基础上提供 DSL api 能力，让用户通过简单的声明配置就可以上线任务。 JFlink-SDK 目前支持 flink sql 吗？目前暂时不支持 flink sql，不过目前 JFlink-SDK 的能力支持类似于 flink sql。举个例子：用户使用 JFlink-SDK 的方式就是类似于 flink sql create table 后的 with xxx properties。通过声明 properties 进行开发。由于两者的类似性，所以之后 JFlink-SDK 会考虑融合 flink sql。 博主理解其实就是在目前 JFlink-SDK 的能力上加上 + schema = flink sql。所以这个融合过程复杂度应该不是很高。 目前网易是怎样做实时数据的时效性、质量监控以及保障的？ 时效性：监控通过采集的 metrics 发现并且进行报警；并且采样算子级别的平均处理时延。 质量监控：目前质量监控这块首先是从开发阶段就要求所有的实时任务都一定具备可回溯性。举个例子：当任务出现数据计算错误时，可回溯性的任务从历史 ck 进行数据回溯即可。但是针对某些大状态实时指标，使用了外部 state 引擎（比如 redis 等），也只能是重新手动清除 redis 进行数据回溯。 目前端到端 exactly-once 的适用情况？ sink 为 TIDB：通过幂等操作实现：at-least-once + 主键重入实现。 sink 为 kafka：通过两阶段提交实现，目前网易对 kafka 的两阶段提交使用是很广泛的。但是两阶段必然会引进数据产出延迟的问题，因此会将两阶段的参数暴露给用户，让用户根据自己的业务诉求进行选择。 对于大状态任务有没有什么实战优化经验？目前也没有非常好的的优化方案。但是可以从以下两个角度去进行优化。 大状态 flink state：rocksdb compaction 压缩 大状态外存：redis 等 PingCAP - 实时数仓之美 TiDB（HTAP） = TiKV（OLTP，行存）+ TiFlush（OLAP，列存）= 大号的 MySQL。 TiDB 对标 MySQL，在此基础之上，如果用户有分析需求，可以进行配置打开 TiFlush 能力，进行 OLAP 分析。底层是两套存储。 flink = 接换发 = 接（接收数据） + 换（进行转换处理） + 发（发送数据） 分享之后和王天宜老师的交流。 计算引擎侧 flink 实现了流批一体，存储引擎呢？存储引擎其实目前已经有了开源的方案，可以了解下 pravega。但是底层引擎能力切换的推动还是需要从上往下。即业务遇到了瓶颈，需要这种解决方案，才能更快速的去推动引擎以及架构的改变。这种新架构的变革从引擎底层进行推动还是比较困难的。 说道这里，博主认为 TiDB 是一个非常好的存储引擎。博主认为其好的地方就在于其 HTAP 能力。站在用户角度，用户只关心我需要 OLAP + OLTP 的能力，接口简单明了就完事了。底层的引擎不应该是用户关心的。无论你底层是 MySQL 还是 Postgre（OLTP），ClickHouse 还是 Druid（OLAP），只要接口层能以一套 API 给我使用就 very good 了。而目前 TiDB 能把 HTAP 的能力都能以 MySQL 这样的统一接口协议给用户。用户的理解、使用成本是很低的。 两阶段提交一定会保障不重、不丢数据吗？是没法 100% 保障的。举个其他的例子：hdfs 三副本也没法 100% 保障 hdfs 数据是完全可用的。但是目前在我们的场景中两阶段提交没有出现过问题。其实目前有还有三阶段。可以根据业务需求进行选择。 TiFlush vs ClickHouse vs Doris？因为目前 TiDB 定位是 HTAP，TiFlush 相比于专门定位与 OLAP 场景 ClickHouse vs Doris 的能力还不是非常完善，性能也不如其好。但是 TiFlush 也是在一直持续不断的学习以及完善过程中。 知乎 - TiDB x Flink 的端到端实时计算 没听，哈哈，和王天宜老师交流 high 了。果然和大佬们交流还是很爽的。 360 - Flink SQL 在奇虎 360 的实践 主要介绍了一些 flink sql 在引擎 + 工具链层面的定制化优化。 flink sql udf 结果复用 这个功能还是很有用的，尤其是做 ods -&gt; dwd 清洗时，由于 flink sql 的各种上推优化，会导致 udf 重复执行，当你遇到一个大 json 解析时，不好意思，你的任务以及废了一半了。顺带夸一嘴，博主所在公司已经实现了表达式复用。 flink sql 算子自定义并行度 就是将 dag 序列化成 json，用户在界面上重新配吧配吧算子并发。 博主的理解：这个功能在资源没有非常紧张的情况下的优化效果其实不是很明显的。 个人理解，个人理解，勿喷勿喷。下面有原因。 第一个方面，在任务运行侧，因为大多数 flink sql 任务当任务出现瓶颈时，往往都是其中一个算子出现了瓶颈，那么基本上这个算子就是所有算子中的并发度最大的，这个时候，flink sql 默认其他算子的并发也是这个并发，但是其他算子又没有出现性能瓶颈，只是并发给了大一点，都是空跑，资源的浪费其实不是非常明显的。至少目前博主遇到过的场景中是这样的。 第二个方面，在 DE 开发侧，flink sql 毕竟面向的还是 DE，大多数 DE 干的工作就是关注业务场景写一个简单的 sql，很多场景下，没时间以及精力做那么多优化。最简单的一个道理，一个引擎能真正用起来，在接口层看的不是你这个引擎配置化能力多牛逼，更多的还是接口层简单，让用户先用起来，上手方便。 但是，站在资源治理的角度上，这个功能是很有效的。 上述都是博主站在自己目前的场景下进行的一些分析。 阿里 - flink-cdc 作为一个个人孵化的子项目，受到很多同学、公司的青睐。 flink cdc 与各开源 cdc 的优劣势对比 flink cdc 目前不支持 ck，失败之后要重跑 flink cdc 2.0 的规划 博主目前所在的公司，binlog 采集都是由基础架构统一管理的。cdc 只能处于一个探索阶段。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时数据时效监控体系建设","date":"2020-12-01T06:21:53.000Z","path":"2020/12/01/wechat-blog/apache-flink:realtime-time-monitor/","text":"本系列介绍了实时数据时效监控体系的建设。 前言数据延迟为是实时数据的一个最大问题。其实不管是哪部分产生延迟，最终的结果是都会直接影响到上层指标（数据质量问题 + 数据时效问题）。为了方便我们在开发阶段，运维阶段快速定位、解决延迟导致的问题；以及为后续可能的报警能力提供基础能力，因此需要建设实时数据流时效监控体系。 以一张图描述整个传输链路与耗时相关的问题。 总结上述图总共分为以下三部分。 数据延迟监控 数据乱序监控 数据加工延迟监控","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | Flink + 直播（三）| 如何建设当前正在直播 xx 数？","date":"2020-11-11T06:21:53.000Z","path":"2020/11/11/wechat-blog/apache-flink:realtime-live-stream-3/","text":"生产实践 | Flink + 直播（三）| 如何建设当前正在直播 xx 数？ 本系列每篇文章都是从一些实际的 case 出发，分析一些生产环境中经常会遇到的问题，抛砖引玉，以帮助小伙伴们解决一些实际问题。本篇文章主要介绍直播间生产侧指标的建设过程，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 整体架构本文主要介绍生产侧指标的建设，比如当前正在直播直播间数，或者主播数等。在介绍生产侧指标的建设过程之前，我们先回顾下上一节的架构图。 而本篇要介绍的生产侧指标的数据链路主要对应以下几个模块。 数据源：读取直播生产，比如开播，关播等 kafka 数据源日志； 数据处理：使用生产侧数据源 + 实时画像维表 + flink 建设生产侧实时指标； 数据汇：将处理完成的指标数据写入到 kafka 中。 我用另一张图进行了标注，图中标红模块为生产侧指标的数据链路涉及到的模块。 其中直播间实时画像维表的介绍已经在上节进行了介绍，感兴趣的话可以点击以下链接，跳转到上节进行阅读~ 本小节就不针对生产侧指标的建设中所有涉及指标的建设过程进行详细介绍了，我们主要以当前分钟正在开播直播间数作为生产侧指标建设的一个代表性案例，介绍这个指标的整个建设过程。来为大家还原生产侧指标的业务过程以及技术方案。 Question仍然从几个问题入手，介绍当前分钟正在开播直播间数的建设过程。 当前分钟正在开播直播间数的定义什么？业务过程是怎么样的？举例？ 怎样去建设这个指标？整体的指标计算流程？ 1.聊聊定义？当前分钟正在开播直播间数，其定义就是整个平台中，当前分钟正在开播的直播间数 + 单层维度下钻的当前分钟正在开播的直播间数。 举例： 现在的时间点是 2020-11-11 12:42，真实直播的直播间数为 3000 个（平台维度下钻：IOS 平台为 1500，安卓平台为 1500） 到了 12:43 时，有 200 个直播间进行了关播（其中 100 个为 IOS，100 个为安卓），有 100 个直播间开播（全部为 IOS），则当前正在直播的直播间数为 2900（平台维度下钻：IOS 平台为 1500，安卓平台为 1400）。 其中 2020-11-11 12:42 的 3000 以及 2020-11-11 12:43 的 2900 以及按照平台下钻的数值就为当前时间正在开播的直播间数。 因此根据上述定义和分析，我们可以直接将数据源和数据汇的 schema 定义下来，主体信息如下。 数据源 schema 字段 备注 live_stream_id 直播间 id author_id 主播 id start_or_end 开播还是关播 timestamp 时间戳 … … 数据汇 schema 字段 备注 timestamp 时间戳，汇总到分钟粒度 metric_name 指标名，举例：开播直播间数 metric_value 指标值，举例：3000（开播直播间数） dim_name 维度名，举例：平台，版本 dim_value 维度值，举例：IOS，8.1 … … Notes: metric_name 和 metric_value： 这两个字段是为了之后进行指标扩充时进行的设计。比如后续如果需要加入开播主播数，开播时长等指标，不用修改数据汇 schema，只需要加一种 metric_name，就可以使用原有 schema 进行数据产出。 dim_name 和 dim_value： 目前我们建设的指标只提供了进行单维度下钻的能力，所以设计了 dim_name 和 dim_value 两个字段，可满足用户查看平台为 IOS 的当前开播直播间数或者使用开播软件版本为 8.1 的当前开播直播间数。如果后续业务场景需要多维下钻能力，可以在字段上面进行扩充。或者也可以提供明细数据在 OLAP 中进行多维下钻。 2.怎样建设？对于当前分钟正在开播直播间数来说，其计算方式很简单，就是下面这个数学公式： 当前分钟正在开播直播间数 = 上一分钟正在开播直播间数 + 当前分钟开播直播间数 - 当前分钟关播直播间数 可以从上面的公式可以看出，对于当前分钟正在开播直播间数的计算来说，是依赖上下文信息的，即上一分钟正在开播直播间数，这也就是我们所说的状态。 指标处理逻辑从获取到数据源，到产出指标的整体处理逻辑如下图所示。这里就不进行赘述了。 其中标为粉色的模块为任务中的状态，即任务中一直存储的当前分钟正在开播直播间数。 状态上述指标涉及到了，状态，那么我这里讲一下我对状态的理解。如有错误，请在文末讨论中进行指出，我会和大家讨论。 状态其实就是一个记录上下文信息的东西，如果当前的计算过程依赖到上次计算的结果，那么上次计算的结果就是状态。举几个🌰； 流处理：如本节介绍的当前分钟正在开播直播间数的计算，就是依赖上一分钟的正在开播直播间数（状态）进行的计算。可能有小伙伴会说，我不依赖上一分钟，我从头开始计算可以不？答案是可以的，但是从头开始计算，也需要将所有历史数据进行存储，这些历史数据其实也就是状态，只不过我们将其优化为了上一分钟开播直播间数。 批处理：今天的全量表 = 昨天全量表（状态） + 今天的增量表。 数据库存储：最常见的 mysql 主键自增，unique key 等。为什么新插入一条数据主键会自增？因为 mysql 存储了主键的上一个值（状态）。为什么插入相同数据时，由于 unique key 会导致报错，就是因为 mysql 存储了所有 unique key 的字段的数据（状态）。 生活：当前的手机电量 = 上一分钟的手机电量（状态） + （充电/用电量）。为什么你越来越喜欢你的另一半？因为你对她的感觉 = 前一秒你对她的感觉（状态） + 当前这一秒她亲了你一下。 生活中随处可见状态，即使你不是程序员，我相信也都可以理解状态的概念。 指标计算代码示例按照最简单的实现方式举例如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class LiveStreamRealtimeMetricProdProcessorJob &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); DataStream&lt;SourceModel&gt; source = SourceFactory.getSourceDataStream(...); DataStream&lt;SinkModel&gt; result = source .keyBy(new KeySelector&lt;SourceModel, Long&gt;() &#123; @Override public Long getKey(SourceModel commonModel) throws Exception &#123; return commonModel.getLiveStreamId() % 1000; &#125; &#125;) .timeWindow(Time.seconds(60)) .process(new ProcessWindowFunction&lt;SourceModel, SinkModel, Long, TimeWindow&gt;() &#123; private ValueState&lt;Long&gt; playingLiveStreamNumberValueState; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.playingLiveStreamNumberValueState = getRuntimeContext().getState(...); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;SourceModel&gt; iterable, Collector&lt;SinkModel&gt; collector) throws Exception &#123; Long playingLiveStreamNumber = this.playingLiveStreamNumberValueState.value(); if (null == playingLiveStreamNumber) &#123; playingLiveStreamNumber = 0L; &#125; List&lt;SourceModel&gt; sourceModels = (List&lt;SourceModel&gt;) iterable; for (SourceModel sourceModel : sourceModels) &#123; if (BizType.I == sourceModel.getBizType()) &#123; playingLiveStreamNumber++; &#125; else &#123; playingLiveStreamNumber--; &#125; &#125; this.playingLiveStreamNumberValueState.update(playingLiveStreamNumber); collector.collect( SinkModel.builder().build() ); &#125; &#125;); SinkFactory.setSinkDataStream(...); env.execute(); &#125; @Data @Builder static class SourceModel &#123; // 直播间id private Long liveStreamId; // 开播时间，关播时间 private Long time; // 主播id private Long authorId; // binlog 时间戳 private long binlogTimestamp; // 开播，关播 private BizType bizType; &#125; enum BizType &#123; I, // 开播 D, // 关播 ; &#125; @Data @Builder static class SinkModel &#123; // 时间戳，汇总到分钟粒度 private Long timestamp; // 指标名 private String metricName; // 指标值 private double metricValue; // 维度名 private String dimName; // 维度值 private String dimValue; &#125;&#125; 总结本文衔接上文，主要介绍直播间生产侧指标的建设，以当前分钟正在开播直播间数为代表举例。提出定义以及建设过程相关的问题，以这两个个问题出发，引出了以下两小节。 第一节简单介绍了当前分钟正在开播直播间数的定义。 第二节主要介绍了当前分钟正在开播直播间数的建设逻辑以及过程，并对状态这个概念进行了一个拓展介绍。 最后一节对本文进行了总结。 如果你也有相同的指标建设需求，或者存在一些指标建设过程中的问题，欢迎关注博主公众号，或者添加博主微信，互相交流~ 记得点赞 + 再看喔~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | Flink + 直播（二）| 如何建设实时公共画像维表？","date":"2020-11-02T06:21:53.000Z","path":"2020/11/02/wechat-blog/apache-flink:realtime-live-stream-2/","text":"生产实践 | Flink + 直播（二）| 如何建设实时公共画像维表？ 本系列每篇文章都是从一些实际生产实践需求出发，解决一些生产实践中的问题，抛砖引玉，以帮助小伙伴们解决一些实际生产问题。本篇文章主要介绍直播间画像实时维表建设的整个过程，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 技术架构回顾上一节的技术架构图。 整个架构相对来说是比较好理解的。从数据源到数据处理以及最后到数据汇部分。 但是大家的疑惑点可能就集中在三个维表的建设上，包含主播用户画像维表，观众用户画像维表，直播间画像维表。 我们依然从以下几个角度的问题出发，通过分析场景，解答这几个问题来给大家介绍以上三个维表的建设过程。 Question WHAT：直播实时公共画像维表是指什么？离线公共画像维表又指什么？区别？ WHY：为什么架构图中的三类公共画像维表要按照实时和离线进行划分？为什么需要建设实时公共画像维表，离线公共画像维表不能满足需求？ HOW：怎样才能建设满足直播实时数据的实时公共画像维表？ WHO：需要使用什么样的组件建设直播实时公共画像维表？为什么选用这些组件进行建设？ WHAT：实时 &amp; 离线公共画像维表？概念首先简单介绍下，实时 &amp; 离线公共画像维表中存储的内容就是实体的固有属性（比如用户的年龄等），我理解这两个词本身是高层抽象的概念，本文中介绍的主播用户画像维表，观众用户画像维表，直播间画像维表是其具体实现。 其他大佬的文章解释中会对实时公共画像维表 &amp; 离线公共画像维表有更加深度的理解，这里我只说明我在直播实时数据建设过程中的理解~ 区别其实这两个词的区别从名字上就可以区分出来，实时公共画像维表和离线公共画像维表的最大区别就是数据建设和应用场景要求的时效性不同。 离线公共画像维表特点： 场景：适合离线场景，时效性要求比较弱的场景，为指标提供画像维度填充或者打标服务 建设：一般都是以离线 t + 1 的方式进行建设 应用：使用的数据为离线 t + 1 的数据 举例：数据仓库中的用户画像维表，为应用层数据提供画像服务；比如不但需要统计总 uv，还需要统计分年龄段的 uv。 实时公共画像维表特点： 场景：适合实时场景，时效性要求比较强的场景，为指标提供画像维度填充或者打标服务 建设：实时的进行建设，延迟一般在秒级别 应用：使用的数据都是实时建设好的，必须可以实时获取（秒级别延迟后获取到）并使用 WHY：为什么建设实时公共画像维表？为什么架构图中的三类公共画像维表要按照实时和离线进行划分？为什么需要建设实时公共画像维表，离线公共画像维表不能满足需求？ 这几个问题其实围绕着我们的直播实时数据建设以及应用的场景就可以展开解答。 接上篇技术架构图，其中直播实时数据需要建设的公共维表分为以下三类： 直播间画像维表：包含直播对应的直播类别、开播客户端、标题、开播地址等信息 主播画像维表：主播对应的主播名、主播类别、性别、年龄段等 观众画像维表：观众对应的观众性别、年龄段等 直播间画像维表首先抛出结论：直播间画像都是直播间的固有属性画像，直播间画像维表的建设过程是实时的。 由于大多数直播的时长都在几小时不等，随着直播的开始，主播域观众的互动也随即产生，从而直播生产和消费的指标也开始产出，随着直播的结束，主播和观众的互动也就结束了，对应的直播生产和消费指标也就不存在了，因此直播间画像的所能提供给其他指标作为维表的价值也就快速消失了，所以直播间画像（标题，开播地址）的应用场景特点就是时效性很强。因此直播间画像维表对于直播生产消费指标的建设和应用来说，需要满足可实时建设、可实时查询获取的要求。 主播 &amp; 观众用户画像维表结论：这类画像都是用户的固有属性画像，而非直播间固有属性，和直播间是非强相关的。主播 &amp; 观众用户画像维表的建设过程可以是离线的。 无论直播间的开播关播，直播过程中的生产消费，主播画像和观众画像基本上不会产生变动。（举例：大多数情况下，当已经判定一个用户的年龄段画像为 18 - 23 时，即使这个用户开了 10 场直播，或者这个用户观看了 10 场直播，其年龄段判定也基本不会有变化）。因此主播用户画像维表 &amp; 观众用户画像维表对于直播生产消费指标的建设和应用来说，可以满足离线 t + 1 建设，提供数据服务进行实时获取的要求。 Notes： 主播 &amp; 观众用户画像需要根据用户生产消费行为以及其他信息，使用到机器学习进行性别和年龄段等的用户画像信息判定产出。也有非常多的场景将这类画像进行实时建设，用于实时个性化推荐等。只不过本文的直播实时数据建设对于这两类画像的时效性要求较弱，所以采用了离线的方式进行建设。 HOW + WHO：怎样建设？用什么建设？直播间生命周期 &amp; 数据流转直播间整个生命周期如图所示。 1.主播创建直播间，直播间进入开播的状态； 2.观众进入直播间后，在直播间内与主播进行互动； 3.最后就是主播对直播间进行关播，标识着直播间生命周期的结束状态。 直播间画像维表-实时实时画像维表的建设。上图中红色的字体为实时画像维表的建设和应用过程。 直播间画像实时数据流转 1.当主播开播，直播间进行直播后，直播间产生了直播间画像信息，这时可以将画像信息实时的建设到直播间画像实时维表中。并且可以同时建设生产侧的实时指标，利用建设好的直播间画像实时维表 + 主播 &amp; 观众画像离线维表进行生产侧指标的维度填充； 2.当观众进入直播间后，与主播进行互动，产生一系列的消费行为，随即可以建设消费侧的实时指标，利用建设的直播间画像实时维表 + 主播 &amp; 观众画像离线维表进行消费侧指标的维度填充； 3.当主播对直播间进行关播的时候，从直播间画像实时维表中就可以对该直播间的画像进行删除。 组件选型通过上文的分析，可以了解到直播间画像实时维表建设的要求如下： 实时画像：首先需要支持实时建设，实时访问； 实时画像：建设的数据都为实时指标，即要求低延迟的请求响应时间； 公共画像：需要支撑多个大流量生产消费实时任务的访问请求，即提供高 QPS 画像数据服务； 公共画像：高稳定性。 因此组件选型就自然落在了高速缓存的范畴中，我们最后经过方案对比之后，选择了 redis 作为我们的实时维表的存储引擎。 使用了 redis 中的 hash 作为维表存储结构，其中直播间画像维度存储设计如下图。 flink 实时维表建设代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LiveStreamRealtimeDimBuilderJob &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); DataStream&lt;byte[]&gt; source = SourceFactory.getSourceDataStream(); source.process(new ProcessFunction&lt;byte[], String&gt;() &#123; @Override public void processElement(byte[] bytes, Context context, Collector&lt;String&gt; collector) throws Exception &#123; CommonModel c = CommonModel.parseFrom(bytes); // 开播 if (c.isStartLiveStream()) &#123; RedisConfig .get() .hmset(c.getLiveStreamId() , ImmutableMap.&lt;String, String&gt;builder() .put(&quot;type&quot;, c.getType()) .put(&quot;client&quot;, c.getClient()) .put(&quot;title&quot;, c.getTitle()) .put(&quot;address&quot;, c.getAddress()) .build() ); RedisConfig .get() .expire(c.getLiveStreamId(), 30 * 24 * 60 * 60); &#125; else if (c.isEndLiveStream()) &#123; // 关播 RedisConfig .get() .expire(c.getLiveStreamId(), 2 * 24 * 60 * 60); &#125; &#125; &#125;); env.execute(); &#125; @Data public static class CommonModel &#123; private String liveStreamId; // 直播间 id private String type; // 直播间类型 private String client; // 开播客户端 private String title; // 直播间标题 private String address; // 直播间开播地址 public static CommonModel parseFrom(byte[] bytes) &#123; // 逻辑根据业务逻辑判定 return null; &#125; public boolean isStartLiveStream() &#123; // 逻辑根据业务逻辑判定 return false; &#125; public boolean isEndLiveStream() &#123; // 逻辑根据业务逻辑判定 return false; &#125; &#125;&#125; 主播 &amp; 观众用户画像维表-离线离线画像维表的建设。主要包含主播和观众的用户画像，性别，年龄等信息。如下图蓝色的字体为离线画像维表的应用过程。 主播 &amp; 观众画像数据流转在产出直播间生产侧、消费侧实时数据时，使用主播 &amp; 观众画像进行了画像维度填充。 存储组件其中离线画像维表的存储组件选型与实时相同，同为 redis，画像信息存储方式也是使用 redis hash 结构进行存储。 以 t + 1 的方式进行画像数据建设并进行数据同步，将建设好的全量主播和观众用户画像同步到 redis 高速缓存当中。 总结本文衔接上文，主要介绍直播间实时维表的建设过程。提出几个建设的问题，以这几个问题出发，引出了一下三小节。 第一节简单介绍了实时 &amp; 离线公共画像维表的概念。 第二节从数据应用场景的角度出发，介绍了为什么需要建设实时的公共画像维表。 第三节主要介绍了实时画像维表的建设过程以及详细的技术方案。 最后一节对本文进行了总结。 如果你也建设过实时画像维表，或者有相同的需求，欢迎留言或者留下你的文章链接，相互交流~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | 基于 Flink 的直播实时数据建设 （一）| 需求和架构篇","date":"2020-10-12T06:21:53.000Z","path":"2020/10/12/wechat-blog/apache-flink:realtime-live-stream-1/","text":"生产实践 | 基于 Flink 的直播实时数据建设 （一）| 需求和架构篇 本系列每篇文章都是从一些实际生产实践需求出发，解决一些生产实践中的问题，抛砖引玉，以帮助小伙伴们解决一些实际生产问题。相信大家或多或少都观看过直播，那大家有没有想过，如果自己负责建设公司内整体直播实时数据，会怎样去建设呢？本系列文章主要介绍直播实时数据建设的整个过程，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 首先思考几个问题 WHAT：相信大家或多或少都观看过直播，甚至自己就是一名主播或负责的业务就是直播相关的，那大家有没有思考过，在直播业务场景中，你最关心什么指标以及需要关注、建设什么数据？ WHY：为什么需要建设直播实时数据？离线建设不能满足吗？ HOW：直播实时数据怎样赋能业务的？怎样根据公司直播场景的需求去划分直播实时数据？怎样去建设直播实时数据体？ WHO：在建设直播实时数据的过程中，需要使用什么样的组件进行建设？每个组件都负责哪一部分？ 让我们带着以上几个问题出发~ 直播 + 短视频，内容运营的下一个战场随着互联网络技术的发展，网络直播受到越来越多人的关注，直播在经过几年前的喷涌式大爆发之后，近段时间热度有所降低。内容的同质化和变现困难是直播现在面临的主要问题，随着移动终端普及和网络的提速，短视频以短平快的大流量传播方式快速获得各大平台、粉丝和资本的青睐，所以众多直播软件开始接入短视频的功能。同时，一些以短视频为主发展起来的 app 也在软件中加入了直播功能，直播和短视频两者互相弥补不足，相辅相成，给用户带来了更好的使用体验，也给各大平台带来更多的流量，”直播 + 短视频”的模式已经也成为新的发展趋势。 本系列文章主要围绕着直播实时数据建设而展开。本文是本系列文章的的第一篇，需求和架构篇，主要分为三个部分，按顺序为WHY - WHAT - HOW，以这三个角度出发，解答开头提出的三个问题，其中 WHO部分在本系列文章的后续建设细节章节进行介绍！ WHY：为什么建设直播实时数据？相比短视频的生产消费来说，直播的主播和观看直播的观众的纽带都是在直播间建立的，相互之间的互动行为也都只在直播间内产生，并且通常情况下，一场直播的时长也就在几个小时之内，因此直播的生产消费时效性相比短视频会更强，因而直播数据对于实时性的诉求也就更高。 WHAT：需要关注、建设什么直播实时数据？需要关注、建设什么直播实时数据？换一句话来说就是根据数据分析业务的需求出发，决定建设什么样的直播实时数据？ 直播就是一个主播和观众联络互动的纽带，其中一切操作都是围绕着主播和观众而展开的，数据分析的同学都会以这个最基础的角度出发进行分析，因此首先我们就可以将整个直播的数据按照直播生产和直播消费进最基本的划分。 除此角度之外，数据分析的同学也还会从全局直播业务洞察和单个直播间洞察不同粒度上进行分析洞察，因此还可以按照大盘数据、单直播间数据进行划分。 从这两个角度出发，基本可以涵盖对于直播业务分析场景的诉求，因此直播实时数据也自然可以从这两个角度进行划分和建设。 综上则整体直播实时数据业务划分和赋能应用架构如下图所示。 其中 直播大盘实时数据在宏观上监控直播业务，提供预测大盘的能力；其中分钟粒度时间序列可快速定位直播各行为的高峰时刻，可以基于该时刻进行详细归因。除此之外，当直播在做运营活动时，也能快速基于实时数据来看运营活动的活动效果，赋能活动策略实时优化。 单直播间直播实时数据可以以细粒度监控单直播间的直播业务，用来在直播过程中对外输出直播数据战报、以及可基于数据战报效果实时对单直播间进资源投放进行实时效果评估和合理调配。 详细的直播实时数据需求和样例如下文。 大盘生产侧 指标：总体开播直播间数… 维度：直播间画像、主播用户画像 举例：[开播直播间为游戏类直播]的[总开播主播数] 消费侧 指标：总体观众观看、点赞、评论数… 维度：观众用户画像、日志上报其他维度 举例：[目前在河北观看直播]的[总观众数] 单直播间生产侧单直播间一般都是一些画像信息，所以此类指标较少，暂时不做讨论。 消费侧 指标：单直播间观众观看、点赞、评论数… 维度：观众用户画像、日志上报其他维度 举例：某直播间[18-23岁年龄段]的[总观众数] 目前已经了解了要建设直播实时数据都包含了什么内容，接下来就是大干一场的时候了。 HOW：怎样去建设？怎样去建设？换一句话来说就是从技术的角度出发，怎样将直播实时数据的业务需求转化为直播实时数据的技术方案进行落地？ 从技术角度出发，上述直播实时数据需要建设的需求内容总结下来就是一个词：直播实时多维指标。 多维即产出指标是多维度的，包含公共维度和非公共维度。 第一类是公共维度。包含三部分，直播间画像，主播用户画像，观众用户画像，公共两字代表这类维度是可以被多个指标进行共享使用的。举例：某直播间开播之后，该直播间画像只需要一次建设，就可以被多个指标多次重复使用，不但可以作为大盘侧生产、消费指标的维度，也可以作为单直播间生产、消费指标的维度。 第二类是非公共维度。非公共维度是和特定消费行为绑定的，也就是和某个指标绑定的，随着日志上报一同上报的维度。举例：某观众观看直播时的客户端类型（安卓？IOS？），观看直播时的省份等维度，这类维度只和当前的消费行为相关，不能被其他指标所共享。 指标其实都是 pv，uv 类指标。简单理解就是各个维度下对应的 xx 量。 实时数据建设技术架构对应到直播实时数据建设的过程主要包含两部分：公共部分和非公共部分。 公共部分就是实时公共维表的建设。 非公共部分就是指标非公共维度以及对应生产、消费指标建设。 直接给出总体技术架构图，本系列后续的文章进行介绍这样进行整体架构设计的详细原因。 简单说明下。 其中数据源包含生产侧，消费侧数据源； 数据处理部分包含公共实时维表建设，和指标建设，其中一部分公共维表的建设也使用了离线的方式提供了支持； 最后就是数据汇部分，产出了生产侧，消费侧的多维指标供数据分析师使用。 下节预告下节主要介绍直播实时公共画像的建设，其中是技术架构图中的主播用户、关注用户画像、以及直播间画像的建设方案。 总结本文首先提出了几个关于直播实时数据建设的问题。以这几个问题触发，引出了一下三小节。 第一节简单介绍了直播时效性强的原因，因此直播对于实时数据的需求更加强烈。 第二节从数据分析的角度出发，引出了我们需要建设的直播实时数据都包含哪些内容，并且从大盘/单直播间，生产/消费角度进行了模块划分。 第三节对数据需求进行了技术方案的整体架构设计。 最后一节对本文进行了总结。 如果你也有相同的建设需求或者你以及建设了直播实时数据，欢迎留言或者留下你的文章链接，相互交流~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"前沿 | 流批一体的一些理解","date":"2020-10-12T06:21:53.000Z","path":"2020/10/12/wechat-blog/apache-flink:stream-batch-integration/","text":"前沿 | 流批一体的一些理解 每家数字化企业在目前遇到流批一体概念的时候，都会对这个概念抱有一些疑问，到底什么是流批一体？这个概念的来源？这个概念能为用户、开发人员以及企业带来什么样的好处？跟随着博主的理解和脑洞出发吧。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"前沿 | 流批一体的一些理解","date":"2020-10-12T06:21:53.000Z","path":"2020/10/12/wechat-blog/read/","text":"前沿 | 流批一体的一些理解 每家数字化企业在目前遇到流批一体概念的时候，都会对这个概念抱有一些疑问，到底什么是流批一体？这个概念的来源？这个概念能为用户、开发人员以及企业带来什么样的好处？跟随着博主的理解和脑洞出发吧。 自流程化：此前没有人正式提过这一说法，在与政府、金融客户沟通时经常会提到：当业务能够实现对象数字化、规则数字化、结果数据化时，业务自身的流程也就可以按照规则自由、自行组建和优化了。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Tips | Flink 使用 union 代替 join、cogroup","date":"2020-10-03T06:21:53.000Z","path":"2020/10/03/wechat-blog/apache-flink:realtime-tips-2-union-join/","text":"Tips | Flink 使用 union 代替 join、cogroup 本系列每篇文章都比较短小，不定期更新，从一些实际的 case 出发抛砖引玉，提高小伙伴的姿♂势水平。本文介绍在满足原有需求、实现原有逻辑的场景下，在 Flink 中使用 union 代替 cogroup(或者join) ，简化任务逻辑，提升任务性能的方法，阅读时长大概一分钟，话不多说，直接进入正文！ 需求场景分析需求场景需求诱诱诱来了。。。数据产品妹妹想要统计单个短视频粒度的点赞，播放，评论，分享，举报五类实时指标，并且汇总成 photo_id、1 分钟时间粒度的实时视频消费宽表（即宽表字段至少为：photo_id + play_cnt + like_cnt + comment_cnt + share_cnt + negative_cnt + minute_timestamp）产出至实时大屏。 问题在于对同一个视频，五类视频消费行为的触发机制以及上报时间是不同，也就决定了对实时处理来说五类行为日志对应着五个不同的数据源。sql boy 们自然就想到了 join 操作将五类消费行为日志合并，可是实时 join(cogroup) 真的那么完美咩~，下文细谈。 source 输入以及特点首先我们分析下需求中的 source 特点： photo_id 粒度 play（播放）、like（点赞）、comment（评论）、share（分享）、negative（举报）明细数据，用户播放（点赞、评论…）n 次，客户端\\服务端就会上传 n 条播放（点赞、评论…）日志至数据源 五类视频消费行为日志的 source schema 都为：photo_id + timestamp + 其他维度 sink 输出以及特点sink 特点如下： photo_id 粒度 play（播放）、like（点赞）、comment（评论）、share（分享）、negative（举报）1 分钟级别窗口聚合数据 实时视频消费宽表 sink schema 为：photo_id + play_cnt + like_cnt + comment_cnt + share_cnt + negative_cnt + minute_timestamp source、sink 样例数据source 数据：| photo_id | timestamp | user_id | 说明 || ——— | – | ———– | ———– || 1 | 2020/10/3 11:30:33 | 3 | 播放 || 1 | 2020/10/3 11:30:33 | 4 | 播放 || 1 | 2020/10/3 11:30:33 | 5 | 播放 || 1 | 2020/10/3 11:30:33 | 4 | 点赞 || 2 | 2020/10/3 11:30:33 | 5 | 点赞 || 1 | 2020/10/3 11:30:33 | 5 | 评论 | sink 数据：| photo_id | timestamp | play_cnt | like_cnt | comment_cnt| ——— | – | ———– | ———– | ———– || 1 | 2020/10/3 11:30:00 | 3 | 1 | 1 || 2 | 2020/10/3 11:30:00 | 0 | 1 | 0 | 我们已经对数据源输入和输出有了完整的分析，那就瞧瞧有什么方案可以实现上述需求吧。 实现方案 方案1：本小节 cogroup 方案直接消费原始日志数据，对五类不同的视频消费行为日志使用 cogroup 或者 join 进行窗口聚合计算 方案2：对五类不同的视频消费行为日志分别单独聚合计算出分钟粒度指标数据，下游再对聚合好的指标数据按照 photo_id 进行合并 方案3：本小节 union 方案既然数据源 schema 相同，直接对五类不同的视频消费行为日志做 union 操作，在后续的窗口函数中对五类指标进行聚合计算。后文介绍 union 方案的设计过程 我们先上 cogroup 方案的示例代码。 cogroupcogroup 实现示例如下，示例代码直接使用了处理时间（也可替换为事件时间~），因此对数据源的时间戳做了简化（直接干掉）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Cogroup &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // Long -&gt; photo_id 播放一次 DataStream&lt;Long&gt; play = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 点赞一次 DataStream&lt;Long&gt; like = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 评论一次 DataStream&lt;Long&gt; comment = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 分享一次 DataStream&lt;Long&gt; share = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 举报一次 DataStream&lt;Long&gt; negative = SourceFactory.getDataStream(xxx); // Tuple3&lt;Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt 播放和点赞的数据合并 DataStream&lt;Tuple3&lt;Long, Long, Long&gt;&gt; playAndLikeCnt = play .coGroup(like) .where(KeySelectorFactory.get(Function.identity())) .equalTo(KeySelectorFactory.get(Function.identity())) .window(TumblingProcessingTimeWindows.of(Time.seconds(60))) .apply(xxx1); // Tuple4&lt;Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt 播放、点赞、评论的数据合并 DataStream&lt;Tuple4&lt;Long, Long, Long, Long, Long&gt;&gt; playAndLikeAndComment = playAndLikeCnt .coGroup(comment) .where(KeySelectorFactory.get(playAndLikeModel -&gt; playAndLikeModel.f0)) .equalTo(KeySelectorFactory.get(Function.identity())) .window(TumblingProcessingTimeWindows.of(Time.seconds(60))) .apply(xxx2); // Tuple5&lt;Long, Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt + share_cnt 播放、点赞、评论、分享的数据合并 DataStream&lt;Tuple5&lt;Long, Long, Long, Long, Long, Long&gt;&gt; playAndLikeAndCommentAndShare = playAndLikeAndComment .coGroup(share) .where(KeySelectorFactory.get(playAndLikeAndCommentModel -&gt; playAndLikeAndCommentModel.f0)) .equalTo(KeySelectorFactory.get(Function.identity())) .window(TumblingProcessingTimeWindows.of(Time.seconds(60))) .apply(xxx2); // Tuple7&lt;Long, Long, Long, Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt + share_cnt + negative_cnt + minute_timestamp 播放、点赞、评论、分享、举报的数据合并 // 同上~ DataStream&lt;Tuple7&lt;Long, Long, Long, Long, Long, Long, Long&gt;&gt; playAndLikeAndCommentAndShare = ***; env.execute(); &#125;&#125; 粗暴一想，上面这样一搞不就结束了么，事情没那么简单，我们来做一个详细点的分析。 上述实现可能会存在的问题点 从 flink 消费到 play 数据源的一条数据到最终产出这条数据被聚合后的数据，整个过程的数据延迟 &gt; 3 分钟… 如果数据源持续增加（比如添加其他视频消费操作数据源），则整个任务算子变多，数据链路更长，任务稳定性会变差，产出数据延迟也会随着窗口计算变多，延迟更久 数据产品妹妹：🤩，小哥哥好棒，既然问题点都分析出来了，技术小哥哥就帮人家解决一下嘛~ 头文字 ∩ 技术小哥哥：搞。 头文字 ∩ 技术小哥哥：既然可能由于过多的窗口导致数据产出延迟，job 不稳定，那有没有什么方法减少窗口数量呢，思路转换一下。我们直接以整个 job 中只包含一个窗口算子操作为基点，逆推一下，则有以下数据链路。 逆推链路1 - 5 为逆推的整条链路。 1.五类指标的数据都在单个窗口中计算 2.五类指标的窗口 model 相同 3.keyby 中的 key 一致（photo_id） 4.五类指标的数据源都为 photo_id 粒度，并且五类数据源的 model 都必须相同，并且可以做合并 5.union 算子可以对五类数据源做合并！！！ 话不多说直接上 union 方案代码。 union123456789101112131415161718192021222324252627282930public class Union &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;PLAY&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; play = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;LIKE&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; like = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;COMMENT&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; comment = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;SHARE&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; share = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;NEGATIVE&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; negative = SourceFactory.getDataStream(xxx); // Tuple5&lt;Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt + window_start_timestamp DataStream&lt;Tuple3&lt;Long, Long, Long&gt;&gt; playAndLikeCnt = play .union(like) .union(comment) .union(share) .union(negative) .keyBy(KeySelectorFactory.get(i -&gt; i.f0)) .timeWindow(Time.seconds(60)) .process(xxx); env.execute(); &#125;&#125; 可以发现，无论上游数据源怎样进行变化，上述 union 方案中始终可以保持只有一个窗口算子处理和计算数据，则可以解决之前列举的数据延迟以及 flink 任务算子过多的问题。 在数据源的 schema 相同（或者不同但经过处理之后可以 format 成相同格式）的情况下，或者处理逻辑相同的话，可以使用 union 进行逻辑简化。 总结本文首先介绍了我们的需求场景，第二部分分析了使用 cogroup（案例代码）是如何解决此需求场景，再分析了此实现方案可能会存在一些问题，并引出了 union 解决方案的逆推和设计思路。在第三部分针对此场景使用 union 代替 cogroup 进行了一定程度上的优化。如果针对此场景，大佬们有更好的优化方案的话，期待留言喔。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"踩坑记 | Flink 天级别窗口中存在的时区问题","date":"2020-10-03T06:21:53.000Z","path":"2020/10/03/wechat-blog/apache-flink:realtime-tips-3-utc/","text":"踩坑记 | Flink 天级别窗口中存在的时区问题 本系列每篇文章都是从一些实际的 case 出发，分析一些生产环境中经常会遇到的问题，抛砖引玉，以帮助小伙伴们解决一些实际问题。本文介绍 Flink 时间以及时区问题，分析了在天级别的窗口时会遇到的时区问题，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 本文主要分为两部分： 第一部分（第 1 - 3 节）的分析主要针对 flink，分析了 flink 天级别窗口的中存在的时区问题以及解决方案。 第二部分（第 4 节）的分析可以作为所有时区问题的分析思路，主要以解决方案中的时区偏移量为什么是加 8 小时为案例做了通用的深度解析。 为了让读者能对本文探讨的问题有一个大致了解，本文先给出问题 sql，以及解决方案。后文给出详细的分析~ 1.问题以及解决方案问题 sqlsql 很简单，用来统计当天累计 uv。 12345678910111213141516171819--------------- 伪代码 ---------------INSERT INTO kafka_sink_tableSELECT -- 窗口开始时间 CAST( TUMBLE_START(proctime, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, -- 当前记录处理的时间 cast(max(proctime) AS BIGINT) AS current_ts, -- 每个桶内的 uv count(DISTINCT id) AS part_daily_full_uvFROM kafka_source_tableGROUP BY mod(id, bucket_number), -- bucket_number 为常数，根据具体场景指定具体数值 TUMBLE(proctime, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 你是否能一眼看出这个 sql 所存在的问题？（PS：数据源以及数据汇时区都为东八区） 没错，天级别窗口所存在的时区问题，即这段代码统计的不是楼主所在东八区一整天数据的 uv，这段代码统计的一整天的范围在东八区是第一天早 8 点至第二天早 8 点。 解决方案楼主目前所处时区为东八区，解决方案如下： 12345678910111213141516171819202122232425--------------- 伪代码 ---------------CREATE VIEW view_table ASSELECT id, -- 通过注入时间解决 -- 加上东八区的时间偏移量，设置注入时间为时间戳列 CAST(CURRENT_TIMESTAMP AS BIGINT) * 1000 + 8 * 60 * 60 * 1000 as ingest_timeFROM source_table;INSERT INTO target_tableSELECT CAST( TUMBLE_START(ingest_time, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, cast(max(ingest_time) AS BIGINT) - 8 * 3600 * 1000 AS current_ts, count(DISTINCT id) AS part_daily_full_uvFROM view_tableGROUP BY mod(id, 1024), -- 根据注入时间划分天级别窗口 TUMBLE(ingest_time, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 通过上述方案，就可以将统计的数据时间范围调整为东八区的今日 0 点至明日 0 点。下文详细说明整个需求场景以及解决方案的实现和分析过程。 2.需求场景以及实现方案需求场景coming，需求场景比较简单，就是消费上游的一个埋点日志数据源，根据埋点中的 id 统计当天 0 点至当前时刻的累计 uv，按照分钟级别产出到下游 OLAP 引擎中进行简单的聚合，最后在 BI 看板进行展示，没有任何维度字段（感动到哭😭）。 数据链路以及组件选型客户端用户行为埋点日志 -&gt; logServer -&gt; kafka -&gt; flink（sql） -&gt; kafka -&gt; druid -&gt; BI 看板。 实现方案以及具体的实现方式很多，这次使用的是 sql API。 flink sql schemasource 和 sink 表 schema 如下（只保留关键字段）： 12345678910111213141516171819202122--------------- 伪代码 ---------------CREATE TABLE kafka_sink_table ( -- 天级别窗口开始时间 window_start BIGINT, -- 当前记录处理的时间 current_ts BIGINT, -- 每个桶内的 uv（处理过程对 id 进行了分桶） part_daily_full_uv BIGINT) WITH ( -- ... );CREATE TABLE kafka_source_table ( -- ... -- 需要进行 uv 计算的 id id BIGINT, -- 处理时间 proctime AS PROCTIME()) WITH ( -- ... );--------------- 伪代码 --------------- flink sql transform12345678910111213141516171819--------------- 伪代码 ---------------INSERT INTO kafka_sink_tableSELECT -- 窗口开始时间 CAST( TUMBLE_START(proctime, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, -- 当前记录处理的时间 cast(max(proctime) AS BIGINT) AS current_ts, -- 每个桶内的 uv count(DISTINCT id) AS part_daily_full_uvFROM kafka_source_tableGROUP BY mod(id, bucket_number), -- bucket_number 为常数，根据具体场景指定具体数值 TUMBLE(proctime, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 使用 early-fire 机制（同 DataStream API 中的 ContinuousProcessingTimeTrigger），并设定触发间隔为 60 s。 在上述实现 sql 中，我们对 id 进行了分桶，那么每分钟输出的数据条数即为 bucket_number 条，最终在 druid 中按照分钟粒度将所有桶的数据进行 sum 聚合，即可得到从当天 0 点累计到当前分钟的全量 uv。 时区问题 激情场景还原： 头文字 ∩ 技术小哥哥：使用 sql，easy game，闲坐摸鱼… 头文字 ∩ 技术小哥哥：等到 00:00 时，发现指标还在不停地往上涨，难道是 sql 逻辑错了，不应该啊，试过分钟，小时级别窗口都木有这个问题 头文字 ∩ 技术小哥哥：抠头ing，算了，稍后再分析这个问题吧，现在还有正事要干😏 头文字 ∩ 技术小哥哥：到了早上，瞅了一眼配置的时间序列报表，发现在 08:00 点的时候指标归零，重新开始累计。想法一闪而过，东八区？（当时为啥没 format 下 sink 数据中的 window_start…） 3.问题定位问题说明flink 在使用时间的这个概念的时候是基于 java 时间纪元（即格林威治 1970/01/01 00:00:00，也即 Unix 时间戳为 0）概念的，窗口对齐以及触发也是基于 java 时间纪元。 问题场景复现可以通过直接查看 sink 数据的 window_start 得出上述结论。 但为了还原整个过程，我们按照如下 source 和 sink 数据进行整个问题的复现： source 数据如下：| id | proctime | proctime UTC + 0（格林威治） 格式化时间 | proctime UTC + 8（北京） 格式化时间| ——— | – | – | – || 1 | 1599091140000 | 2020/09/02 23:59:00 | 2020/09/03 07:59:00 || 2 | 1599091140000 | 2020/09/02 23:59:00 | 2020/09/03 07:59:00 || 3 | 1599091140000 | 2020/09/02 23:59:00 | 2020/09/03 07:59:00 || 1 | 1599091200000 | 2020/09/03 00:00:00 | 2020/09/03 08:00:00 || 2 | 1599091200000 | 2020/09/03 00:00:00 | 2020/09/03 08:00:00 || 3 | 1599091260000 | 2020/09/03 00:01:00 | 2020/09/03 08:01:00 | sink 数据（为了方便理解，直接按照 druid 聚合之后的数据展示）：| window_start | current_ts | part_daily_full_uv | window_start UTC + 8（北京） 格式化时间 | current_ts UTC + 8（北京） 格式化时间| ——— | – | ———– | ———– | ———– || 1599004800000 | 1599091140000 | 3 | 2020/09/02 08:00:00 | 2020/09/03 07:59:00 || 1599091200000 | 1599091200000 | 2 | 2020/09/03 08:00:00 | 2020/09/03 08:00:00 || 1599091200000 | 1599091260000 | 3 | 2020/09/03 08:00:00 | 2020/09/03 08:01:00 | 从上述数据可以发现，天级别窗口开始时间在 UTC + 8（北京）的时区是每天早上 8 点，即 UTC + 0（格林威治）的凌晨 0 点。 下文先给出解决方案，然后详细解析各个时间以及时区概念~ 解决方案 框架层面解决：Blink Planner 支持时区设置 sql层面解决：从 sql 实现层面给出解决方案 sql 层面解决方案12345678910111213141516171819202122232425--------------- 伪代码 ---------------CREATE VIEW view_table ASSELECT id, -- 通过注入时间解决 -- 加上东八区的时间偏移量，设置注入时间为时间戳列 CAST(CURRENT_TIMESTAMP AS BIGINT) * 1000 + 8 * 60 * 60 * 1000 as ingest_timeFROM source_table;INSERT INTO target_tableSELECT CAST( TUMBLE_START(ingest_time, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, cast(max(ingest_time) AS BIGINT) - 8 * 3600 * 1000 AS current_ts, count(DISTINCT id) AS part_daily_full_uvFROM view_tableGROUP BY mod(id, 1024), -- 根据注入时间划分天级别窗口 TUMBLE(ingest_time, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 我目前所属的时区是东八区（北京时间），通过上述 sql，设置注入时间，并对注入时间加上 8 小时的偏移量进行天级别窗口的划分，就可以对此问题进行解决（也可以在 create table 时，在 schema 中根据计算列添加对应的注入时间戳进行解决）。如果你在 sql 层面有更好的解决方案，欢迎讨论~ Notes： 东 n 区的解决方案就是时间戳 +n * 3600 秒的偏移量，西 n 区的解决方案就是时间戳 -n * 3600 秒的偏移量 DataStream API 存在相同的天级别窗口时区问题 这里提出一个问题，为什么东八区是需要在时间戳上加 8 小时偏移量进行天级别窗口计算，而不是减 8 小时或是加上 32（24 + 8） 小时，小伙伴们有详细分析过嘛~ 根据上述问题，引出本文的第二大部分，即深度解析时区偏移量问题，这部分可以作为所有时区问题的分析思路。 4.为什么东八区是加 8 小时？时间和时区基本概念时区：由于世界各国家与地区经度不同，地方时也有所不同，因此会划分为不同的时区。 Unix 时间戳(Unix timestamp)： Unix 时间戳(Unix timestamp)，或称 Unix 时间(Unix time)、POSIX 时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒（UTC/GMT的午夜）起至现在的总秒数。Unix 时间戳不仅被使用在 Unix 系统、类 Unix 系统中，也在许多其他操作系统中被广泛采用。 GMT：Greenwich Mean Time 格林威治标准时间。这是以英国格林威治天文台观测结果得出的时间，这是英国格林威治当地时间，这个地方的当地时间过去被当成世界标准的时间。 UT：Universal Time 世界时。根据原子钟计算出来的时间。 UTC：Coordinated Universal Time 协调世界时。因为地球自转越来越慢，每年都会比前一年多出零点几秒，每隔几年协调世界时组织都会给世界时 +1 秒，让基于原子钟的世界时和基于天文学（人类感知）的格林威治标准时间相差不至于太大。并将得到的时间称为 UTC，这是现在使用的世界标准时间。协调世界时不与任何地区位置相关，也不代表此刻某地的时间，所以在说明某地时间时要加上时区也就是说 GMT 并不等于 UTC，而是等于 UTC + 0，只是格林威治刚好在 0 时区上。 白话时间和时区当时看完这一系列的时间以及时区说明之后我大脑其实是一片空白。…ojbk…，我用自己现在的一些理解，尝试将上述所有涉及到时间的概念解释一下。 GMT：格林威治标准时间。 UTC：基于原子钟协调之后的世界标准时间。可以认为 UTC 时间和格林威治标准时间一致。即 GMT = UTC + 0，其中 0 代表格林威治为 0 时区。 时区：逆向思维来解释下（只从技术层面解释，不从其他复杂层面解释），没有时区划分代表着全世界都是同一时区，那么同一时刻看到的外显时间是一样的。举个🌰：假如全世界都按照格林威治时间作为统一时间，在格林威治时间 0 点时，对于北京和加拿大的两个同学来说，这两个同学感知到的是北京是太阳刚刚升起（清晨），加拿大是太阳刚刚落下（傍晚）。但是由于没有时区划分，这两个同学看到的时间都是 0 点，因此这是不符合人类对感知到的时间和自己看到的时间的理解的。所以划分时区之后，可以满足北京（东八区 UTC + 8）同学看到的时间是上午 8 点，加拿大（西四区 UTC - 4）同学看到的时间是下午 8 点。注意时区的划分是和 UTC 绑定的。东八区即 UTC + 8。 flink 时间：flink 使用的时间基于 java 时间纪元（GMT 1970/01/01 00:00:00，UTC + 0 1970/01/01 00:00:00）。 Unix 时间戳：世界上任何一个地方，同时接收到的数据的对应的 Unix 时间戳都是相同的，类似时区中我们举的不分时区的🌰，全世界同一时刻的 Unix 时间戳一致。 Unix 时间戳为 0：对应的格林威治时间：1970-01-01 00:00:00，对应的北京时间（东八区）：1970-01-01 08:00:00** 概念关系如图所示： 为什么东八区是加 8 小时？下述表格只对一些重要的时间进行了标注： Unix 时间戳 格林威治时间（外显） 北京时间（外显） -8 * 3600 - 1970/01/01 00:00:00 0 1970/01/01 00:00:00 1970/01/01 08:00:00 16 * 3600 - 1970/01/02 00:00:00 24 * 3600 1970/01/02 00:00:00 - 拿第一条数据解释下，其代表在北京时间 1970/01/01 00:00:00 时，生成的一条数据所携带的 Unix 时间戳为 -8 * 3600。 根据需求和上图和上述表格内容，我们可以得到如下推导过程： 需求场景是统计一个整天的 uv，即天级别窗口，比如统计北京时间 1970/01/01 00:00:00 - 1970/01/02 00:00:00 范围的数据时，这个日期范围内的数据所携带的 Unix 时间戳范围为 -8 * 3600 到 16 * 3600 对于 flink 来说，默认情况下它所能统计的一个整天的 Unix 时间戳的范围是 0 到 24 * 3600 所以当我们想通过 flink 实现正确统计北京时间（1970/01/01 00:00:00 - 1970/01/02 00:00:00）范围内的数据时，即统计 Unix 时间戳为 -8 * 3600 到 16 * 3600 的数据时，就需要对时间戳做个映射。 映射方法如下，就是将整体范围内的时间戳做在时间轴上做平移映射，就是把 -8 * 3600 映射到 0，16 * 3600 映射到 24 * 3600。相当于是对北京时间的 Unix 时间戳整体加 8 * 3600。 最后在产出的时间戳上把加上的 8 小时再减掉（因为外显时间会自动按照时区对 Unix 时间戳进行格式化）。 Notes： 可以加 32 小时吗？答案是可以。在东八区，对于天级别窗口的划分，加 8 小时和加 8 + n * 24（其中 n 为整数）小时后进行的天级别窗口划分和计算的效果是一样的，flink 都会将东八区的整一天内的数据划分到一个天级别窗口内。所以加 32（8 + 24），56（8 + 48），-16（8 - 24）小时效果都相同，上述例子只是选择了时间轴平移最小的距离，即 8 小时。注意某些系统的 Unix 时间戳为负值时会出现异常。 此推理过程适用于所有遇到时区问题的场景，如果你也有其他应用场景有这个问题，也可以按照上述方式解决 Appendix求输入 Unix 时间戳对应的东八区每天 0 点的 Unix 时间戳。 12345public static final long ONE_DAY_MILLS = 24 * 60 * 60 * 1000L;public static long transform(long timestamp) &#123; return timestamp - (timestamp + 8 * 60 * 60 * 1000) % ONE_DAY_MILLS;&#125; 5.总结本文首先介绍了直接给出了我们的问题 sql 和解决方案。 第二节从需求场景以及整个数据链路的实现方案出发，解释了我们怎样使用 flink sql 进行了需求实现，并进而引出了 sql 中天级别窗口存在的时区问题。 第三节确认了天级别窗口时区问题原因，引出了 flink 使用了 java 时间纪元，并针对此问题给出了引擎层面和 sql 层面的解决方案。也进而提出了一个问题：为什么我们的解决方案是加 8 小时偏移量？ 第四节针对加 8 小时偏移量的原因进行了分析，并详细阐述了时区，UTC，GMT，Unix 时间戳之间的关系。 最后一节对本文进行了总结。 如果你有更方便的时区偏移量理解方式，欢迎留言~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Tips | Flink sink schema 字段设计小技巧","date":"2020-09-12T06:21:53.000Z","path":"2020/09/12/wechat-blog/apache-flink:realtime-tips-1/","text":"Tips | Flink sink schema 字段设计小技巧 本系列每篇文章都比较短小，不定期更新，从一些实际的 case 出发抛砖引玉，提高小伙伴的姿♂势水平。本文介绍 Flink sink schema 字段设计小技巧，阅读时长大概 2 分钟，话不多说，直接进入正文！ sink schema 中添加 version 版本字段如 title，直接上实践案例和使用方式。 实践案例及使用方式 非故障场景下产出的每条记录的 version 字段值为 1 故障场景下，可以在同一 sink 中产出 version &gt; 1（非 1）的数据，代表故障修复数据提供给下游消费 可应对的故障场景上游 flink 任务 A 发生故障导致产出脏数据至 kafka X，并且下游消费方可以按照下面两类进行划分： 下游为 flink 任务：flink 任务 B 消费 kafka X 中的脏数据，结果计算并产出错误数据 下游为 OLAP 引擎以及 BI 看板：结果导致看板展示数据异常 首先介绍下避免以及处理上述问题的整体思路： 1.优化逻辑，保障上游任务稳定性：首先通过一些优化手段，尽可能保证上游 flink 任务 A 不出现故障 2.配置作业监控报警：针对整条链路配置对应的监控报警等，以及时发现和定位问题 3.制定故障处理、修复预案：需要制定对应的故障处理、修复预案，一旦出现故障，需要有可处理故障的能力 4.下游针对数据源特性改进消费和处理方式：保障即使消费了脏数据也不会对业务逻辑产生影响 下文主要介绍第 2 点，出现上述故障时修复的方案，针对以上场景，目前有如下 3 种可选方案修复数据： 方案 1 - 离线方式修复：通过离线方式产出修复数据，对脏数据进行覆盖操作。缺点是故障修复延迟较高，需要切换离线、实时数据源，人工操作成本较高 方案 2 - 实时方式修复：重跑修数逻辑，产出修复数据至 kafka X-fix，下游 flink 任务 B 重新从 kafka X-fix 中的指定 offset 开始消费，计算并产出正确的数据。此方案对下游 flink 任务 B 来说，需要改动代码逻辑，存在修数 topic 和原 topic 切换逻辑，修复逻辑较为复杂 方案 3 - 实时方式修复（本小节 version 字段方案）：为避免下游产生数据源切换操作带来的高成本操作，可在原有 kafka topic 中产出修复数据，通过 version 字段区分正常产出数据以及修复数据，相对方案 1 和 2 的优点在于，不存在数据源切换逻辑，下游通过控制 version 字段值就可消费到对应的修复数据，明显降低人工操作成本，且修复逻辑相对简单 Note: 方案 3 需要对 Kafka X 预留一定的 buffer，否则在产出修复数据时，由于写入或读出 Kafka X 的 QPS 过高，会影响正常产出数据的任务。 sink schema 中添加时间戳字段实践案例及使用方式有窗口场景中，sink schema 中可添加以下字段： flink_process_start_time(long)：代表 flink 窗口开始逻辑处理的时间戳 flink_process_end_time(long)：代表 flink 窗口结束逻辑处理的时间戳 window_start(long)：代表 flink 窗口开始时间戳 window_end(long)：代表 flink 窗口结束时间戳 生产实践案例 flink_process_start_time，flink_process_end_time 在开发、测试、验数阶段可帮助用户定位数据偏差原因 window_start，window_end 可以帮助用户定位每个窗口处理是否有丢数，及每个窗口处理的具体数据 总结本文主要介绍了在 sink schema 中添加 version（版本），时间戳扩展字段的小技巧，以帮助用户在生产环境中提升实时数据故障修复效率以及可用性。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Tips | flink watermark 一定只能用时间戳衡量？？？","date":"2020-09-12T06:21:53.000Z","path":"2020/09/12/wechat-blog/apache-flink:realtime-tips-4-watermark/","text":"本系列每篇文章都比较短小，不定期更新，从一些实际的 case 出发抛砖引玉，提高小伙伴的姿♂势水平。本文从另一种角度介绍 flink 的 watermark，阅读时长大概 2 分钟，话不多说，直接进入正文！ 关于 watermarkNicki是某一线互联网大厂的数据开发， 最近由于公司业务的发展，以及业务对数据实时性要求变高，Nicki 开始使用 flink 进行实时数据开发， 今天Nicki 在使用 flink datastream api 进行开发，当她写万 watermark 分配器之后，突然有了一个疑问，watermark 的分配只能使用时间戳吗？ 带着这个疑问Nicki 找到了 lsp 数据羊。 结论时间戳作为 watermark 的原因时间戳是我们最常用的标识以及分析方式 但是可以作为 watermark 的不止时间戳","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"踩坑记 | Flink 事件时间语义下数据乱序丢数踩坑","date":"2020-09-11T06:21:53.000Z","path":"2020/09/11/wechat-blog/apache-flink:realtime-out-of-order/","text":"踩坑记 | Flink 事件时间语义下数据乱序丢数踩坑 本文详细介绍了在上游使用处理时间语义的 flink 任务出现故障后，重启消费大量积压在上游的数据并产出至下游数据乱序特别严重时，下游 flink 任务使用事件时间语义时遇到的大量丢数问题以及相关的解决方案。 本文分为以下几个部分： 1.本次踩坑的应用场景 2.应用场景中发生的丢数故障分析 3.待修复的故障点 4.丢数故障解决方案及原理 5.总结 应用场景应用场景如下： flink 任务 A 以处理时间语义做过滤产出新增 xx 明细数据至 Kafka Y flink 任务 B 以事件时间语义消费 Kafka Y 做窗口聚合操作产出分钟级别聚合指标至 Kafka Z Kafka Z 实时导入至 Druid 以做即时 OLAP 分析，并且展示在 BI 应用看板 丢数故障分析简要介绍下这次生产中故障场景。整条故障追踪链路如下： 故障一： 收到报警反馈 flink 任务 A 入口流量为 0 定位 flink 任务 A 中某个算子的故障导致整个 job 卡住 导致此 flink 任务 A 上游 kafka X 积压了大量数据 重启 flink 任务 A后，消费大量积压在上游 kafka X 数据完成，任务恢复正常 故障一从而引发下游的故障二： 由于 flink 任务 A 使用了处理时间语义处理数据，并且有过滤和 keyBy 分桶窗口逻辑，在重启后消费大量积压在上游的数据时，导致 sink rebalance 后产出到下游 kafka Y 各个分区数据中的 server_timestamp 是乱序的 下游 flink 任务 B 在消费 Kafka Y 时使用了事件时间语义处理数据，并且使用了数据中的 server_timestamp 作为事件时间时间戳 flink 任务 B 消费了乱序很严重的数据之后，导致在窗口聚合计算时丢失了大量数据 最终展示在 BI 应用中的报表有丢失数据的情况 待修复的故障点 1.flink 任务 A 的稳定性故障，这部分解决方案暂不在本文中介绍 2.flink 任务 B 消费上游乱序丢数故障，解决方案在下文介绍 解决方案以及原理丢数故障解决方案解决方案是以下游 flink 任务 B 作为切入点，直接给出 flink 任务 B 的 sql 代码解决方案，java code 也可以按照这个方案实现，其本质原理相同。下文进行原理解释。 123456789SELECT to_unix_timestamp(server_timestamp / bucket) AS timestamp, -- format 成原有的事件时间戳 count(id) as id_cnt, sum(duration) as duration_sumFROM source_tableGROUP BY TUMBLE(proctime, INTERVAL &#x27;1&#x27; MINUTE), server_timestamp / bucket -- 根据事件时间分桶计算，将相同范围（比如 1 分钟）事件时间的数据分到一个桶内 解决方案原理首先明确一个无法避免的问题，在不考虑 watermark 允许延迟设置特别大的情况下，只要上游使用到了处理时间语义，下游使用事件时间语义，一旦上游发生故障重启并在短时间内消费大量数据，就不可避免的会出现上述错误以及故障。 在下游消费方仍然需要将对应事件时间戳的数据展示在 BI 平台报表中、并且全链路时间语义都为处理时间保障不丢数的前提下。解决方案就是在聚合并最终产出对应事件时间戳的数据。 最后的方案如下：整条链路全部为处理时间语义，窗口计算也使用处理时间，但是产出数据中的时间戳全部为事件时间戳。在出现故障的场景下，一分钟的窗口内的数据的事件时间戳可能相差几个小时，但在最终窗口聚合时可以根据事件时间戳划分到对应的事件时间窗口内，下游 BI 应用展示时使用此事件时间戳即可。 注意：sql 中的 bucket 需要根据具体使用场景进行设置，如果设置过于小，比如非故障场景下按照处理时间开 1 分钟的窗口，bucket设为 60000（1 分钟），那么极有可能，这个时间窗口中所有数据的 server_timestamp 都集中在某两分钟内，那么这些数据就会被分到两个桶（bucket）内，则会导致严重的数据倾斜。 输入数据样例模拟上述故障，flink B 的任务某一个窗口内的数据输入如下。 server_timestamp id duration 2020/9/01 21:14:38 1 300 2020/9/01 21:14:50 1 500 2020/9/01 21:25:38 2 600 2020/9/01 21:25:38 3 900 2020/9/01 21:25:38 2 800 输出数据样例按照上述解决方案中的 sql 处理过后，输出数据如下，则可以解决此类型丢数故障。 timestamp id_cnt duration_sum 2020/9/01 21:14:00 2 900 2020/9/01 21:25:00 3 2300 总结本文分析了在 flink 应用中： 上游使用处理时间语义的 flink 任务出现故障、重启消费大量积压数据并产出至下游数据乱序特别严重时，下游使用事件时间语义时遇到的大量丢数问题 以整条链路为处理时间语义的前提下，产出的数据时间戳为事件时间戳解决上述问题 以 sql 代码给出了丢数故障解决方案样例 学习资料flink https://github.com/flink-china/flink-training-course/blob/master/README.md https://ververica.cn/developers-resources/ https://space.bilibili.com/33807709","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | 基于 Flink 的短视频生产消费监控","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/apache-flink:realtime-monitor-video/","text":"生产实践 | 基于 Flink 的短视频生产消费监控 本文详细介绍了实时监控类指标的数据流转链路以及技术方案，大多数的实时监控类指标都可按照本文中的几种方案实现。 短视频生产消费监控短视频带来了全新的传播场域和节目形态，小屏幕、快节奏成为行业潮流的同时，也催生了新的用户消费习惯，为创作者和商户带来收益。而多元化的短视频也可以为品牌方提供营销机遇。 其中对于垂类生态短视频的生产消费热点的监控分析目前成为了实时数据处理很常见的一个应用场景，比如对某个圈定的垂类生态下的视频生产或者视频消费进行监控，对热点视频生成对应的优化推荐策略，促进热点视频的生产或者消费，构建整个生产消费数据链路的闭环，从而提高创作者收益以及消费者留存。 本文将完整分析垂类生态短视频生产消费数据的整条链路流转方式，并基于 Flink 提供几种对于垂类视频生产消费监控的方案设计。通过本文，你可以了解到： 垂类生态短视频生产消费数据链路闭环 实时监控短视频生产消费的方案设计 不同监控量级场景下的代码实现 flink 学习资料 项目简介垂类生态短视频生产消费数据链路流转架构图如下，此数据流转图也适用于其他场景： 在上述场景中，用户生产和消费短视频，从而客户端、服务端以及数据库会产生相应的行为操作日志，这些日志会通过日志抽取中间件抽取到消息队列中，我们目前的场景中是使用 Kafka 作为消息队列；然后使用 flink 对垂类生态中的视频进行生产或消费监控（内容生产通常是圈定垂类作者 id 池，内容消费通常是圈定垂类视频 id 池），最后将实时聚合数据产出到下游；下游可以以数据服务，实时看板的方式展现，运营同学或者自动化工具最终会帮助我们分析当前垂类下的生产或者消费热点，从而生成推荐策略。 方案设计 其中数据源如下： Kafka 为全量内容生产和内容消费的日志。 Rpc/Http/Mysql/配置中心/Redis/HBase 为需要监控的垂类生态内容 id 池（内容生产则为作者 id 池，内容消费则为视频 id 池），其主要是提供给运营同学动态配置需要监控的 id 范围，其可以在 flink 中进行实时查询，解析运营同学想要的监控指标范围，以及监控的指标和计算方式，然后加工数据产出，可以支持随时配置，实时数据随时计算产出。 其中数据汇为聚类好的内容生产或者消费热点话题或者事件指标： Redis/HBase 主要是以低延迟（Redis 5ms p99，HBase 100ms p99，不同公司的服务能力不同）并且高 QPS 提供数据服务，给 Server 端或者线上用户提供低延迟的数据查询。 Druid/Mysql 可以做为 OLAP 引擎为 BI 分析提供灵活的上卷下钻聚合分析能力，供运营同学配置可视化图表使用。 Kafka 可以以流式数据产出，从而提供给下游继续消费或者进行特征提取。 废话不多说，我们直接上方案和代码，下述几种方案按照监控 id 范围量级区分，不同的量级对应着不同的方案，其中的代码示例为 ProcessWindowFunction，也可以使用 AggregateFunction 代替，其中主要监控逻辑都相同。 方案 1适合监控 id 数据量小的场景（几千 id），其实现方式是在 flink 任务初始化时将需要监控的 id 池或动态配置中心的 id 池加载到内存当中，之后只需要在内存中判断内容生产或者消费数据是否在这个监控池当中。 12345678910111213141516171819ProcessWindowFunction p = new ProcessWindowFunction&lt;CommonModel, CommonModel, Long, TimeWindow&gt;() &#123; // 配置中心动态 id 池 private Config&lt;Set&lt;Long&gt;&gt; needMonitoredIdsConfig; @Override public void open(Configuration parameters) throws Exception &#123; this.needMonitoredIdsConfig = ConfigBuilder .buildSet(&quot;needMonitoredIds&quot;, Long.class); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;CommonModel&gt; iterable, Collector&lt;CommonModel&gt; collector) throws Exception &#123; Set&lt;Long&gt; needMonitoredIds = needMonitoredIdsConfig.get(); /** * 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 */ &#125;&#125; 监控的 id 池可以按照固定或者可配置从而分出两种获取方式：第一种是在 flink 任务开始时就全部加载进内存中，这种方式适合监控 id 池不变的情况；第二种是使用动态配置中心，每次都从配置中心访问到最新的监控 id 池，其可以满足动态配置或者更改 id 池的需求，并且这种实现方式通常可以实时感知到配置更改，几乎无延迟。 方案 2适合监控 id 数据量适中（几十万 id），监控数据范围会不定时发生变动的场景。其实现方式是在 flink 算子中定时访问接口获取最新的监控 id 池，以获取最新监控数据范围。 1234567891011121314151617181920212223242526272829ProcessWindowFunction p = new ProcessWindowFunction&lt;CommonModel, CommonModel, Long, TimeWindow&gt;() &#123; private long lastRefreshTimestamp; private Set&lt;Long&gt; needMonitoredIds; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.refreshNeedMonitoredIds(System.currentTimeMillis()); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;CommonModel&gt; iterable, Collector&lt;CommonModel&gt; collector) throws Exception &#123; long windowStart = context.window().getStart(); this.refreshNeedMonitoredIds(windowStart); /** * 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 */ &#125; public void refreshNeedMonitoredIds(long windowStart) &#123; // 每隔 10 秒访问一次 if (windowStart - this.lastRefreshTimestamp &gt;= 10000L) &#123; this.lastRefreshTimestamp = windowStart; this.needMonitoredIds = Rpc.get(...) &#125; &#125;&#125; 根据上述代码实现方式，按照时间间隔的方式刷新 id 池，其缺点在于不能实时感知监控 id 池的变化，所以刷新时间可能会和需求场景强耦合（如果 id 池会频繁更新，那么就需要缩小刷新时间间隔）。也可根据需求场景在每个窗口开始前刷新 id 池，这样可保证每个窗口中的 id 池中的数据一直保持更新。 方案 3方案 3 对方案 2 的一个优化（几十万 id，我们生产环境中最常用的）。其实现方式是在 flink 中使用 broadcast 算子定时访问监控 id 池，并将 id 池以广播的形式下发给下游参与计算的各个算子。其优化点在于：比如任务的并行度为 500，每 1s 访问一次，采用方案 2 则访问监控 id 池接口的 QPS 为 500，在使用 broadcast 算子之后，其访问 QPS 可以减少到 1，可以大大减少对接口的访问量，减轻接口压力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Example &#123; @Slf4j static class NeedMonitorIdsSource implements SourceFunction&lt;Map&lt;Long, Set&lt;Long&gt;&gt;&gt; &#123; private volatile boolean isCancel; @Override public void run(SourceContext&lt;Map&lt;Long, Set&lt;Long&gt;&gt;&gt; sourceContext) throws Exception &#123; while (!this.isCancel) &#123; try &#123; TimeUnit.SECONDS.sleep(1); Set&lt;Long&gt; needMonitorIds = Rpc.get(...); // 可以和上一次访问的数据做比较查看是否有变化，如果有变化，才发送出去 if (CollectionUtils.isNotEmpty(needMonitorIds)) &#123; sourceContext.collect(new HashMap&lt;Long, Set&lt;Long&gt;&gt;() &#123;&#123; put(0L, needMonitorIds); &#125;&#125;); &#125; &#125; catch (Throwable e) &#123; // 防止接口访问失败导致的错误导致 flink job 挂掉 log.error(&quot;need monitor ids error&quot;, e); &#125; &#125; &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; &#125; public static void main(String[] args) &#123; ParameterTool parameterTool = ParameterTool.fromArgs(args); InputParams inputParams = new InputParams(parameterTool); StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(); final MapStateDescriptor&lt;Long, Set&lt;Long&gt;&gt; broadcastMapStateDescriptor = new MapStateDescriptor&lt;&gt;( &quot;config-keywords&quot;, BasicTypeInfo.LONG_TYPE_INFO, TypeInformation.of(new TypeHint&lt;Set&lt;Long&gt;&gt;() &#123; &#125;)); /********************* kafka source *********************/ BroadcastStream&lt;Map&lt;Long, Set&lt;Long&gt;&gt;&gt; broadcastStream = env .addSource(new NeedMonitorIdsSource()) // redis photoId 数据广播 .setParallelism(1) .broadcast(broadcastMapStateDescriptor); DataStream&lt;CommonModel&gt; logSourceDataStream = SourceFactory.getSourceDataStream(...); /********************* dag *********************/ DataStream&lt;CommonModel&gt; resultDataStream = logSourceDataStream .keyBy(KeySelectorFactory.getStringKeySelector(CommonModel::getKeyField)) .connect(broadcastStream) .process(new KeyedBroadcastProcessFunction&lt;String, CommonModel, Map&lt;Long, Set&lt;Long&gt;&gt;, CommonModel&gt;() &#123; private Set&lt;Long&gt; needMonitoredIds; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.needMonitoredIds = Rpc.get(...) &#125; @Override public void processElement(CommonModel commonModel, ReadOnlyContext readOnlyContext, Collector&lt;CommonModel&gt; collector) throws Exception &#123; // 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 &#125; @Override public void processBroadcastElement(Map&lt;Long, Set&lt;Long&gt;&gt; longSetMap, Context context, Collector&lt;CommonModel&gt; collector) throws Exception &#123; // 需要监控的字段 Set&lt;Long&gt; needMonitorIds = longSetMap.get(0L); if (CollectionUtils.isNotEmpty(needMonitorIds)) &#123; this.needMonitoredIds = needMonitorIds; &#125; &#125; &#125;); /********************* kafka sink *********************/ SinkFactory.setSinkDataStream(...); env.execute(inputParams.jobName); &#125;&#125; 方案 4适合于超大监控范围的数据（几百万，我们自己的生产实践中使用扩量到 500 万）。其原理是将监控范围接口按照 id 按照一定规则分桶。flink 消费到日志数据后将 id 按照 监控范围接口 id 相同的分桶方法进行分桶 keyBy，这样在下游算子中每个算子中就可以按照桶名称，从接口中拿到对应桶的监控 id 数据，这样 flink 中并行的每个算子只需要获取到自己对应的桶的数据，可以大大减少请求的压力。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Example &#123; public static void main(String[] args) &#123; ParameterTool parameterTool = ParameterTool.fromArgs(args); InputParams inputParams = new InputParams(parameterTool); StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(); final MapStateDescriptor&lt;Long, Set&lt;Long&gt;&gt; broadcastMapStateDescriptor = new MapStateDescriptor&lt;&gt;( &quot;config-keywords&quot;, BasicTypeInfo.LONG_TYPE_INFO, TypeInformation.of(new TypeHint&lt;Set&lt;Long&gt;&gt;() &#123; &#125;)); /********************* kafka source *********************/ DataStream&lt;CommonModel&gt; logSourceDataStream = SourceFactory.getSourceDataStream(...); /********************* dag *********************/ DataStream&lt;CommonModel&gt; resultDataStream = logSourceDataStream .keyBy(KeySelectorFactory.getLongKeySelector(CommonModel::getKeyField)) .timeWindow(Time.seconds(inputParams.accTimeWindowSeconds)) .process(new ProcessWindowFunction&lt;CommonModel, CommonModel, Long, TimeWindow&gt;() &#123; private long lastRefreshTimestamp; private Set&lt;Long&gt; oneBucketNeedMonitoredIds; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;CommonModel&gt; iterable, Collector&lt;CommonModel&gt; collector) throws Exception &#123; long windowStart = context.window().getStart(); this.refreshNeedMonitoredIds(windowStart, bucket); /** * 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 */ &#125; public void refreshNeedMonitoredIds(long windowStart, long bucket) &#123; // 每隔 10 秒访问一次 if (windowStart - this.lastRefreshTimestamp &gt;= 10000L) &#123; this.lastRefreshTimestamp = windowStart; this.oneBucketNeedMonitoredIds = Rpc.get(bucket, ...) &#125; &#125; &#125;); /********************* kafka sink *********************/ SinkFactory.setSinkDataStream(...); env.execute(inputParams.jobName); &#125;&#125; 总结本文首先介绍了，在短视频领域中，短视频生产消费数据链路的整个闭环，并且其数据链路闭环一般情况下也适用于其他场景；以及对应的实时监控方案的设计和不同场景下的代码实现，包括： 垂类生态短视频生产消费数据链路闭环：用户操作行为日志的流转，日志上传，实时计算，以及流转到 BI，数据服务，最后数据赋能的整个流程 实时监控方案设计：监控类实时计算流程中各类数据源，数据汇的选型 监控 id 池在不同量级场景下具体代码实现 学习资料flink https://github.com/flink-china/flink-training-course/blob/master/README.md https://ververica.cn/developers-resources/ https://space.bilibili.com/33807709","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时新增类指标标准化处理方案","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/apache-flink:realtime-new-id/","text":"实时新增类指标标准化处理方案 实时指标整个链路开发过程中的一些经验。 实时新增类指标大体上可以将实时新增类指标以以下两种维度进行分类。 identity id 类型维度 identity id 类型 备注 number(long) 类型 identity id 数值类型 identity id 的好处在于可以使用 Bitmap 类组件做到精确去重。 字符类型 identity id 字符类型 identity id 去重相对复杂，有两种方式，在误差允许范围之内使用 BloomFilter 进行去重，或者使用 key-value 组件进行精确去重。 产出数据类型维度 产出数据类型 备注 明细类数据 此类数据一般是要求将新增的数据明细产出，uv 的含义是做过滤，产出的明细数据中的 identity id 不会有重复。输出明细数据的好处在于，我们可以在下游使用 OLAP 引擎对明细数据进行各种维度的聚合计算，从而很方便的产出不同维度下的 uv 数据。 聚合类数据 将一个时间窗口内的 uv 进行聚合，并且可以计算出分维度的 uv，其产出数据一般都是[维度 + uv_count]，但是这里的维度一般情况下是都是固定维度。如果需要拓展则需要改动源码。 计算链路因此新增产出的链路多数就是以上两种维度因子的相互组合。 number(long) 类型 identity id 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public interface RoaringBitmapDuplicateable&lt;Model&gt; &#123; long DEFAULT_DUPLICATE_MILLS = 24 * 3600 * 1000L; BiPredicate&lt;Long, Long&gt; ROARING_BIT_MAP_CLEAR_BI_PREDICATE = (start, end) -&gt; end - start &gt;= DEFAULT_DUPLICATE_MILLS; // 初始化 default ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; getBitMapValueState(String name) &#123; return this.getRuntimeContext().getState( new ValueStateDescriptor&lt;&gt;(name, TypeInformation.of( new TypeHint&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt;() &#123; &#125;)) ); &#125; RuntimeContext getRuntimeContext(); long getLongId(Model model); Optional&lt;Logger&gt; getLogger(); default BiPredicate&lt;Long, Long&gt; roaringBitMapClearBiPredicate() &#123; return ROARING_BIT_MAP_CLEAR_BI_PREDICATE; &#125; default List&lt;Model&gt; duplicateAndGet(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Date, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Date, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Map&lt;Long, Model&gt; idModelsMap = models .stream() .collect(Collectors.toMap(this::getLongId, Function.identity(), (oldOne, newOne) -&gt; oldOne)); Set&lt;Long&gt; ids = idModelsMap.keySet(); List&lt;Model&gt; newModels = Lists.newArrayList(); for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; if (idModelsMap.containsKey(id)) &#123; newModels.add(idModelsMap.get(id)); &#125; &#125; &#125; newModels.stream() .map(this::getLongId) .forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return newModels; &#125; default long duplicateAndCount(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Set&lt;Long&gt; ids = models .stream() .map(this::getLongId) .collect(Collectors.toSet()); List&lt;Long&gt; newIds = Lists.newArrayList(); int count = 0; for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; newIds.add(id); count++; &#125; &#125; newIds.forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return count; &#125; default Tuple2&lt;Long, Roaring64NavigableMap&gt; checkAndGetState(long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitmap = bitMapValueState.value(); if (null == bitmap) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;New RoaringBitMapValueState Timestamp=&#123;&#125;&quot;, windowStartTimestamp)); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else if (this.roaringBitMapClearBiPredicate().test(bitmap.f0, windowStartTimestamp)) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;Clear RoaringBitMapValueState, from start=&#123;&#125; to end=&#123;&#125;&quot;, bitmap.f0, windowStartTimestamp)); bitMapValueState.clear(); bitmap.f1.clear(); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else &#123; return bitmap; &#125; &#125;&#125; 字符类型 identity id使用 Flink state 使用 key-value 外存 如果选用的是 Redis 作为 key-value 过滤，那么这里会有一个巧用 Redis bit 特性的优化。举一个一般场景下的方案与使用 Redis bit 特性的方案做对比： 场景：假如需要同一天有几十场活动，并且都希望计算出这几十场活动的 uv，那么我们就可以按照下图设计 Redis bit 结构。 通常方案： 这种场景下，如果有 1 亿用户，需要同时计算 50 个活动或者 50 个不同维度下的 uv。那么理论上最大 key 数量为 1 亿 * 50 = 50 亿个 key。 Redis bit 方案： 这样做的一个优点，就是这几十场活动的 uv 计算都使用了相同的 Redis key 来计算，可以大幅度减少 Redis 的容量占用。使用此方案的话，以上述相同的用户和活动场数，理论上最大key 数量仅仅为 1 亿，只是 value 数量会多占几十个 bit。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时开发标准化处理方案","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/realtime/","text":"实时开发标准化处理方案 实时指标整个链路开发过程中的一些经验。 指标类型 指标类型 备注 pv 简单 pv 类型指标，来一条日志信息加一，计算 count uv uv 类型指标，需要在一段时间范围内（一小时、一天、一场活动）正对 user_id 等 identity_id 去重计数。 监控圈定集合内的 identity_id 数据表现 有一组鉴定的 identity_id 集合，实时的监控或者计算这组 identity_id 相关的数据 排名 实时监控某些数据并根据某些指标进行排序","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"项目经验 | 一定要多思考，过脑子","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/work:life-cycle/","text":"项目经验 | 一定要多思考，过脑子 前言老妹是一个数据开发同学，最近在参与一个中台项目的实时数据建设，这也是她第一次完全的投入到一个项目体系当中（之前都是在某一个项目中负责一小块）。就在做这个项目的过程中，遇到了一些问题。 比如可行性调研和技术方案的细节也七七八八的写了不少，但是实际上需求整体的推进进度很慢，迟迟没有进入到开发阶段。依赖的上游接口不确定，整个项目的推进就暂停了。和上游沟通了半天，但是聊完之后发现好像没有什么可行的结论。 总的来说就是，需求推进慢，推进方向不正确，导致浪费了很多时间。 于是老妹抱着这些问题找到了羊老狗。 需求提出需求评审阶段之前好像还有一个阶段，提出需求阶段？？？开会时候说的【这个可以提成需求】？？？不太理解，这里是否有一个阶段？？？ 需求评审阶段需求评审阶段非常重要，需要根据目前的能力合理评估需求 A：哪部分需求，以目前的能力经验能评估可行性或者收益很低的，可以直接同步出去； B：哪部分需求能做，但是从长远来看，目前做完的结果只是一种过渡方案，可能 1-2 个月之后就会有代替方案的项目，这部分可以支持，但是没必要为了做成而去支持复杂模块，不必要投入全部人力做这类临时的方案； C：哪部分可以做，并且从长远来看，收益很高的，这部分我们可以深度调研方案。 分别举例如下 A 目前从技术上是不可行的，或者从资源层面是不可行的，比如我们目前的能力是能抗住 100w qps 的压力，但是需求可能是 1000w qps； 分析场景上不合理，我是数据人，有的数据需求可能从分析场景上不合理，比如这个场景其实是算 pv 就可以得出结论的，但是需求是 uv，这类就没有必要，而且 uv 相对 pv 肯定更加耗时耗力。 B 我目前是做实时数据的，用数据举例。目前的项目有两种方案：第一种方案是实时数据产出 A 维度数据到 OLAP 中，后端在查询 OLAP 时填充 B、C 维度，最后在看板展示数据；但是目前由于人力问题，后端没法支持完成。因此就有了第二中方案，第二种方案是实时数据产出 A、B、C 维度数据到 OLAP 中，但是数据源没有 B、C 维度，B、C 维度的数据只有后端才存储，所以实时这边需要去存储了 B、C 维度的维表当中做关联操作，并且关联存在一定的难度。这类情况下，实时关联 B、C 只是一个过渡方案，从长期来看，其实这部分没必要因为一个临时方案，而过度投入人力在收益很小的这个方案里面，可以做一些舍弃。 C 从长远来看可以做，之后会有越来越多的业务需要使用我们产出的数据，那么我们就可以针对这些业务做通用化模型建设，收益高。即使多加一些人力在这类需求上也可以。 以上这些情况在需求评审阶段，都需要对产品有一定的观点输出，可以表达我们的观点，技术可以做什么和技术应该做什么。 需求评审完成之后，就可以进入需求技术方案调研阶段。 需求技术方案调研阶段技术方案调研 + 设计（5W 1H）我们和上游能够沟通的内容是哪些？比如数据就是加字段，能不能同步一些表？？还能做什么沟通？？排期能不能沟通，应不应该沟通，应不应该自己去沟通，或者最好什么时候去沟通？比如等整体的技术方案确定下来，确定了工作量，然后去定排期 和产品能够沟通的东西是哪些？需求合理性？需求目前遇到的问题？需求的技术方案可行性？得等技术方案完全确认才能够评估工作量？ 和上下游能够沟通的东西是哪些？能否做支持？ 整体就是 5W 1H 的方式去调研整个技术方案。 首先第一点，最最最重要的就是一定要有目的的盘东西。我最终要产出什么（WHAT），我的上游依赖是什么（WHAT）。举例：需要产出的东西 - 目前手上有的东西 = 上游依赖。只要明确了目的，其实这部分东西很快就能够盘清楚。 第二点，我们盘清楚上游依赖之后，就是需要去想一下这些上游依赖可能存在的提供方式。举例：这些上游依赖是必须都要其他上游提供吗？能不能通过一些其他的方式自己进行实现？ 第三点，如果目前的技术方案满足不了需求，那么还有没有其他的方式进行实现，一定要多想可行性方案，可以多提供方案，但是方案的优劣可以让产品进行取舍抉择。举例：比如数据上面需要一些维度数据，我之前可能就评估各类方法去关联维表去填充这些维度信息。其实还可以推动上游数据去添加这些维度数据。让可行性方案变多，我们只需要去评估可行性方案的优劣。推动上游去做改动时，一定要通过业务角度解释这些数据的通用性，不可能每来一次需求添加一次，那样会被喷，上下游压力都很大。 第四点，数据人遇到问题时能使用数据说话就使用数据说话，包括方案的可行性等。举例：调研后发现，这个实现成本很高，反馈的时候一定要用数据说话，比如成本达到 xxx，使用 xxx 台机器，这个成本是不是可控的。尽量避免技术方案评审时只能反馈实现成本很高。 第五点，遇到问题时一定需要尽早的抛出问题，推动各方解决问题，而不能 block 在自己这里。举例：比如在技术方案上，自己可以先和 tech leader 详细讨论，一定注意详细讨论的前提是自己对整个项目目前的需求理解一定要到位，理解有问题的地方及时和产品沟通，明确理解需求。我就犯过比较明显的错误，经常会被 tech leader 问你调研的这个东西合不合理，有什么价值，这个东西能不能用其他的东西进行替代，或者你的方案为什么是这样的，这只是一个过渡的方案，我们有没有必要去完全按照需求要求的产出。 第六点，技术调研过程中，如果遇到上下游依赖的话，可以先和上下游方进行沟通，与上下游沟通一定要把握一个度，这部分可以慢慢学习理解。需要站在自己做的事情的全局上和未来的通用性上去思考问题，不但要思考自己的东西，还要站在上下游的角度上思考问题。 举例：沟通时可以和上游确认这部分上游能不能做支持，哪部分能帮忙支持，哪部分不能支持。站在对方的角度上想问题，比如自己需要的某些字段或者数据，其实站在上下游的角度上是不需要的，这个就需要多考量。上下游支持如果还存在难度的话，那就需要和产品同步目前的整体问题，让产品去推动各方或者是做一些取舍。 第七点，方案的每个细节都需要确认。做数据，那么数据每个字段都得清清楚楚的列出计算逻辑才算需求调研完成！！！不然很容易出现口径不一致和可行性问题。 通过上述几个步骤之后，都要最终和产品确认我们产出最终交付物。 这里结束之后，其实我们自己大致的工作量也就大致可以评估出来了，工作量是一个很迷的东西，如果工作经验不长的话，很难估计一个准确的工作量。 不一定就是利用现在手上有的东西去做需求，还可以去推动其他上下游去支持需求。 做项目时，没必要一口吃一个胖子，也没有必要钻一些牛角尖，有些东西比较难做，我们可以先实现简单的，后续再优化方案，进行迭代，没有什么项目是一次性能做完美的。 需求排期Question1.什么时候可以进入排期阶段？ 技术方案敲定后排人力，按照项目上下游情况排期？ 2.排期的时候如果依赖上游，上游的排期应该怎么沟通？或者我们和上游能够沟通的内容是哪些？ 上游的排期不应该自己去沟通。但是产品又会问，你拍的这个期有和上游沟通吗？ 3.有哪些方式去做排期？ 倒排：比如产品希望这个需求或者功能在某个时间点上线，那么我们就需要按照这个时间点，往前排。如果有上游依赖，还需要定下来上游依赖最晚给到的时间点。举例：比如产品希望 11.30 号整体上线，如果开发、自测需要 5 人天，联调预估需要 2 人天的话，我们就就可以排 11.22 开始开发，并且还需要根据上游依赖的强弱指定上游依赖给到的时间，比如 11.23 号给到。最后还需要留一定的 buffer 给自己，避免中途出现问题。 正排：这种情况下，一般都没有给定的截止日期。 3.为什么要这样划分排期？ 排期一般划分为一下几个： 开发 自测 联调 回测 上线 很多情况下，尤其是多个项目组合作的项目，一般都只能排到联调 4.排期过程中容易忽略的关键点？ 上下游依赖：上下游依赖很重要，上下游如果一旦发生 delay，咱的排期可能就会受到很大的影响。资源、上下游接口等等等等。 风险控制：一定要说明风险点。比如资源，上游依赖，上线前的前置依赖等。最好可以有一个 checklist，根据经验列举自己在开发过程中可能会遇到的各类问题。 5.所有的东西不能都以 mock 的形式进行，比如为了赶排期，复杂项目的联调全部使用 mock 数据就会存在问题 开发1.开发过程中最需要注意的就是单测的编写，一定要记得编写单测，保证每个单元的代码都是正确的 2.数据开发完成后需要验数，验数过程是很重要的","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"项目经验 | 一定要多思考，过脑子","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/work:thinker/","text":"本系列每篇文章都比较短小，不定期更新，从一些实际的经历出发抛砖引玉，希望给小伙伴一些启发。本文介绍了博主从做数据到玩数据的整个思考过程的转变，阅读时长大概 2 分钟，话不多说，直接进入正文！ 项目经验 | 怎么从做数据转变到玩数据？ 前言是不是还一直是在执行工作而不是真正的去思考工作？","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高","date":"2020-01-06T12:39:35.000Z","path":"2020/01/06/java:study-hashmap/","text":"为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高 123static int indexFor(int hashcode, int length) &#123; return hashcode &amp; (length-1); &#125; 怎样提高get(key)效率？怎样提高get(key)效率 = 怎样提高确定key的所在hashmap中数组index的效率 hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 1.假设key的hashcode为h，数组长度为length，为了将数据打散，使hashmap中的数组下标对应的Entry链表都有数据，首先想到的就是对length取模，计算方法如下： 123static int indexFor(int h, int length) &#123; return h % length;&#125; 因此确定了hashmap的indexFor函数的计算方式。 怎样确定hashmap数组的length“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式？我们发现做位运算的消耗是很小的，所以尝试将取模运算转换成位预算，由此发现length为2的n次方时会有 123static int indexFor(int h, int length) &#123; return h % length; // 等价于 h &amp; (length - 1);&#125; 由于 &amp; 运算符计算效率大大高于 % 运算符，所以上述计算转换为： 123static int indexFor(int h, int length) &#123; return h &amp; (length - 1);&#125; 也规定了 length 必须是2的n次方（n&gt;0）除此之外，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://yangyichao-mango.github.io/tags/JAVA/"}]},{"title":"apache-flink:study-flink","date":"2019-11-22T03:30:41.000Z","path":"2019/11/22/apache-flink:study-flink/","text":"所有operator中的初始化如果写在构造函数当中就会出错，问题是序列化时的问题flink从jobmanager序列化到各个 taskmanager时可能会出问题 split组件功能可以减少多个flatmap的性能损失多个flatmap数据每个都是使用全部的流进行filtersplit一个就可以满足","tags":[]},{"title":"Apache Flink 学习：Jobs 和 Scheduling","date":"2019-11-20T03:27:03.000Z","path":"2019/11/20/apache-flink:study-flink-jobs-and-scheduling/","text":"Apache Flink 学习：Jobs 和 Scheduling SchedulingFlink中的执行资源是通过 Task Slots 定义的。每个 TaskManager 都有一个或多个 Task Slots，每个 Slot 可以运行一个并行任务流。并行任务流由多个连续的任务组成，例如 MapFunction 的第n个并行实例和 ReduceFunction 的第n个并行实例。请注意，Flink 经常并发地执行连续的任务：对于流式程序，基本上都会使用并行任务，对于批处理程序，也会经常使用并行任务。 下图说明了这一点。一个具有数据源、MapFunction 和 ReduceFunction 的程序。源函数和 MapFunction 的并行度为4，而 ReduceFunction 的并行度为3。流由 Source - Map - Reduce 组成。在这个集群中，有两个 TaskManager，每个 TaskManager 有三个 slot，则程序将按如下所述执行。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 State 和容错——State 的使用","date":"2019-11-19T07:48:16.000Z","path":"2019/11/19/apache-flink:study-flink-datastream-state-and-fault-tolerance-working-with-state/","text":"flink有两种基本的state，分别是Keyed State以及Operator State(non-keyed state)；其中Keyed State只能在KeyedStream上的functions及operators上使用；每个operator state会跟parallel operator中的一个实例绑定；Operator State支持parallelism变更时进行redistributingKeyed State及Operator State都分别有managed及raw两种形式，managed由flink runtime来管理，由runtime负责encode及写入checkpoint；raw形式的state由operators自己管理，flink runtime无法了解该state的数据结构，将其视为raw bytes；所有的datastream function都可以使用managed state，而raw state一般仅限于自己实现operators来使用stateful function可以通过CheckpointedFunction接口或者ListCheckpointed接口来使用managed operator state；CheckpointedFunction定义了snapshotState、initializeState两个方法；每当checkpoint执行的时候，snapshotState会被调用；而initializeState方法在每次用户定义的function初始化的时候(第一次初始化或者从前一次checkpoint recover的时候)被调用，该方法不仅可以用来初始化state，还可以用于处理state recovery的逻辑对于manageed operator state，目前仅仅支持list-style的形式，即要求state是serializable objects的List结构，方便在rescale的时候进行redistributed；关于redistribution schemes的模式目前有两种，分别是Even-split redistribution(在restore/redistribution的时候每个operator仅仅得到整个state的sublist)及Union redistribution(在restore/redistribution的时候每个operator得到整个state的完整list)FunctionSnapshotContext继承了ManagedSnapshotContext接口，它定义了getCheckpointId、getCheckpointTimestamp方法；FunctionInitializationContext继承了ManagedInitializationContext接口，它定义了isRestored、getOperatorStateStore、getKeyedStateStore方法，可以用来判断是否是在前一次execution的snapshot中restored，以及获取OperatorStateStore、KeyedStateStore对象","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Hadoop 学习：hdfs架构","date":"2019-11-13T06:04:52.000Z","path":"2019/11/13/apache-hadoop:study-hadoop-hdfs-design/","text":"Apache Hadoop 学习：hdfs架构 文件系统 Namespace HDFS支持传统的分层文件组织。用户或应用程序可以在这些目录中创建目录并存储文件。文件系统命名空间层次结构与大多数其他现有文件系统相似；可以创建和删除文件，将文件从一个目录移动到另一个目录，或者重命名文件。HDFS支持用户配额和访问权限。HDFS不支持硬链接或软链接。然而，HDFS体系结构并不排除实现这些特性。 虽然HDFS遵循文件系统的命名约定，但某些路径和名称（例如/.reserved和.snapshot）是保留的。透明加密和快照等功能使用保留路径。 NameNode维护文件系统名称空间。对文件系统命名空间或其属性的任何更改都由NameNode记录。应用程序可以指定HDFS应该维护的文件副本的数量。文件的副本数称为该文件的复制因子。此信息由NameNode存储。","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"}]},{"title":"Apache Flink 学习：Table Api & SQL","date":"2019-11-12T01:51:01.000Z","path":"2019/11/12/apache-flink:study-flink-table-api-and-sql/","text":"Apache Flink 学习：Table Api &amp; SQL","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 Operators（算子）——Joining","date":"2019-11-11T10:30:13.000Z","path":"2019/11/11/apache-flink:study-flink-datastream-operators-joining/","text":"Apache Flink 学习：DataStream Api 中 Operators（算子）——Joining Window JoinWindow Join 可以将两个流中相同key并且在同一个窗口中的元素进行链接。窗口可以使用 Window Assigner 进行定义，并且对来自不同的流的元素进行计算。 12345stream.join(otherStream) .where(&lt;KeySelector&gt;) .equalTo(&lt;KeySelector&gt;) .window(&lt;WindowAssigner&gt;) .apply(&lt;JoinFunction&gt;) 关于一些语义的解释：1.两个流的成对组合的过程类似于 Inner Join，意味着如果一个流中的元素没有另一个流的元素要与之连接，则不会发出这些元素。 2.那些被连接的元素的时间戳是位于相应窗口中的最大时间戳。例如，以[5，10)为边界的窗口，则进行连接的元素的时间戳为9。 Tumbling Window Join执行 Tumbling Window Join，在相同 key，相同时间窗口内的元素会进行笛卡尔积组合，这种组合类似于 inner join，如果一个流的对应流的同一窗口中没有元素，则这个流的当前窗口数据不会发出去。 12345678910111213141516171819import org.apache.flink.api.java.functions.KeySelector;import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;import org.apache.flink.streaming.api.windowing.time.Time; ...DataStream&lt;Integer&gt; orangeStream = ...DataStream&lt;Integer&gt; greenStream = ...orangeStream.join(greenStream) .where(&lt;KeySelector&gt;) .equalTo(&lt;KeySelector&gt;) .window(TumblingEventTimeWindows.of(Time.milliseconds(2))) .apply (new JoinFunction&lt;Integer, Integer, String&gt; ()&#123; @Override public String join(Integer first, Integer second) &#123; return first + &quot;,&quot; + second; &#125; &#125;); Sliding Window Join执行 Sliding Window Join，具有公共 key 和公共滑动窗口的所有元素都作为成对组合进行连接，并传递给 JoinFunction 或 FlatJoinFunction。也是 inner join，当前流窗口匹配不到对应流窗口的元素则不会发送数据到下游！请注意，某些元素可能在一个滑动窗口中连接，在另一个滑动窗口中不会进行连接！ 12345678910111213141516171819import org.apache.flink.api.java.functions.KeySelector;import org.apache.flink.streaming.api.windowing.assigners.SlidingEventTimeWindows;import org.apache.flink.streaming.api.windowing.time.Time;...DataStream&lt;Integer&gt; orangeStream = ...DataStream&lt;Integer&gt; greenStream = ...orangeStream.join(greenStream) .where(&lt;KeySelector&gt;) .equalTo(&lt;KeySelector&gt;) .window(SlidingEventTimeWindows.of(Time.milliseconds(2) /* size */, Time.milliseconds(1) /* slide */)) .apply (new JoinFunction&lt;Integer, Integer, String&gt; ()&#123; @Override public String join(Integer first, Integer second) &#123; return first + &quot;,&quot; + second; &#125; &#125;); Session Window Join执行 Session Window Join，具有相同 key 的所有元素（当“组合”满足会话条件时）将以成对组合联接，并传递给JoinFunction或FlatJoinFunction。同样，也是 inner join，当前流窗口匹配不到对应流窗口的元素则不会发送数据到下游！ Interval Joininterval join 用一个公共 key 连接两个流的元素（流A和流B），其中流B的元素具有与流A中元素的时间戳相对时间间隔内的时间戳，那么这个时间间隔内两个流的元素就会 join。 即：b.timestamp ∈ [a.timestamp + lowerBound; a.timestamp + upperBound] or a.timestamp + lowerBound &lt;= b.timestamp &lt;= a.timestamp + upperBound 其中 lowerBound 和 upperBound 可正可负，只要 lowerBound &lt;= upperBound。 1234567891011121314151617181920import org.apache.flink.api.java.functions.KeySelector;import org.apache.flink.streaming.api.functions.co.ProcessJoinFunction;import org.apache.flink.streaming.api.windowing.time.Time;...DataStream&lt;Integer&gt; orangeStream = ...DataStream&lt;Integer&gt; greenStream = ...orangeStream .keyBy(&lt;KeySelector&gt;) .intervalJoin(greenStream.keyBy(&lt;KeySelector&gt;)) .between(Time.milliseconds(-2), Time.milliseconds(1)) .process (new ProcessJoinFunction&lt;Integer, Integer, String()&#123; @Override public void processElement(Integer left, Integer right, Context ctx, Collector&lt;String&gt; out) &#123; out.collect(first + &quot;,&quot; + second); &#125; &#125;);","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"apache-flink:study-allowedLateness-and-maxOutOfOrderness","date":"2019-11-11T02:32:17.000Z","path":"2019/11/11/apache-flink:study-allowedLateness-and-maxOutOfOrderness/","text":"","tags":[]},{"title":"Apache Kafka 学习：kafka在数据处理中的应用","date":"2019-11-10T15:12:14.000Z","path":"2019/11/10/apache-kafka:study-kafka-in-data-process/","text":"Apache Kafka 学习：kafka在数据处理中的应用的一些个人理解。 离线数据处理场景在离线数据处理的过程中。如果不使用消息队列，在并发量很小的情况下，所有的客户端数据日志直接向hdfs写数据暂时不会产生什么问题。如果不使用消息队列，在并发量很大的情况下，向 hdfs 写数据就会出现问题，首先，向hdfs写数据会有锁竞争的情况，可能会导致大部分写请求很长时间得不到锁，导致大量请求延迟或者超时，这是不能接受的；并且 hdfs 作为文件系统不能承受太大的并发量，在并发很高的情况下，集群可能会崩溃。 问题原因总结总的来说，在这种情况下，问题的根本在于高并发情况下，hdfs 作为文件系统不能承受高并发请求的问题。 实施方案所以需要一种工具可以将客户端日志这种高并发请求转换为低并发的请求，这时候就可以使用kafka这样的消息队列，客户端的高并发请求直接写入 kafka，然后 hdfs 以低并发消费 kafka 中的数据。这样就解决了文件系统不能支持高并发的情况。并且由于 kafka 的HA特性，可以保证数据的正确性。 kafka作用将高并发请求以低并发方式处理。这种方式中解耦效果不明显，下面的实时数据处理使用到的解耦效果比较明显。 实时数据处理场景在实时数据处理的过程中。如果不使用消息队列，上游数据写入到类似 flink 这样的实时处理引擎当中，flink处理完成后向下游 olap 引擎（druid，clickhouse等）或者hdfs，hive，es等的文件系统写数据时，就需要为每一种 olap 引擎开发一种 connector，这样的情况下，每出现一种 olap 引擎或者每当下游的 olap 引擎升级版本引入新特性时，就需要 flink 开发工程师开发一种新的 connector 或者跟随 olap 引擎的升级而升级自己的 connector，这样 flink 开发工程师的维护成本之后就会特别高。这里有同学可能会说可以在数据处理的过程中使用下游 olap 等的引擎提供的 sdk，这种方法是可以的，但是实时处理打不风情况下并发量很高，olap 引擎提供的 sdk 应对这种高并发的场景可能会有很多问题。 问题原因总结问题的根本在于实时处理引擎和下游之间的耦合问题，这就需要一种HA的中间件来将各个模块进行解耦，kafka这样的消息队列可以很好的解决这中模块之间高度耦合的情况。 实施方案在 flink 和 druid中间使用 kafka 进行解耦，让 flink 向 kafka 生成数据，druid 消费 kafka 的数据。这样就使得 flink 可以只开发和维护一套针对于 kafka 的 connector，druid也只用开发和维护一套针对 kafka 的 connector，这样无论是实时处理引擎的升级或替换，或者是实时处理引擎下游的模块的升级或替换，都不会互相影响，并且这些模块的工程师只需要对消息队列的 connector 进行维护即可，并且可以根据其特性进行更好的优化。 kafka作用模块之间的解耦。让各个模块各司其职。拓展：1.Java 虚拟机在 Java 语言和各个系统之间的作用。2.Sql 进行三范式优化，不需要将所有数据都放在一张表当中，将n对n的表拆分出一张维表进行解耦。将维度拆分为维表可以减少数据量，更好划分和使用维度数据。3.经典网络五层模型，划分为五层，则在每一层中更新或者新建协议栈只需要对上下层进行兼容即可，不需要对整个网络架构模型做调整。4.Maven multiModule 划分。5.springMvc。等等。","tags":[{"name":"Apache Kafka","slug":"Apache-Kafka","permalink":"https://yangyichao-mango.github.io/tags/Apache-Kafka/"}]},{"title":"Apache Flink 学习：DataStream Api 中 Operators（算子）——窗口","date":"2019-11-09T14:48:53.000Z","path":"2019/11/09/apache-flink:study-flink-datastream-operators-windows/","text":"Apache Flink 学习：DataStream Api 中 Operators（算子）——窗口 Keyed Windows 123456789stream .keyBy(...) &lt;- keyed versus non-keyed windows .window(...) &lt;- required: &quot;assigner&quot; [.trigger(...)] &lt;- optional: &quot;trigger&quot; (else default trigger) [.evictor(...)] &lt;- optional: &quot;evictor&quot; (else no evictor) [.allowedLateness(...)] &lt;- optional: &quot;lateness&quot; (else zero) [.sideOutputLateData(...)] &lt;- optional: &quot;output tag&quot; (else no side output for late data) .reduce/aggregate/fold/apply() &lt;- required: &quot;function&quot; [.getSideOutput(...)] &lt;- optional: &quot;output tag&quot; Non-Keyed Windows 12345678stream .windowAll(...) &lt;- required: &quot;assigner&quot; [.trigger(...)] &lt;- optional: &quot;trigger&quot; (else default trigger) [.evictor(...)] &lt;- optional: &quot;evictor&quot; (else no evictor) [.allowedLateness(...)] &lt;- optional: &quot;lateness&quot; (else zero) [.sideOutputLateData(...)] &lt;- optional: &quot;output tag&quot; (else no side output for late data) .reduce/aggregate/fold/apply() &lt;- required: &quot;function&quot; [.getSideOutput(...)] &lt;- optional: &quot;output tag&quot; Window 生命周期简而言之，当属于该窗口的第一个元素到达时，将会创建一个窗口，并且当时间（Event Time 或者 Processing Time）超过其结束时间戳加上用户指定的允许延迟时间时，将完全删除该窗口，注意窗口都是左开右闭，比如：[0, 5)。Flink 保证只删除基于时间的窗口，而不删除其他类型的窗口，例如 Global Window。例如，使用基于事件时间的窗口，并且创建一个窗口大小为5分钟的滚动（Tumbing）窗口，并且允许延迟1分钟。当时间戳属于12:00到12:05之间的第一个元素到达时，Flink 将创建一个新窗口，当 Watermark 通过12:06时间戳时，就会把这个窗口删除。 此外，每个窗口都包含一个 Trigger 和一个函数（ProcessWindowFunction, ReduceFunction, AggregateFunction or FoldFunction）。函数包含了要应用于窗口内容的计算，而 Trigger 制定了什么情况下才触发执行这些函数。比如，触发策略可能类似于“当窗口中的元素数超过4时”或“当 WaterMark 通过窗口结束时”进行触发。Trigger 还可以决定什么时候删除窗口中的元素。 除上述内容外，您还可以指定一个 Evictor，该 Evictor 将能够在 Trigger 触发后、应用函数之前和/或之后从窗口中移除元素。 下面例子中的窗口都是按照 Event Time 或者 Processing Time进行指定。 Keyed vs Non-Keyed Windows首先要指定的是是否应该为流设置 key。使用keyBy（…）可以将无限流拆分为逻辑 keyed 流。 在 Keyed Stream 的情况下，传入 event 的任何属性都可以用作键。拥有一个 Keyed Stream 将允许您的窗口计算由多个任务并行执行，因为每个逻辑 Keyed Stream 都可以独立于其他任务进行处理。所有引用同一个键的 event 都将被发送到同一个并行任务（通过 partitioner 完成）。 如果不是 Keyed Stream，则不会将原始流拆分为多个逻辑流，所有窗口逻辑将由单个任务执行，即并行度为1。 Tumbling Windows 滚动窗口，如果你指定的滚动窗口大小为一天计算一次，并且你需要更具你本地的时间的 00:00:00 开始，则必须按照时区来指定窗口。可以看到上图中，无论是多少个 key，每个 key 的窗口的起始和截止时间都相同。 1234567891011121314151617181920212223242526272829303132333435363738/** * Creates a new &#123;@code TumblingEventTimeWindows&#125; &#123;@link WindowAssigner&#125; that assigns * elements to time windows based on the element timestamp and offset. * * 可以根据 时间戳 以及 偏移量 来指定 窗口的范围 * * &lt;p&gt;For example, if you want window a stream by hour,but window begins at the 15th minutes * of each hour, you can use &#123;@code of(Time.hours(1),Time.minutes(15))&#125;,then you will get * time windows start at 0:15:00,1:15:00,2:15:00,etc. * * 比如，如果需要一个窗口大小为一个小时，从每个小时的第15分钟开始计数的窗口，则可以使用下面的代码实现 * of(Time.hours(1),Time.minutes(15)) * 这样获得的窗口就是 0:15:00，1:15:00，2:15:00 ... * * &lt;p&gt;Rather than that,if you are living in somewhere which is not using UTC±00:00 time, * such as China which is using UTC+08:00,and you want a time window with size of one day, * and window begins at every 00:00:00 of local time,you may use &#123;@code of(Time.days(1),Time.hours(-8))&#125;. * The parameter of offset is &#123;@code Time.hours(-8))&#125; since UTC+08:00 is 8 hours earlier than UTC time. * * 除此之外，如果您的时区不是 UTC±00:00 时间，比如在 中国（时区是 UTC+08:00），并且你需要一个一天大小的窗口， * 并且窗口时间是本地 00:00:00开始，则可以使用下面的代码实现 * of(Time.days(1), Time.hours(-8)) * * @param size The size of the generated windows. * @param offset The offset which window start would be shifted by. * @return The time policy. */public static TumblingEventTimeWindows of(Time size, Time offset) &#123; return new TumblingEventTimeWindows(size.toMilliseconds(), offset.toMilliseconds());&#125;public static void main(String[] args) &#123; // daily tumbling event-time windows offset by -8 hours. input .keyBy(&lt;key selector&gt;) .window(TumblingEventTimeWindows.of(Time.days(1), Time.hours(-8))) .&lt;windowed transformation&gt;(&lt;window function&gt;);&#125; Sliding Windows 滑动窗口，如果你指定窗口大小和滑动步长一样，那么和滚动窗口的作用一样，滑动窗口的一个明显的特征就是：窗口可能会重叠，即同一个元素可能会属于不同的窗口。 和滚动窗口相同，如果你指定的滚动窗口大小为一天计算一次，你需要更具你本地的时间的 00:00:00 开始，则必须按照时区来指定窗口。 1234567public static void main(String[] args) &#123; // sliding processing-time windows offset by -8 hours input .keyBy(&lt;key selector&gt;) .window(SlidingProcessingTimeWindows.of(Time.hours(12), Time.hours(1), Time.hours(-8))) .&lt;windowed transformation&gt;(&lt;window function&gt;);&#125; Session Windows 会话窗口，根据会话来指定窗口，与滚动和滑动窗口相比，会话窗口不重叠，并且没有固定的开始和结束时间。会话窗口可以指定静态指定会话间隔，或者可以让用户动态指定会话间隔。 123456789101112131415DataStream&lt;T&gt; input = ...;// event-time session windows with static gapinput .keyBy(&lt;key selector&gt;) .window(EventTimeSessionWindows.withGap(Time.minutes(10))) .&lt;windowed transformation&gt;(&lt;window function&gt;); // event-time session windows with dynamic gapinput .keyBy(&lt;key selector&gt;) .window(EventTimeSessionWindows.withDynamicGap((element) -&gt; &#123; // determine and return session gap &#125;)) .&lt;windowed transformation&gt;(&lt;window function&gt;); Global Windows 全局窗口（即无窗口），代表所有元素斗数以一个全局窗口，如果你不指定 Trigger，那么永远也不会生产出数据，因为全局窗口没有窗口开始和窗口结束的概念。 123456DataStream&lt;T&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(GlobalWindows.create()) .&lt;windowed transformation&gt;(&lt;window function&gt;); 窗口函数在定义 window assigner 之后，我们需要指定要在每个窗口上执行的计算。当系统确定窗口准备好处理时（Trigger决定），这些窗口函数就可以用于处理每个（Keyed / Non-Keyed）窗口的元素。 窗口函数可以是ReduceFunction、AggregateFunction、FoldFunction或ProcessWindowFunction之一。前两个函数执行起来会更高效，因为 Flink 可以在每个窗口中的元素到达时递增地聚合元素。ProcessWindowFunction获取包含在窗口中的所有元素的Iterable，以及有关元素所属窗口的其他元信息。 使用ProcessWindowFunction的窗口函数不能像其他函数那样高效地执行，因为Flink在调用函数之前必须在内部缓冲窗口的所有元素。这可以通过将ProcessWindowFunction与ReduceFunction、AggregateFunction或FoldFunction组合使用来提高效率，从而使得其他窗口元数据或者窗口元素的进行增量聚合。 ReduceFunction变量：两个输入生成一个输出，三个变量的类型必须相同。触发时间：在每个窗口的元素到来的时候进行增量聚合。 12345678910DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .reduce(new ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt; &#123; public Tuple2&lt;String, Long&gt; reduce(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2) &#123; return new Tuple2&lt;&gt;(v1.f0, v1.f1 + v2.f1); &#125; &#125;); AggregateFunctionAggregateFunction 是 ReduceFunction 的一个扩展版本。 变量：三个变量，一个是输入，一个是 accumulator 累加器，还有一个是输出，三个变量的类型可以不同。触发时间：在每个窗口的元素到来的时候进行增量聚合。 123456789101112131415161718192021222324252627282930313233/** * The accumulator is used to keep a running sum and a count. The &#123;@code getResult&#125; method * computes the average. */private static class AverageAggregate implements AggregateFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123; @Override public Tuple2&lt;Long, Long&gt; createAccumulator() &#123; return new Tuple2&lt;&gt;(0L, 0L); &#125; @Override public Tuple2&lt;Long, Long&gt; add(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator) &#123; return new Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + 1L); &#125; @Override public Double getResult(Tuple2&lt;Long, Long&gt; accumulator) &#123; return ((double) accumulator.f0) / accumulator.f1; &#125; @Override public Tuple2&lt;Long, Long&gt; merge(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b) &#123; return new Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1); &#125;&#125;DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .aggregate(new AverageAggregate()); FoldFunctionFoldFunction 是 AggregateFunction 的一个简易版本。 变量：三个个变量，一个是输出值的初始化值，一个是输入，还有一个是输出，三个变量中输入和输出的类型可以不同，但是输出和输出初始化值必须相同。触发时间：在每个窗口的元素到来的时候进行增量聚合。 FoldFunction 指定如何将窗口的输入元素与输出类型的元素组合。对添加到窗口的每个元素和当前输出值增量调用 FoldFunction。 12345678910DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .fold(&quot;&quot;, new FoldFunction&lt;Tuple2&lt;String, Long&gt;, String&gt;&gt; &#123; public String fold(String acc, Tuple2&lt;String, Long&gt; value) &#123; return acc + value.f1; &#125; &#125;); ProcessWindowFunctionProcessWindowFunction 可以得到一个包含窗口的所有元素的迭代器，以及一个访问时间和状态信息的上下文对象，使得它能够提供比其他窗口函数更好的灵活性。但是这是以性能和资源消耗为代价的，因为元素不能增量聚合，而是需要在内部缓冲，直到窗口可以处理为止。 变量：四个变量，一个是窗口的key，一个是包含了窗口信息的上下文，一个是窗口内所有元素的迭代器，一个是输出数据的收集器。触发时间：窗口内有数据并且 Watermark 到达了窗口结束时间时触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt; implements Function &#123; /** * Evaluates the window and outputs none or several elements. * * @param key The key for which this window is evaluated. * @param context The context in which the window is being evaluated. * @param elements The elements in the window being evaluated. * @param out A collector for emitting elements. * * @throws Exception The function may throw exceptions to fail the program and trigger recovery. */ public abstract void process( KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out) throws Exception; /** * The context holding window metadata. */ public abstract class Context implements java.io.Serializable &#123; /** * Returns the window that is being evaluated. */ public abstract W window(); /** Returns the current processing time. */ public abstract long currentProcessingTime(); /** Returns the current event-time watermark. */ public abstract long currentWatermark(); /** * State accessor for per-key and per-window state. * * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt;If you use per-window state you have to ensure that you clean it up * by implementing &#123;@link ProcessWindowFunction#clear(Context)&#125;. */ public abstract KeyedStateStore windowState(); /** * State accessor for per-key global state. */ public abstract KeyedStateStore globalState(); &#125;&#125; 123456789101112131415161718192021DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(t -&gt; t.f0) .timeWindow(Time.minutes(5)) .process(new MyProcessWindowFunction());/* ... */public class MyProcessWindowFunction extends ProcessWindowFunction&lt;Tuple2&lt;String, Long&gt;, String, String, TimeWindow&gt; &#123; @Override public void process(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out) &#123; long count = 0; for (Tuple2&lt;String, Long&gt; in: input) &#123; count++; &#125; out.collect(&quot;Window: &quot; + context.window() + &quot;count: &quot; + count); &#125;&#125; 使用 ProcessWindowFunction 进行元素 count 是非常低效的，下面会讲到怎样将 ReduceFunction 或者 AggregateFunction 与 ProcessWindowFunction 结合使用将增量的数据的与 ProcessWindowFunction 配合进行使用。 为什么需要用到 ProcessWindowFunction：如果必要的话，一般的业务逻辑是没必要使用到 ProcessWindowFunction 的，但是有的需求需要获取到当前元素时间戳，窗口开始结束等等的信息，这时就需要使用 ProcessWindowFunction 来获取这些信息了。 ProcessWindowFunction 与 ReduceFunction123456789101112131415161718192021222324252627DataStream&lt;SensorReading&gt; input = ...;input .keyBy(&lt;key selector&gt;) .timeWindow(&lt;duration&gt;) .reduce(new MyReduceFunction(), new MyProcessWindowFunction());// Function definitionsprivate static class MyReduceFunction implements ReduceFunction&lt;SensorReading&gt; &#123; public SensorReading reduce(SensorReading r1, SensorReading r2) &#123; return r1.value() &gt; r2.value() ? r2 : r1; &#125;&#125;private static class MyProcessWindowFunction extends ProcessWindowFunction&lt;SensorReading, Tuple2&lt;Long, SensorReading&gt;, String, TimeWindow&gt; &#123; public void process(String key, Context context, Iterable&lt;SensorReading&gt; minReadings, Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out) &#123; SensorReading min = minReadings.iterator().next(); out.collect(new Tuple2&lt;Long, SensorReading&gt;(context.window().getStart(), min)); &#125;&#125; ProcessWindowFunction 与 AggregateFunction1234567891011121314151617181920212223242526272829303132333435363738394041424344454647DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .timeWindow(&lt;duration&gt;) .aggregate(new AverageAggregate(), new MyProcessWindowFunction());// Function definitions/** * The accumulator is used to keep a running sum and a count. The &#123;@code getResult&#125; method * computes the average. */private static class AverageAggregate implements AggregateFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123; @Override public Tuple2&lt;Long, Long&gt; createAccumulator() &#123; return new Tuple2&lt;&gt;(0L, 0L); &#125; @Override public Tuple2&lt;Long, Long&gt; add(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator) &#123; return new Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + 1L); &#125; @Override public Double getResult(Tuple2&lt;Long, Long&gt; accumulator) &#123; return ((double) accumulator.f0) / accumulator.f1; &#125; @Override public Tuple2&lt;Long, Long&gt; merge(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b) &#123; return new Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1); &#125;&#125;private static class MyProcessWindowFunction extends ProcessWindowFunction&lt;Double, Tuple2&lt;String, Double&gt;, String, TimeWindow&gt; &#123; public void process(String key, Context context, Iterable&lt;Double&gt; averages, Collector&lt;Tuple2&lt;String, Double&gt;&gt; out) &#123; Double average = averages.iterator().next(); out.collect(new Tuple2&lt;&gt;(key, average)); &#125;&#125; ProcessWindowFunction 与 FoldFunction123456789101112131415161718192021222324252627282930DataStream&lt;SensorReading&gt; input = ...;input .keyBy(&lt;key selector&gt;) .timeWindow(&lt;duration&gt;) .fold(new Tuple3&lt;String, Long, Integer&gt;(&quot;&quot;,0L, 0), new MyFoldFunction(), new MyProcessWindowFunction())// Function definitionsprivate static class MyFoldFunction implements FoldFunction&lt;SensorReading, Tuple3&lt;String, Long, Integer&gt; &gt; &#123; public Tuple3&lt;String, Long, Integer&gt; fold(Tuple3&lt;String, Long, Integer&gt; acc, SensorReading s) &#123; Integer cur = acc.getField(2); acc.setField(cur + 1, 2); return acc; &#125;&#125;private static class MyProcessWindowFunction extends ProcessWindowFunction&lt;Tuple3&lt;String, Long, Integer&gt;, Tuple3&lt;String, Long, Integer&gt;, String, TimeWindow&gt; &#123; public void process(String key, Context context, Iterable&lt;Tuple3&lt;String, Long, Integer&gt;&gt; counts, Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out) &#123; Integer count = counts.iterator().next().getField(2); out.collect(new Tuple3&lt;String, Long, Integer&gt;(key, context.window().getEnd(),count)); &#125;&#125; ProcessWindowFunction 中使用 stateWindowFunction（遗留）在一些可以使用 ProcessWindowFunction 的地方，你也可以使用 WindowFunction，这是较旧版本的 ProcessWindowFunction，它提供的上下文信息较少，并且没有一些高级功能，例如 per-window keyed state。 1234567891011121314public interface WindowFunction&lt;IN, OUT, KEY, W extends Window&gt; extends Function, Serializable &#123; /** * Evaluates the window and outputs none or several elements. * * @param key The key for which this window is evaluated. * @param window The window that is being evaluated. * @param input The elements in the window being evaluated. * @param out A collector for emitting elements. * * @throws Exception The function may throw exceptions to fail the program and trigger recovery. */ void apply(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out) throws Exception;&#125; 123456DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .apply(new MyWindowFunction()); Triggers触发器决定了窗口函数什么时候处理窗口中的数据。每一个 WindowAssigner 都会带有一个默认的 Trigger，如果默认的 Trigger 不符合需求，你可以使用 trigger(…) 指定你需要的触发器。 一个 Trigger 接口有五个方法，可以通过编写函数指定如何对不同的 event 做出相应。 Function 作用 TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx) 每向窗口添加一个元素时触发一次。 TriggerResult onEventTime(long time, W window, TriggerContext ctx) Event Time timer 触发时调用。 TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) Processing Time timer 调用时触发。 void onMerge(W window, OnMergeContext ctx) 方法与有状态 Trigger 相关，并在两个触发器的相应窗口合并时合并它们的状态，例如在使用会话窗口时（会话窗口每添加一个元素就会产生一个窗口）。 void clear(W window, TriggerContext ctx) 将当前窗口的 state 清除。 前三个函数通过 TriggerResult 决定如何处理它们的调用事件。 TriggerResult 作用 TriggerResult.CONTINUE 什么都不做。 TriggerResult.FIRE 触发计算。 TriggerResult.PURGE 清除窗口内的元素。 TriggerResult.FIRE_AND_PURGE 触发计算，并且在此之后清除窗口内的元素。 触发运算并且清除元素WindowAssigners 的默认 Triggers很多 WindowAssigners 的默认 Triggers是适用于很多场景的。例如，所有的 event-time window assigners 都将 EventTimeTrigger 作为默认的 Trigger。这个 Trigger 的作用就是当 Watermark 到达了窗口结束时间时就触发。提示1：GlobalWindow 的默认 Trigger 是永远不会触发的 NeverTrigger。提示2：通过使用 trigger() 指定触发器，您将覆盖 WindowAssigner 的默认触发器。例如，如果为 TumblingEventTimeWindows 指定 CountTrigger，则不会再根据时间进度而仅按 count 触发窗口。 通用的 Triggers Trigger 作用 EventTimeTrigger 根据由 Watermark 计算的 Event Time 进度触发。 ProcessingTimeTrigger 根据 Processing Time 触发。 CountTrigger 在窗口中的元素数超过给定限额时触发。 PurgingTrigger 将另一个 Trigger 作为参数，并将其转换为清除触发器。 EvictorsFlink 的窗口模型中允许指定除 WindowAssigner 和 Trigger 之外的可选逐出器（Evictor）。可以使用exictor(…)方法指定。Exictor 能够在触发器触发之后，并在使用窗口函数之前或者之后移除元素。为此，逐出器接口有两个方法： 123456789101112131415161718192021/** * Optionally evicts elements. Called before windowing function. * 在执行窗口函数之前执行。 * * @param elements The elements currently in the pane. * @param size The current number of elements in the pane. * @param window The &#123;@link Window&#125; * @param evictorContext The context for the Evictor */void evictBefore(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext);/** * Optionally evicts elements. Called after windowing function. * 在执行窗口函数之后执行。 * * @param elements The elements currently in the pane. * @param size The current number of elements in the pane. * @param window The &#123;@link Window&#125; * @param evictorContext The context for the Evictor */void evictAfter(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext); Evictor 作用 CountEvictor 保持窗口内元素数量符合用户指定数量，如果多于用户指定的数量，从窗口缓冲区的开头丢弃剩余的元素。 DeltaEvictor 使用 DeltaFunction 和一个阈值，计算窗口缓冲区中的最后一个元素与其余每个元素之间的 delta 值，并删除 delta 值大于或等于阈值的元素。 TimeEvictor 以毫秒为单位的时间间隔作为参数，对于给定的窗口，找到元素中的最大的时间戳max_ts，并删除时间戳小于max_ts - interval的所有元素。 默认情况下，都只会在执行 WindowFunction 之前执行 Evictor。 提示：Flink 不能保证窗口中元素的顺序。这意味着尽管逐出器可能会从窗口的开头移除元素，但这些元素不一定是最先到达或最后到达的元素。 Allowed Lateness概念使用 Event Time 窗口时，可能会发生元素到达晚的情况，即 Flink 用于跟踪 Event Time 进度的 Watermark 已超过元素所属窗口的结束时间戳。 默认情况下，当发现 Watermark 已经超过到达的元素所属的窗口结束时间时，将删除这个延迟元素。但是 Flink 可以给窗口算子指定一个最大允许延迟时间。Allowed lateness 指定元素在被删除之前可以延迟多少时间，其默认值为0。 在迟到元素到达时，如果 Watermark 大于其所属窗口的结束时间时，并且 Watermark 小于窗口结束时间加上 allowed lateness，这个迟到的元素仍然可以被加到这个窗口内进行运算。有的触发器会出现在延迟但是没有丢弃的元素到达时，使得窗口再次计算，比如 EventTimeTrigger。 提示1：在 assignTimestampsAndWatermarks 时有一个 maxOutOfOrderness 的概念，maxOutOfOrderness 是生成 Watermark 所需要的，是指元素最大无序时间。而 Allowed Lateness 是指在 Watermark 到达窗口结束时间之后允许延迟多长时间，两个概念不一样。提示2：a.通过 watermark 机制来处理 out-of-order 的问题，属于第一层防护，属于全局性的防护，通常说的乱序问题的解决办法，就是指这类；b.通过窗口上的 allowedLateness 机制来处理 out-of-order 的问题，属于第二层防护，属于特定 window operator 的防护，late element 的问题就是指这类 1234567DataStream&lt;T&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .allowedLateness(&lt;time&gt;) .&lt;windowed transformation&gt;(&lt;window function&gt;); 提示：当使用 GlobalWindows 时，没有元素会被认为是迟到的，因为这个窗口哦的结束时间时 Long.MAX_VALUE。 迟到的数据做旁路输出（side output）123456789101112final OutputTag&lt;T&gt; lateOutputTag = new OutputTag&lt;T&gt;(&quot;late-data&quot;)&#123;&#125;;DataStream&lt;T&gt; input = ...;SingleOutputStreamOperator&lt;T&gt; result = input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .allowedLateness(&lt;time&gt;) .sideOutputLateData(lateOutputTag) .&lt;windowed transformation&gt;(&lt;window function&gt;);DataStream&lt;T&gt; lateStream = result.getSideOutput(lateOutputTag); 拓展思考当指定 Allowed Lateness &gt; 0 时，在 Watermark 通过窗口结束时间后，将保留窗口及其内容。在这种情况下，当一个延迟但未被丢弃的元素到达时，它可能会再次触发窗口运算。这些被触发运算的被称为 late firing。在使用会话窗口时，它们可能会将两个预先存在的未合并窗口进行合并，下面是一个例子。 比如：有一个会话窗口且 Gap 为3分钟，现在有两个窗口，第一个窗口起始和结束时间为（01:00:00，01:00:05），第二个窗口起始和结束时间为（01:00:09，01:00:15），如果我们在此时不设置 Allowed Lateness 时，那么如果不保存第一个窗口的数据，运算第二个窗口的数据时，不会有什么问题，但是如果我们设置了 Allowed Lateness = 5 min，那么这时就会有问题了，比如有迟到元素01:00:15才到达，元素自己的时间戳为01:00:07，这样这个元素就可以将两个窗口的数据结合为一个窗口。 提示：延迟数据触发的运算应该将之前的计算结果更新，所以如果下游 sink 使用了 kafka，则这种情况不是很适用（除非消费 kafka 的是一些 updateable dfs），否则，你将会得到很多的对相同组数据计算的结果。 窗口结果的使用窗口计算的结果也会转化为一个数据流，这份结果中不会包含窗口操作的任何信息，所以如果后续计算中需要这些信息，你必须使用 ProcessWindowFunction 将这些信息通过编码传输进去。 窗口和 Watermark 的联系当 Watermark 到达窗口算子处时，会触发两个事件：1.Watermark 会触发所有的窗口中的最大时间戳（窗口结束时间戳 - 1）&lt; 到达的最新 Watermark的窗口运算。2.将 Watermark 发送到下游算子。Intuitively, a watermark “flushes” out any windows that would be considered late in downstream operations once they receive that watermark. 连续的窗口算子设置窗口时产生的状态大小的注意事项窗口大小可以定义的很大（如天、周或月），因此可能会累积非常大的状态（state）。所以在估计窗口计算的存储需求时，需要记住以下几个规则： 1.Flink 会为每个元素所属的窗口创建一个副本。因此，滚动的窗口保留每个元素的一个副本（一个元素只属于一个窗口）。相反，滑动窗口可能会创建每个元素中的几个副本。因此，1天大小的窗口，1秒滑动步长的滑动窗口可能不是一个好主意。 2.ReduceFunction、AggregateFunction 和 FoldFunction 可以显著减少存储需求，因为它们在元素到达时就聚合元素，并且每个窗口只存储一个值。相反，仅仅使用 ProcessWindowFunction 就需要累积所有元素。 3.使用 Evictor 可防止任何预聚合，因为在应用计算之前，窗口的所有元素都必须通过 Evictor 传递。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 Operators（算子）——概览","date":"2019-11-09T08:22:30.000Z","path":"2019/11/09/apache-flink:study-flink-datastream-operators-overview/","text":"描述了基本 Operators 的 Transformations，应用这些转换后如何进行 physical partitioning（物理分区），以及对Flink算子链的深入了解。 DataStream TransformationsPhysical partitioning Transformation Description Custom partitioning DataStream → DataStream CustomPartitionerWrapper 使用自定义的 partitioner 为每一条 record 选择下一个 task dataStream.partitionCustom(partitioner, \"someKey\"); dataStream.partitionCustom(partitioner, 0); Random partitioning DataStream → DataStream ShufflePartitioner 按随机均匀划分元素 dataStream.shuffle(); Rebalancing (Round-robin partitioning) DataStream → DataStream RebalancePartitioner 分区循环划分元素，为每个下游创建相等的负载。对于存在数据倾斜的性能优化非常有用。 dataStream.rebalance(); Rescaling DataStream → DataStream RescalePartitioner 将元素循环（round robin）分配到下游 operator 的子集。如果你的 pipeline 是一下的情况，那么这种方式会非常有用。 例如，将并行数据源的每个实例的数据传输到的下游多个算子（operators）一个子集以分配负载。但不希望 full rebalance，则这非常有用。 如果合理配置 TaskManager 的 slot数量，则数据传输只需要本地传输，而不需要通过网络传输数据。 上游 operators 向的下游 operators 发送 record 取决于上游 operators 和下游 operators 的并行度。 例如，如果上游 operator 的并行度为2，而下游 operator 的并行度为6，则一个上游 operator 将 record 分配给三个下游 operator，而另一个上游 operator 将 record 分配给其他三个下游 operator。相反，如果下游 operator 的并行度为2，而上游 operator 的并行度为6，则三个上游 operator 将分配给一个下游 operator，而其他三个上游 operator 将分配给另一个下游 operator。 如果上下游算子的并行度不是彼此的倍数，则一个或多个下游 operator 将具有来自上游 operator 的不同数量的输入。 如下图： dataStream.rescale(); Broadcasting DataStream → DataStream BroadcastPartitioner 广播数据到下游的每个partition。 dataStream.broadcast(); Local Forward DataStream → DataStream ForwardPartitioner 数据传输到本地的下游算子。 dataStream.forward(); GlobalPartitioner DataStream → DataStream GlobalPartitioner 数据传输到下游子任务id为0的task中。 dataStream.forward(); Key Groups DataStream → DataStream KeyGroupStreamPartitioner 相同key的值会传输到同一个下游。类似于Rescaling，但是不用再api中指定，再使用keyBy时会自动指定此方法。 dataStream.keyBy(); Task chaining 和 资源组链接两个 Transformations 意味着可以将它们共同放在在同一个线程中执行以获得更好的性能。默认情况下，Flink会尽可能链接两个算子（例如，两个 Map Transformations）。如果需要，可以使用API对 Task chaining 进行细粒度控制： 在 Flink 中，一个 slot 就是一个资源组。如果需要的话，你可以通过使用api把上下游算子隔离在不同的 slot 中运行。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 EventTime","date":"2019-11-09T04:09:56.000Z","path":"2019/11/09/apache-flink:study-flink-datastream-eventtime/","text":"Apache Flink 学习：DataStream Api 中 EventTime Processing time处理时间是指执行相应操作的机器的系统时间 Event time事件时间是每个事件在其生产设备（生产event的设备，手机等的源头设备）上发生的时间 Event Time 和 WatermarkFlink中测量事件时间进度的机制是Watermark。Watermark作为数据流的一部分流动，并带有时间戳t。Watermark（t）声明该流中的 Event Time 已达到时间t，这意味着流中不应再有时间戳t’&lt;=t的元素（即 Event Time 早于或等于 Watermark 的事件） 下图显示了具有时间戳的事件流，以及内联流动的水印。在这个例子中，事件是有序的，这意味着 Watermark 只是流中的周期性标记。 Watermark对于无序流是至关重要的，如下所示，其中事件到达顺序不是按时间戳顺序。Watermark代表通过流中的该点，这个时间戳之前的事件都应该到达了。一旦Watermark到达算子，算子就可以将其内部事件时钟更新到Watermark的值。 并行流的 WatermarksWatermark 在源数据 Function 处生成，或直接在源数据 Function 之后生成。源数据 Function 的每个并行子任务通常独立生成其 Watermark。这些 Watermark 定义并行源数据的 Event Time。 当 Watermark 流过程序时，会更新到达算子的 Event Time，当一个 Watermark 更新了算子的 Event Time 时，它会为其下游的后续算子生成一个新的 Watermark。 某些算子消费多个输入流，例如：union 算子或者跟在 keyBy，partition 算子的之后的算子。这样的算子的 Event Time 是所有输入 stream 中最小的 Watermark，即：Operator Event Time = min(Input Stream 1 Watermark, Input Stream 2 Watermark…)算子会跟着输入流 Watermark 的更新来更新算子自己的 Event Time。 下图显示了流经并行流的事件和 Watermark 以及算子获取 Event Time 的示例。 注意，Kafka支持分区 Watermark Ingestion time注入时间是事件进入Flink Job的时间。在源Operator处，每条Operator获取源数据的时间作为Ingestion time时间戳 生成 Timestamps 和 Watermarks分配 Timestamps数据流源生成 Timestamps 和 Watermarks数据源可以直接为它们产生的数据分配 Timestamp，并且他们也能发送 Watermark。这样做的话，在后面的处理中就没必要再去定义 Timestamp 分配器了，需要注意的是：如果在后面的处理中使用了一个 timestamp 分配器，由数据源提供的任何 timestamp 和 watermark 都会被重写。 Timestamp 分配器 / Watermark生成器Timestamp 分配器获取一个流并生成一个新的带有 Timestamp 元素和 Watermark 的流。如果上游的原始数据流已经有 Timestamp 或 Watermark，则 Timestamp 分配器将覆盖上游的 Timestamp 或 Watermark Timestamp 分配器通常在数据源之后立即指定，但这并不是严格要求的。通常是在 Timestamp 分配器之前先解析（MapFunction）和过滤（FilterFunction）数据源。在任何情况下，都需要在基于 Event Time 算子（例如 window 操作）运行之前指定 Timestamp 分配程序。有一个特殊情况，当使用 Kafka 作为流作业的数据源时，Flink 允许在数据源内部指定 Timestamp 分配器和 Watermark 生成器。更多关于如何进行的信息请参考Kafka Connector的文档。 直接在FlinkKafkaConsumer010上面使用assignTimestampsAndWatermarks可以根据kafka source的partitions的特性进行设置Timestamps和Watermarks，让用户做一些特殊的处理 Running timestamp extractors / watermark generators directly inside the Kafka source, per Kafkapartition, allows users to let them exploit the per-partition characteristics. Kafka 分区的 Timestamp当使用 Apache Kafka 作为数据源时，每个 Kafka 分区可能有一个简单的 Event Time 模式（递增的时间戳或有界无序）。然而，当 Flink Job 使用来自Kafka的流时，多个分区常常并行消费，每一个 operator 算子并行消费时就会破坏各个分区的时间模式（这是 Kafka 客户端消费 Kafka 数据必然发生的）。 在这种情况下，可以使用 Flink’s Kafka-partition-aware watermark generation，使用该功能，每个 Kafka 分区在 Kafka consumer 内部生成 Watermark，每个分区合并 Watermark 的方式与流 shuffles 时合并 Watermark 的方式相同。 例如，如果事件时间戳严格按照 Kafka 分区递增，则使用递增时间戳 Watermark 生成器生成每个分区的 Watermark 将是完美的全局 Watermark。 下图显示了如何使用 Flink’s Kafka-partition-aware watermark generation，以及在这种情况下 Watermark 如何通过流数据流传播。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：slot和parallelism设置的关系","date":"2019-11-08T07:31:08.000Z","path":"2019/11/08/apache-flink:study-flink-slot-parallelism/","text":"Apache Flink 学习：slot和parallelism设置的关系 如何设置 parallelismflink-conf.yaml1234cat flink-conf.yaml | grep parallelism# The parallelism used for programs that did not specify and other parallelism.parallelism.default: 1 命令行启动如果你是用命令行启动你的 Flink job，那么你也可以这样设置并行度(使用 -p 并行度)： 1./bin/flink run -p 10 ../word-count.jar 代码设置整个程序的并行度12StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();env.setParallelism(10); 注意：这样设置的并行度是你整个程序的并行度，那么后面如果你的每个算子不单独设置并行度覆盖的话，那么后面每个算子的并行度就都是这里设置的并行度的值了。 每个算子单独设置并行度1234data.keyBy(new xxxKey()) .flatMap(new XxxFlatMapFunction()).setParallelism(5) .map(new XxxMapFunction).setParallelism(5) .addSink(new XxxSink()).setParallelism(1) 如上，就是在每个算子后面单独的设置并行度，这样的话，就算你前面设置了 env.setParallelism(10) 也是会被覆盖的。 这也说明优先级是：算子设置并行度 &gt; env 设置并行度 &gt; 配置文件默认并行度 slot 图中 Task Manager 是从 Job Manager 处接收需要部署的 Task，任务的并行性由每个 Task Manager 上可用的 slot 决定。每个任务代表分配给任务槽的一组资源，slot 在 Flink 里面可以认为是资源组，Flink 将每个任务分成子任务并且将这些子任务分配到 slot 来并行执行程序。 例如，如果 Task Manager 有四个 slot，那么它将为每个 slot 分配 25％ 的内存。 可以在一个 slot 中运行一个或多个线程。 同一 slot 中的线程共享相同的 JVM。 同一 JVM 中的任务共享 TCP 连接和心跳消息。Task Manager 的一个 Slot 代表一个可用线程，该线程具有固定的内存，注意 Slot 只对内存隔离，没有对 CPU 隔离。默认情况下，Flink 允许子任务共享 Slot，即使它们是不同 task 的 subtask，只要它们来自相同的 job。这种共享可以有更好的资源利用率。 默认情况下，Flink 允许 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，只要它们来自同一个 job。因此，一个 slot 可能会负责这个 job 的整个管道（pipeline）。允许 slot sharing 有两个好处： 1.Flink 集群需要与 job 中使用的最高并行度一样多的 slots。这样不需要计算作业总共包含多少个 tasks（具有不同并行度）。 2.更好的资源利用率。在没有 slot sharing 的情况下，简单的 subtasks（source/map()）将会占用和复杂的 subtasks （window）一样多的资源。通过 slot sharing，将示例中的并行度从 2 增加到 6 可以充分利用 slot 的资源，同时确保繁重的 subtask 在 TaskManagers 之间公平地获取资源。 下图即为Flink subtasks 共享 slots的模式： 上面图片中有两个 Task Manager，每个 Task Manager 有三个 slot，这样我们的算子最大并行度那么就可以达到 6 个，在同一个 slot 里面可以执行 1 至多个子任务。 那么再看上面的图片，source/map/keyby/window/apply 最大可以有 6 个并行度，sink 只用了 1 个并行。 每个 Flink TaskManager 在集群中提供 slot。 slot 的数量通常与每个 TaskManager 的可用 CPU 内核数成比例。一般情况下你的 slot 数是你每个 TaskManager 的 cpu 的核数","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：Flink Job ExecutionGraph生成过程","date":"2019-11-08T01:49:18.000Z","path":"2019/11/08/apache-flink:study-flink-job-ExecutionGraph/","text":"Apache Flink 学习：Flink Job 执行计划生成过程 Transformations 并不是每一个 Transformation 都会转换成runtime层中的物理操作。有一些只是逻辑概念，比如union、split/select、partition等。如下图所示的转换树，在运行时会优化成下方的操作图。 执行计划转换过程 1.转换过程 StreamExecutionEnvironment 存放的 transformation -&gt; StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图2.StreamExecutionEnvironment 存放的 transformation -&gt; StreamGraph -&gt; JobGraph 在客户端完成，然后提交 JobGraph 到 JobManager3.JobManager 的主节点 JobMaster，将 JobGraph 转化为 ExecutionGraph，然后发送到不同的 taskManager，得到实际的物理执行图 LocalStreamEnvironment 中 parallelism其中 LocalStreamEnvironment Task 中的 parallelism 数量是根据以下代码生成的 12345678910111213141516171819202122232425262728293031323334@Publicpublic abstract class StreamExecutionEnvironment &#123; ... private static int defaultLocalParallelism = Runtime.getRuntime().availableProcessors(); /** * Creates a &#123;@link LocalStreamEnvironment&#125;. The local execution environment * will run the program in a multi-threaded fashion in the same JVM as the * environment was created in. The default parallelism of the local * environment is the number of hardware contexts (CPU cores / threads), * unless it was specified differently by &#123;@link #setParallelism(int)&#125;. * * @return A local execution environment. */ public static LocalStreamEnvironment createLocalEnvironment() &#123; return createLocalEnvironment(defaultLocalParallelism); &#125; /** * Creates a &#123;@link LocalStreamEnvironment&#125;. The local execution environment * will run the program in a multi-threaded fashion in the same JVM as the * environment was created in. It will use the parallelism specified in the * parameter. * * @param parallelism * The parallelism for the local environment. * @return A local execution environment with the specified parallelism. */ public static LocalStreamEnvironment createLocalEnvironment(int parallelism) &#123; return createLocalEnvironment(parallelism, new Configuration()); &#125; ...&#125;","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：异步IO之RichAsyncFunction","date":"2019-11-06T10:45:59.000Z","path":"2019/11/06/apache-flink:study-async-io-RichAsyncFunction/","text":"Apache Flink 学习：异步IO之RichAsyncFunction 问题设置kafka consumer并行度的语义1.如果设置kafka consumer的并发度为100，并且申请到集群中资源的Task Manager的slot个数也为100个，则每个slot中运行的任务都生成这么多数量的kafka consumer，还是每个slot一个kafka consumer? 2.场景：一个keyBy过后设置了一分钟的窗口dataStream中，如果保证每次触发这个窗口时，窗口的数据永远只有一条的话，并且在保证窗口为1分钟大小的情况下，接口返回速度保证在10秒，使用Async IO是否就没有意义了，因为当前请求队列里面只有一条数据 3.flink 默认执行一个Job的slot中线程数为什么是8，在哪里设置的 使用AsyncIO需要考虑的指标1.每个slot中Flink Job的线程数2.如果需要使用时间窗口：时间窗口的大小，几分钟的窗口2.如果需要keyBy：每个slot中Flink Job的大概key的个数（什么情况使用，什么情况不使用） 简介我们知道flink对于外部数据源的操作可以通过自带的连接器，或者自定义sink和source实现数据的交互，那么为啥还需要异步IO呢？那时因为对于实时处理，当我们需要使用外部存储数据参与计算时，与外部系统之间的交互延迟对流处理的整个工作进度起决定性的影响。如果我们是使用传统方式mapfunction等算子里访问外部存储，实际上该交互过程是同步的，比如下图中：请求a发送到数据库，那么function会一直等待响应。在很多案例中，这个等待过程是非常浪费函数时间的。 图中棕色的长条表示等待时间，可以发现网络等待时间极大地阻碍了吞吐和延迟。为了解决同步访问的问题，异步模式可以并发地处理多个请求和回复。也就是说，你可以连续地向数据库发送用户a、b、c等的请求，与此同时，哪个请求的回复先返回了就处理哪个回复，从而连续的请求之间不需要阻塞等待，如上图右边所示。这也正是 Async I/O 的实现原理。 目的将MapFunction或者FlatMapFunction中的同步访问外部存储设备的方法通过AsyncFunction替换以实现异步访问在执行过程中，如果使用了keyBy，则相同的key整个执行周期都使用同一个线程，但是不同的key也可以使用同一个线程 如何使用Async I/O我们需要自定义一个类实现RichAsyncFunction这个抽象类，实现其中的抽象方法，这点和自定义source很像。主要是的抽象方法如下，然后在asyncInvoke()使用CompletableFuture执行异步操作（CompletableFuture会提供一个ForkJoinPool作为请求线程池） 123456789public void open(Configuration parameters) throws Exception;public void close() throws Exception;void asyncInvoke(IN var1, ResultFuture&lt;OUT&gt; var2) throws Exception;default void timeout(IN input, ResultFuture&lt;OUT&gt; resultFuture) throws Exception &#123; resultFuture.completeExceptionally(new TimeoutException(&quot;Async function call has timed out.&quot;));&#125; 然后在AsyncDataStream中使用我们定义好的类，去实现主流异步的访问外部数据源 原理实现AsyncDataStream.(un)orderedWait 的主要工作就是创建了一个 AsyncWaitOperator。AsyncWaitOperator 是支持异步 IO 访问的算子实现，该算子会运行 AsyncFunction 并处理异步返回的结果，其内部原理如下图所示 如图所示，AsyncWaitOperator 主要由两部分组成：StreamElementQueue 和 Emitter。StreamElementQueue 是一个 Promise 队列，所谓 Promise 是一种异步抽象表示将来会有一个值（参考 Scala Promise 了解更多），这个队列是未完成的 Promise 队列，也就是进行中的请求队列。Emitter 是一个单独的线程，负责发送消息（收到的异步回复）给下游。 图中E5表示进入该算子的第五个元素（”Element-5”），在执行过程中首先会将其包装成一个 “Promise” P5，然后将P5放入队列。最后调用 AsyncFunction 的 ayncInvoke 方法，该方法会向外部服务发起一个异步的请求，并注册回调。该回调会在异步请求成功返回时调用 AsyncCollector.collect 方法将返回的结果交给框架处理。实际上 AsyncCollector 也一个 Promise，也就是 P5，在调用 collect 的时候会标记 Promise 为完成状态，并通知 Emitter 线程有完成的消息可以发送了。Emitter 就会从队列中拉取完成的 Promise ，并从 Promise 中取出消息发送给下游。 消息的顺序性上文提到 Async I/O 提供了两种输出模式。其实细分有三种模式: 有序，ProcessingTime 无序，EventTime 无序。Flink 使用队列来实现不同的输出模式，并抽象出一个队列的接口（StreamElementQueue），这种分层设计使得AsyncWaitOperator和Emitter不用关心消息的顺序问题。StreamElementQueue有两种具体实现，分别是 OrderedStreamElementQueue 和 UnorderedStreamElementQueue。UnorderedStreamElementQueue 比较有意思，它使用了一套逻辑巧妙地实现完全无序和 EventTime 无序 有序有序比较简单，使用一个队列就能实现。所有新进入该算子的元素（包括 watermark），都会包装成 Promise 并按到达顺序放入该队列。如下图所示，尽管P4的结果先返回，但并不会发送，只有 P1 （队首）的结果返回了才会触发 Emitter 拉取队首元素进行发送 ProcessingTime 无序ProcessingTime 无序也比较简单，因为没有 watermark，不需要协调 watermark 与消息的顺序性，所以使用两个队列就能实现，一个 uncompletedQueue 一个 completedQueue。所有新进入该算子的元素，同样的包装成 Promise 并放入 uncompletedQueue 队列，当uncompletedQueue队列中任意的Promise返回了数据，则将该 Promise 移到 completedQueue 队列中，并通知 Emitter 消费。如下图所示： EventTime 无序EventTime 无序类似于有序与 ProcessingTime 无序的结合体。因为有 watermark，需要协调 watermark 与消息之间的顺序性，所以uncompletedQueue中存放的元素从原先的 Promise 变成了 Promise 集合。如果进入算子的是消息元素，则会包装成 Promise 放入队尾的集合中。如果进入算子的是 watermark，也会包装成 Promise 并放到一个独立的集合中，再将该集合加入到 uncompletedQueue 队尾，最后再创建一个空集合加到 uncompletedQueue 队尾。这样，watermark 就成了消息顺序的边界。只有处在队首的集合中的 Promise 返回了数据，才能将该 Promise 移到 completedQueue 队列中，由 Emitter 消费发往下游。只有队首集合空了，才能处理第二个集合。这样就保证了当且仅当某个 watermark 之前所有的消息都已经被发送了，该 watermark 才能被发送。过程如下图所示： 说明1、AsyncDataStream有2个方法，unorderedWait表示数据不需要关注顺序，处理完立即发送，orderedWait表示数据需要关注顺序，为了实现该目标，操作算子会在该结果记录之前的记录为发送之前缓存该记录。这往往会引入额外的延迟和一些Checkpoint负载，因为相比于无序模式结果记录会保存在Checkpoint状态内部较长的时间。2、Timeout配置，主要是为了处理死掉或者失败的任务，防止资源被长期阻塞占用。3、最后一个参数Capacity表示同时最多有多少个异步请求在处理，异步IO的方式会导致更高的吞吐量，但是对于实时应用来说该操作也是一个瓶颈。限制并发请求数，算子不会积压过多的未处理请求，但是一旦超过容量的显示会触发背压。该参数可以不配置，但是默认是100","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Common 包学习：常用集合类Collections4学习","date":"2019-11-06T08:04:06.000Z","path":"2019/11/06/apache-common:study-apache-common-collections4/","text":"Apache Common 包学习：常用集合类Collections4学习 Maven依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CollectionUtils&lt;O&gt; Collection&lt;O&gt; subtract(final Iterable&lt;? extends O&gt; a, final Iterable&lt;? extends O&gt; b)a是做差集运算的左集，b是做差集运算的右集，下面是一个例子 1234567891011121314151617181920public class Demo &#123; private static final Logger LOGGER = LoggerFactory.getLogger(Demo.class); public static void main(String[] args) &#123; Set&lt;Pair&lt;String, String&gt;&gt; allProductDevices = Sets.newHashSet(Pair.of(&quot;a&quot;, &quot;b&quot;), Pair.of(&quot;c&quot;, &quot;d&quot;)); Set&lt;Pair&lt;String, String&gt;&gt; oldProductDevices = Sets.newHashSet(Pair.of(&quot;a&quot;, &quot;b&quot;), Pair.of(&quot;e&quot;, &quot;f&quot;)); List&lt;Pair&lt;String, String&gt;&gt; newProductDevices = (ArrayList&lt;Pair&lt;String, String&gt;&gt;) CollectionUtils.subtract(allProductDevices, oldProductDevices); List&lt;String&gt; list1 = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;); List&lt;String&gt; list2 = Lists.newArrayList(&quot;c&quot;, &quot;b&quot;); List&lt;String&gt; list3 = (ArrayList&lt;String&gt;) CollectionUtils.subtract(list1, list2); &#125;&#125;","tags":[{"name":"Apache Common包","slug":"Apache-Common包","permalink":"https://yangyichao-mango.github.io/tags/Apache-Common%E5%8C%85/"}]},{"title":"Google Guava 学习：guava cache缓存学习","date":"2019-11-06T08:03:38.000Z","path":"2019/11/06/google-guava:study-guava-cache/","text":"Google Guava 学习：guava cache缓存学习 背景缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。在日长开发有很多场合，有一些数据量不是很大，不会经常改动，并且访问非常频繁。但是由于受限于硬盘IO的性能或者远程网络等原因获取可能非常的费时。会导致我们的程序非常缓慢，这在某些业务上是不能忍的！而缓存正是解决这类问题的神器！ 正文Guava Cache与ConcurrentMap很相似，但也不完全一样。最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存 Guava Cache是在内存中缓存数据，相比较于数据库或redis存储，访问内存中的数据会更加高效。Guava官网介绍，下面的这几种情况可以考虑使用Guava Cache： 1.愿意消耗一些内存空间来提升速度。 2.预料到某些键会被多次查询。 3.缓存中存放的数据总量不会超出内存容量。 所以，可以将程序频繁用到的少量数据存储到Guava Cache中，以改善程序性能。下面对Guava Cache的用法进行详细的介绍。 Maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt; 构建缓存对象接口Cache代表缓存，它有如下方法： 1234567891011121314151617181920212223public interface Cache&lt;K, V&gt; &#123; V get(K key, Callable&lt;? extends V&gt; valueLoader) throws ExecutionException; ImmutableMap&lt;K, V&gt; getAllPresent(Iterable&lt;?&gt; keys); void put(K key, V value); void putAll(Map&lt;? extends K, ? extends V&gt; m); void invalidate(Object key); void invalidateAll(Iterable&lt;?&gt; keys); void invalidateAll(); long size(); CacheStats stats(); ConcurrentMap&lt;K, V&gt; asMap(); void cleanUp();&#125; 可以通过CacheBuilder类构建一个缓存对象，构建一个缓存对象代码如下 1234567public class StudyGuavaCache &#123; public static void main(String[] args) &#123; Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder().build(); cache.put(&quot;word&quot;,&quot;Hello Guava Cache&quot;); System.out.println(cache.getIfPresent(&quot;word&quot;)); &#125;&#125; 可以看到Cache非常类似于JDK中的Map，但是相比于Map，Guava Cache提供了很多更强大的功能 设置最大存储Guava Cache可以在构建缓存对象时指定缓存所能够存储的最大记录数量。当Cache中的记录数量达到最大值后再调用put方法向其中添加对象，Guava会先从当前缓存的对象记录中选择一条删除掉，腾出空间后再将新的对象存储到Cache中 12345678910111213public class StudyGuavaCache &#123; public static void main(String[] args) &#123; Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); System.out.println(&quot;第一个值：&quot; + cache.getIfPresent(&quot;key1&quot;)); System.out.println(&quot;第二个值：&quot; + cache.getIfPresent(&quot;key2&quot;)); System.out.println(&quot;第三个值：&quot; + cache.getIfPresent(&quot;key3&quot;)); &#125;&#125; 上面代码在构造缓存对象时，通过CacheBuilder类的maximumSize方法指定Cache最多可以存储两个对象，然后调用Cache的put方法向其中添加了三个对象。程序执行结果如下图所示，可以看到第三条对象记录的插入，导致了第一条对象记录被删除 123第一个值：null第二个值：value2第三个值：value3 设置过期时间在构建Cache对象时，可以通过CacheBuilder类的expireAfterAccess和expireAfterWrite两个方法为缓存中的对象指定过期时间，过期的对象将会被缓存自动删除。其中，expireAfterWrite方法指定对象被写入到缓存后多久过期，expireAfterAccess指定对象多久没有被访问后过期 expireAfterWrite1234567891011121314public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .expireAfterWrite(3, TimeUnit.SECONDS) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); int time = 1; while (true) &#123; System.out.println(&quot;第&quot; + time++ + &quot;次取到key1的值为：&quot; + cache.getIfPresent(&quot;key1&quot;)); Thread.sleep(1000); &#125; &#125;&#125; 上面的代码在构造Cache对象时，通过CacheBuilder的expireAfterWrite方法指定put到Cache中的对象在3秒后会过期。在Cache对象中存储一条对象记录后，每隔1秒读取一次这条记录。程序运行结果如下图所示，可以看到，前三秒可以从Cache中获取到对象，超过三秒后，对象从Cache中被自动删除 12345678第1次取到key1的值为：value1第2次取到key1的值为：value1第3次取到key1的值为：value1第4次取到key1的值为：null第5次取到key1的值为：null第6次取到key1的值为：null第7次取到key1的值为：null第8次取到key1的值为：null expireAfterAccess1234567891011121314public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .expireAfterAccess(3, TimeUnit.SECONDS) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); double time = 1.5; while (true) &#123; Thread.sleep((long) time * 1000L); System.out.println(&quot;睡眠&quot; + time++ + &quot;秒后取到key1的值为：&quot; + cache.getIfPresent(&quot;key1&quot;)); &#125; &#125;&#125; 通过CacheBuilder的expireAfterAccess方法指定Cache中存储的对象如果超过3秒没有被访问就会过期。while中的代码每sleep一段时间就会访问一次Cache中存储的对象key1，每次访问key1之后下次sleep的时间会加长一秒。程序运行结果如下图所示，从结果中可以看出，当超过3秒没有读取key1对象之后，该对象会自动被Cache删除。 123睡眠1.5秒后取到key1的值为：value1睡眠2.5秒后取到key1的值为：value1睡眠3.5秒后取到key1的值为：null 也可以同时用expireAfterAccess和expireAfterWrite方法指定过期时间，这时只要对象满足两者中的一个条件就会被自动过期删除。 弱引用可以通过weakKeys和weakValues方法指定Cache只保存对缓存记录key和value的弱引用。这样当没有其他强引用指向key和value时，key和value对象就会被垃圾回收器回收 1234567891011121314public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, Object&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .weakValues() .build(); Object value = new Object(); cache.put(&quot;key1&quot;, value); value = new Object(); // 原对象不再有强引用 System.gc(); System.out.println(cache.getIfPresent(&quot;key1&quot;)); &#125;&#125; 上面代码的打印结果是null。构建Cache时通过weakValues方法指定Cache只保存记录值的一个弱引用。当给value引用赋值一个新的对象之后，就不再有任何一个强引用指向原对象。System.gc()触发垃圾回收后，原对象就被清除了 1null 显示清除可以调用Cache的invalidateAll或invalidate方法显示删除Cache中的记录。invalidate方法一次只能删除Cache中一个记录，接收的参数是要删除记录的key。invalidateAll方法可以批量删除Cache中的记录，当没有传任何参数时，invalidateAll方法将清除Cache中的全部记录。invalidateAll也可以接收一个Iterable类型的参数，参数中包含要删除记录的所有key值。下面代码对此做了示例 123456789101112131415161718public class StudyGuavaCache &#123; public static void main(String[] args) &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(); Object value = new Object(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;key1&quot;); list.add(&quot;key2&quot;); cache.invalidateAll(list); // 批量清除list中全部key对应的记录 System.out.println(cache.getIfPresent(&quot;key1&quot;)); System.out.println(cache.getIfPresent(&quot;key2&quot;)); System.out.println(cache.getIfPresent(&quot;key3&quot;)); &#125;&#125; 代码中构造了一个集合list用于保存要删除记录的key值，然后调用invalidateAll方法批量删除key1和key2对应的记录，只剩下key3对应的记录没有被删除 123nullnullvalue3 移除监听器可以为Cache对象添加一个移除监听器，这样当有记录被删除时可以感知到这个事件 123456789101112131415161718public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; RemovalListener&lt;String, String&gt; listener = notification -&gt; System.out.println(&quot;[&quot; + notification.getKey() + &quot;:&quot; + notification.getValue() + &quot;] is removed!&quot;); Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(3) .removalListener(listener) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); cache.put(&quot;key4&quot;, &quot;value3&quot;); cache.put(&quot;key5&quot;, &quot;value3&quot;); cache.put(&quot;key6&quot;, &quot;value3&quot;); cache.put(&quot;key7&quot;, &quot;value3&quot;); cache.put(&quot;key8&quot;, &quot;value3&quot;); &#125;&#125; removalListener方法为Cache指定了一个移除监听器，这样当有记录从Cache中被删除时，监听器listener就会感知到这个事件。程序运行结果如下图所示 12345[key1:value1] is removed![key2:value2] is removed![key3:value3] is removed![key4:value3] is removed![key5:value3] is removed! 自动加载Cache的get方法有两个参数，第一个参数是要从Cache中获取记录的key，第二个记录是一个Callable对象。当缓存中已经存在key对应的记录时，get方法直接返回key对应的记录。如果缓存中不包含key对应的记录，Guava会使用当前线程执行Callable对象中的call方法，call方法的返回值会作为key对应的值被存储到缓存中，并且被get方法返回。下面是一个多线程的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StudyGuavaCache &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StudyGuavaCache.class); private static Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(1) .build(); public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; LOGGER.info(&quot;1&quot; + Thread.currentThread().getName()); try &#123; String value = cache.get(&quot;key&quot;, new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; LOGGER.info(&quot;load1&quot; + Thread.currentThread().getName()); // 加载数据线程执行标志 Thread.sleep(1000); // 模拟加载时间 return &quot;auto load by Callable1&quot;; &#125; &#125;); LOGGER.info(&quot;thread1 &quot; + value); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; LOGGER.info(&quot;thread2&quot;); try &#123; LOGGER.info(&quot;2&quot; + Thread.currentThread().getName()); String value = cache.get(&quot;key1&quot;, new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; LOGGER.info(&quot;load2&quot; + Thread.currentThread().getName()); // 加载数据线程执行标志 Thread.sleep(1000); // 模拟加载时间 return &quot;auto load by Callable2&quot;; &#125; &#125;); LOGGER.info(&quot;thread2 &quot; + value); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 这段代码中有两个线程共享同一个Cache对象，两个线程同时调用get方法获取同一个key对应的记录。由于key对应的记录不存在，所以两个线程都在get方法处阻塞。此处在call方法中调用Thread.sleep(1000)模拟程序从外存加载数据的时间消耗 1234517:49:23.965 [Thread-2] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - thread217:49:23.965 [Thread-1] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - 1Thread-117:49:23.969 [Thread-2] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - 2Thread-217:49:23.983 [Thread-1] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - load1Thread-117:49:23.983 [Thread-2] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - load2Thread-2 从结果中可以看出，虽然是两个线程同时调用get方法，但只有一个get方法中的Callable会被执行(没有打印出load2)。Guava可以保证当有多个线程同时访问Cache中的一个key时，如果key对应的记录不存在，Guava只会启动一个线程执行get方法中Callable参数对应的任务加载数据存到缓存。当加载完数据后，任何线程中的get方法都会获取到key对应的值 统计信息可以对Cache的命中率、加载数据时间等信息进行统计。在构建Cache对象时，可以通过CacheBuilder的recordStats方法开启统计信息的开关。开关开启后Cache会自动对缓存的各种操作进行统计，调用Cache的stats方法可以查看统计后的信息 123456789101112131415161718192021public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(3) .recordStats() // 开启统计信息开关 .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); cache.put(&quot;key4&quot;, &quot;value4&quot;); cache.getIfPresent(&quot;key1&quot;); cache.getIfPresent(&quot;key2&quot;); cache.getIfPresent(&quot;key3&quot;); cache.getIfPresent(&quot;key4&quot;); cache.getIfPresent(&quot;key5&quot;); cache.getIfPresent(&quot;key6&quot;); System.out.println(cache.stats()); // 获取统计信息 &#125;&#125; 程序执行结果如下所示 1CacheStats&#123;hitCount=3, missCount=3, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=1&#125; 这些统计信息对于调整缓存设置是至关重要的，在性能要求高的应用中应该密切关注这些数据 LoadingCacheLoadingCache是Cache的子接口，相比较于Cache，当从LoadingCache中读取一个指定key的记录时，如果该记录不存在，则LoadingCache可以自动执行加载数据到缓存的操作。LoadingCache接口的定义如下： 123456789101112131415public interface LoadingCache&lt;K, V&gt; extends Cache&lt;K, V&gt;, Function&lt;K, V&gt; &#123; V get(K key) throws ExecutionException; V getUnchecked(K key); ImmutableMap&lt;K, V&gt; getAll(Iterable&lt;? extends K&gt; keys) throws ExecutionException; V apply(K key); void refresh(K key); @Override ConcurrentMap&lt;K, V&gt; asMap();&#125; 与构建Cache类型的对象类似，LoadingCache类型的对象也是通过CacheBuilder进行构建，不同的是，在调用CacheBuilder的build方法时，必须传递一个CacheLoader类型的参数，CacheLoader的load方法需要我们提供实现。当调用LoadingCache的get方法时，如果缓存不存在对应key的记录，则CacheLoader中的load方法会被自动调用从外存加载数据，load方法的返回值会作为key对应的value存储到LoadingCache中，并从get方法返回 12345678910111213141516171819public class StudyGuavaCache &#123; public static void main(String[] args) throws ExecutionException &#123; CacheLoader&lt;String, String&gt; loader = new CacheLoader&lt;String, String&gt;() &#123; public String load(String key) throws Exception &#123; Thread.sleep(1000); // 休眠1s，模拟加载数据 System.out.println(key + &quot; is loaded from a cacheLoader!&quot;); return key + &quot;&#x27;s value&quot;; &#125; &#125;; LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder() .maximumSize(3) .build(loader); // 在构建时指定自动加载器 loadingCache.get(&quot;key1&quot;); loadingCache.get(&quot;key2&quot;); loadingCache.get(&quot;key3&quot;); &#125;&#125; 程序执行结果如下所示： 123key1 is loaded from a cacheLoader!key2 is loaded from a cacheLoader!key3 is loaded from a cacheLoader! 从LoadingCache查询的正规方式是使用get(K)方法。这个方法要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值（通过load(String key) 方法加载）。由于CacheLoader可能抛出异常，LoadingCache.get(K)也声明抛出ExecutionException异常。如果你定义的CacheLoader没有声明任何检查型异常，则可以通过getUnchecked(K)查找缓存；但必须注意，一旦CacheLoader声明了检查型异常，就不可以调用getUnchecked(K)。","tags":[{"name":"guava","slug":"guava","permalink":"https://yangyichao-mango.github.io/tags/guava/"}]},{"title":"apache-kafka:study-features","date":"2019-11-06T01:57:17.000Z","path":"2019/11/06/apache-kafka:study-features/","text":"如何为Kafka集群选择合适的Partitions数量越多的分区可以提供更高的吞吐量首先我们需要明白以下事实：在kafka中，单个patition是kafka并行操作的最小单元。在producer和broker端，向每一个分区写入数据是可以完全并行化的，此时，可以通过加大硬件资源的利用率来提升系统的吞吐量，例如对数据进行压缩。在consumer段，kafka只允许单个partition的数据被一个consumer线程消费。因此，在consumer端，每一个Consumer Group内部的consumer并行度完全依赖于被消费的分区数量。综上所述，通常情况下，在一个Kafka集群中，partition的数量越多，意味着可以到达的吞吐量越大。 我们可以粗略地通过吞吐量来计算kafka集群的分区数量。假设对于单个partition，producer端的可达吞吐量为p，Consumer端的可达吞吐量为c，期望的目标吞吐量为t，那么集群所需要的partition数量至少为max(t/p,t/c)。在producer端，单个分区的吞吐量大小会受到批量大小、数据压缩方法、 确认类型（同步/异步）、复制因子等配置参数的影响。经过测试，在producer端，单个partition的吞吐量通常是在10MB/s左右。在consumer端，单个partition的吞吐量依赖于consumer端每个消息的应用逻辑处理速度。因此，我们需要对consumer端的吞吐量进行测量。 虽然随着时间的推移，我们能够对分区的数量进行添加，但是对于基于Key来生成的这一类消息需要我们重点关注。当producer向kafka写入基于key的消息时，kafka通过key的hash值来确定消息需要写入哪个具体的分区。通过这样的方案，kafka能够确保相同key值的数据可以写入同一个partition。kafka的这一能力对于一部分应用是极为重要的，例如对于同一个key的所有消息，consumer需要按消息的顺序进行有序消费。如果partition的数量发生改变，那么上面的有序性保证将不复存在。为了避免上述情况发生，通常的解决办法是多分配一些分区，以满足未来的需求。通常情况下，我们需要根据未来1到2年的目标吞吐量来设计kafka的分区数量。 一开始，我们可以基于当前的业务吞吐量为kafka集群分配较小的broker数量，随着时间的推移，我们可以向集群中增加更多的broker，然后在线方式将适当比例的partition转移到新增加的broker中去。通过这样的方法，我们可以在满足各种应用场景（包括基于key消息的场景）的情况下，保持业务吞吐量的扩展性。 在设计分区数时，除了吞吐量，还有一些其他因素值得考虑。正如我们后面即将看到的，对于一些应用场景，集群拥有过的分区将会带来负面的影响。","tags":[{"name":"Apache Kafka","slug":"Apache-Kafka","permalink":"https://yangyichao-mango.github.io/tags/Apache-Kafka/"}]},{"title":"Apache Flink 学习：系统特性学习","date":"2019-11-03T08:20:21.000Z","path":"2019/11/03/apache-flink:study-features/","text":"Apache Flink 学习：系统特性学习 教程 window窗口窗口大小窗口大小是用户自己设定的，但是窗口的起始和结束时间点是系统根据窗口大小和自然数进行设定的，不会出现设置了一分钟的窗口，统计的数据是2:30到3:30的数据 [window_start_time, window_end_time)根据窗口大小和自然数进行设定 如果window大小是3秒，那么1分钟内会把window划分为如下的形式: 1234[00:00:00,00:00:03)[00:00:03,00:00:06)...[00:00:57,00:01:00) 如果window大小是10秒，则window会被分为如下的形式： 1234[00:00:00,00:00:10)[00:00:10,00:00:20)...[00:00:50,00:01:00) watermark123456789@Overridepublic final Watermark getCurrentWatermark() &#123; // this guarantees that the watermark never goes backwards. long potentialWM = currentMaxTimestamp - maxOutOfOrderness; if (potentialWM &gt;= lastEmittedWatermark) &#123; lastEmittedWatermark = potentialWM; &#125; return new Watermark(lastEmittedWatermark);&#125; watermark = max( [当前已到达的时间戳最新的数据(currentMaxTimestamp)] - [最大乱序等待时间(maxOutOfOrderness)], watermark ) 触发窗口运算条件1.当前最新数据到达进行判断：当前到达event的time(timestamp) ＜ watermark则触发，表示数据是超过了最大等待时间，已经延迟到达的，则会触发 2.当前最新数据到达进行判断：最新的watermark &gt;= window_end_time（对于out-of-order以及正常的数据而言），在[window_start_time, window_end_time)中有数据存在 3.而且，这里要强调一点，watermark和currentMaxTimestamp是一个全局的值，不是某一个key下的值，所以即使不是同一个key的数据，其warmark也会增加 语义是：currentMaxTimestamp是当前到达的最大时间戳数据，代表时间戳为currentMaxTimestamp的数据已经到达了，所以所能等待的数据的时间戳（max_out_of_orderness）只能为watermark = currentMaxTimestamp - maxOutOfOrderness 窗口计算Window reduce，Window aggregate 和 Window Fold 是增量聚合，每来一条数据就计算一次，高效 Window apply（Window process 的老版本） 和 Window process 是全量聚合，触发窗口计算时全量计算 被Keys化与非被Keys化Windows要指定的第一件事是您的流是否应该使用keyedWindow，一般都与业务逻辑有关，比如说使用一分钟的窗口进行去重。使用keyBy(…)将您的无限流分成逻辑Key化的数据流。如果keyBy(…)未调用，则表示您的流不是被Keys化的。 对于被Key化的数据流，可以将传入数据（Object）的的任何属性用作键）。拥有被Key化的数据流将允许您的窗口计算由多个任务并行执行，因为每个Key化的数据流可以独立于其余任务进行处理。引用相同Keys的所有数据将被发送到同一个并行任务进行计算。 在非被Key化的数据流的情况下，您的原始流将不会被拆分为多个逻辑流，并且所有窗口逻辑将由单个任务执行，即并行度为1。 sql1.在flinkSql中，如果使用groupBy，尽量使用窗口，否则会认为被groupBy的数据会默认人为整个窗口内的数据还没有到达，所以会一直等待，不会产出数据 update-mode: append / update 分为 update stream 模式和 append stream 模式 window聚合为append mode stream，groupby聚合为update mode stream Flink生成 Timestamps 和 Watermarks为了让event time工作，Flink需要知道事件的时间戳，这意味着流中的每个元素都需要分配其事件时间戳。这个通常是通过抽取或者访问事件中某些字段的时间戳来获取的。 时间戳的分配伴随着水印的生成，告诉系统事件时间中的进度。 这里有两种方式来分配时间戳和生成水印: 直接在数据流源中进行。 通过timestamp assigner和watermark generator生成:在Flink中，timestamp分配器也定义了用来发射的水印。 数据流源生成Timestamps和Watermarks数据流源可以直接为它们产生的数据元素分配timestamp，并且他们也能发送水印。这样做的话，就没必要再去定义timestamp分配器了，需要注意的是:如果一个timestamp分配器被使用的话，由源提供的任何timestamp和watermark都会被重写。 时间戳分配器/水印生成器（Timestamp Assigners / Watermark Generators）Timestamp分配器获取一个流并生成一个新的带有Timestamp元素和水印的流。如果原始流已经有时间戳和/或水印，则Timestamp分配程序将覆盖它们 Timestamp分配器通常在数据源之后立即指定，但这并不是严格要求的。通常是在timestamp分配器之前先解析(MapFunction)和过滤(FilterFunction)。在任何情况下，都需要在事件时间上的第一个操作(例如第一个窗口操作)之前指定timestamp分配程序。有一个特殊情况，当使用Kafka作为流作业的数据源时，Flink允许在源内部指定timestamp分配器和watermark生成器。更多关于如何进行的信息请参考Kafka Connector的文档。 直接在FlinkKafkaConsumer010上面使用assignTimestampsAndWatermarks可以根据kafka source的partitions的特性进行设置Timestamps和Watermarks，让用户做一些特殊的处理 Running timestamp extractors / watermark generators directly inside the Kafka source, per Kafkapartition, allows users to let them exploit the per-partition characteristics. logWeb UI查找logJobManger log： 展示整个作业的状态变化（例如，从create 到deploy到running再到failed），通过jobManger log可以查看作业历史失败的记录和直接原因。 TaskManager log： 调度到该TaskManager上的task 的打印的相关log。 shuffle被keyBy的数据流中，相同的key的数据会被发送到同一个slot中运行（partitiner决定），也就是TaskManager中slot进行shuffle的过程如果有多个producer并且producer的数量和partition数量相同，则每个producer写一个partition Savepoints和Checkpoints用 Data Stream API 编写的程序可以从 savepoint 继续执行。Savepoints 允许在不丢失任何状态的情况下升级程序和 Flink 集群。 Savepoints 是手动触发的 Checkpoints，它依靠常规的 Checkpoint 机制获取程序的快照并将其写入 state backend。在执行期间，程序会定期在 worker 节点上创建快照并生成 Checkpoints。对于恢复，Flink 仅需要最后完成的 Checkpoint，而一旦完成了新的 Checkpoint，旧的就可以被丢弃。 Savepoints 类似于这些定期的 Checkpoints，除了它们是由用户触发并且在新的 Checkpoints 完成时不会自动过期。你可以通过命令行 或在取消一个 job 时通过 REST API 来创建 Savepoints。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：实时场景下的应用","date":"2019-11-03T05:30:05.000Z","path":"2019/11/03/apache-flink:study-realtime-scenario/","text":"Apache Flink 学习：实时场景下的应用 用户需求场景用户想要查看 版本，机型，国家，城市 等等维度下按照分钟的时间粒度的设备活跃，新增设备数，首次活跃设备数 用户需求-&gt;架构方案设计 数据所处阶段 功能描述 数据source 各种各样的打到kafka的用户行为数据的日志 数据process 实时引擎消费kafka，根据数据服务化提供的接口判断当前用户是否是新增，活跃，首次活跃，将用户的相关数据打到下游kafka 数据sink 结果kafka olap引擎 消费sink kafka 数据产品 通过BI等的产品呈现给用户 架构设计-&gt;选择实时计算引擎为什么使用flink： A.保证消费一次：checkpoint和savepoint 容错 B.时间属性：事件，注入，处理时间 优点：事件时间的属性可以被广泛应用，比如一般的分析场景都是分析用户某个时间段的用户相关指标，而不是事件处理某个时间段的用户相关指标 flink实现方案第一种方案方案新增场景下，每消费一条source kafka用户数据就判断一次是否为新增，判断方式可以选择自己维护历史全量数据，或者使用数据服务化提供的接口，最后将结果写入sink kafka 存在的问题 数据处理阶段 问题 结果（仅仅指当前问题会产生的结果） 是否可解决 数据source 同一个用户的行为数据到达时间间隔很小，几秒内就可能会产生几十条行为日志，判断是否为新增，活跃用户时可能会被重复判断 最终数据结果＞真实结果 可部分解决 数据process 自己维护全量数据1.每判断一条就更新历史全量数据就不存在问题2.如果历史全量数据更新有问题就会产生和数据服务化一样的下面两种问题 可部分解决 数据process 数据服务化维护全量数据且更新不及时在新增的场景下，一个新增用户使用app可能会在短时间内上报成百上千条行为日志，如果第一条数据判断出来这个用户是新增，下一条数据判断时，数据服务化提供的全量用户里还没有及时将这条新增用户数据添加进去，则这条数据也会被判断为新增，就会导致最终结果重复 最终数据结果＞真实结果 可部分解决 数据process 数据服务化维护全量数据且更新过快数据服务化更新速度快于flink消费source kafka的速度：就会导致本来是新增的设备被判断不是新增，导致最终结果漏判 最终数据结果＜真实结果 暂时无法解决 解决方案后续解决方法只讨论上述可部分解决的问题 数据处理阶段 问题 解决方案 数据source 同一个用户的行为数据到达时间间隔很小，可能会被重复判断 使用flink窗口解决部分问题使用滚动窗口解决，将一段时间内的用户行为收集，然后到达窗口结束时间处理后再进行上报。假设设置一小时的窗口，则将这一小时的用户行为数据只取一条进行判断是否为新增，则可以极大的保证当前用户判断为新增时，下一小时窗口中这个用户不太可能被判断为新增了，因为数据服务化没有那么慢 数据process 数据服务化维护全量数据且更新不及时，最终结果重复 第一种方案-&gt;第二种方案方案使用窗口可以部分解决在新增活跃等场景下用户行为数据重复的问题 但是使用了窗口也会引入问题，就是虽然大窗口可以保证尽可能去重，但是数据的实时性大大降低，所以窗口设置不能大也不能小，窗口大保证不了数据产出及时性，窗口小去重效果差，所以最大窗口就为一分钟，和用户期望看板中结果一致 存在的问题 数据处理阶段 问题 结果（仅仅指当前问题会产生的结果） 是否可解决 数据source 由于用户行为数据到达source，或者从source到达process阶段，由于网络延迟等的问题，会导致处理用户数据时有乱序情况比如计算实时活跃设备，上一分钟的数据如果下一分钟才到达，则该条数据就会被上一分钟漏算 最终数据结果＜真实结果 可部分解决 数据process 解决方案 数据处理阶段 问题 解决方案 数据source 数据乱序延迟漏算 在flink窗口计算中，通过timestamp和watermark特性来尽可能解决 数据process 第二种方案-&gt;第三种方案方案设置一分钟的窗口，然后设置一分钟的最大延迟等待时间，其语义是保证数据最多延迟一分钟到达，只要可以保证这个语义可以保证最后数据的正确性","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"},{"name":"实时计算","slug":"实时计算","permalink":"https://yangyichao-mango.github.io/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"}]},{"title":"Apache Flink 学习：BoundedOutOfOrdernessTimestampExtractor","date":"2019-11-02T08:48:43.000Z","path":"2019/11/02/apache-flink:study-BoundedOutOfOrdernessTimestampExtractor/","text":"Apache Flink 学习：BoundedOutOfOrdernessTimestampExtractor 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * &quot;License&quot;); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.flink.streaming.api.functions.timestamps;import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;import org.apache.flink.streaming.api.watermark.Watermark;import org.apache.flink.streaming.api.windowing.time.Time;/** * This is a &#123;@link AssignerWithPeriodicWatermarks&#125; used to emit Watermarks that lag behind the element with * the maximum timestamp (in event time) seen so far by a fixed amount of time, &lt;code&gt;t_late&lt;/code&gt;. This can * help reduce the number of elements that are ignored due to lateness when computing the final result for a * given window, in the case where we know that elements arrive no later than &lt;code&gt;t_late&lt;/code&gt; units of time * after the watermark that signals that the system event-time has advanced past their (event-time) timestamp. * */public abstract class BoundedOutOfOrdernessTimestampExtractor&lt;T&gt; implements AssignerWithPeriodicWatermarks&lt;T&gt; &#123; private static final long serialVersionUID = 1L; /** The current maximum timestamp seen so far. */ /** 数据流的最大时间戳 */ private long currentMaxTimestamp; /** The timestamp of the last emitted watermark. */ /** 最后一次已提交的最新 [水印]（当前批次水印） */ private long lastEmittedWatermark = Long.MIN_VALUE; /** * The (fixed) interval between the maximum seen timestamp seen in the records * and that of the watermark to be emitted. * 最大乱序时间间隔 * 将要被提交的 [水印] 和 [数据流的最大时间戳] 的固定时间间隔 * 如果 [数据流的最大时间戳] - [当前批次水印] &gt; [最大乱序时间间隔] * 则就会打上一个新的 [水印] */ private final long maxOutOfOrderness; public BoundedOutOfOrdernessTimestampExtractor(Time maxOutOfOrderness) &#123; if (maxOutOfOrderness.toMilliseconds() &lt; 0) &#123; throw new RuntimeException(&quot;Tried to set the maximum allowed &quot; + &quot;lateness to &quot; + maxOutOfOrderness + &quot;. This parameter cannot be negative.&quot;); &#125; this.maxOutOfOrderness = maxOutOfOrderness.toMilliseconds(); this.currentMaxTimestamp = Long.MIN_VALUE + this.maxOutOfOrderness; &#125; public long getMaxOutOfOrdernessInMillis() &#123; return maxOutOfOrderness; &#125; /** * Extracts the timestamp from the given element. * 从当前数据流元素中获取 [时间戳] 字段，需要用户根据业务自定义 * * @param element The element that the timestamp is extracted from. * @return The new timestamp. */ public abstract long extractTimestamp(T element); /** * 如果 [当前数据流最大时间戳] - [最大乱序时间间隔] &gt;= [最后一次已提交的时间戳] * 则更新 [最后一次已提交的时间戳] */ @Override public final Watermark getCurrentWatermark() &#123; // this guarantees that the watermark never goes backwards. long potentialWM = currentMaxTimestamp - maxOutOfOrderness; if (potentialWM &gt;= lastEmittedWatermark) &#123; lastEmittedWatermark = potentialWM; &#125; return new Watermark(lastEmittedWatermark); &#125; /** * 获取数据流中当前最大时间戳 */ @Override public final long extractTimestamp(T element, long previousElementTimestamp) &#123; long timestamp = extractTimestamp(element); if (timestamp &gt; currentMaxTimestamp) &#123; currentMaxTimestamp = timestamp; &#125; return timestamp; &#125;&#125; ****12345678910111213141516171819/** * Sets the time characteristic for all streams create from this environment, e.g., processing * time, event time, or ingestion time. * * &lt;p&gt;If you set the characteristic to IngestionTime of EventTime this will set a default * watermark update interval of 200 ms. If this is not applicable for your application * you should change it using &#123;@link ExecutionConfig#setAutoWatermarkInterval(long)&#125;. * * @param characteristic The time characteristic. */@PublicEvolvingpublic void setStreamTimeCharacteristic(TimeCharacteristic characteristic) &#123; this.timeCharacteristic = Preconditions.checkNotNull(characteristic); if (characteristic == TimeCharacteristic.ProcessingTime) &#123; getConfig().setAutoWatermarkInterval(0); &#125; else &#123; getConfig().setAutoWatermarkInterval(200); &#125;&#125; window触发机制window的触发机制，是先按照自然时间将window划分，如果window大小是3秒，那么1分钟内会把window划分为如下的形式: 1234[00:00:00,00:00:03)[00:00:03,00:00:06)...[00:00:57,00:01:00) 如果window大小是10秒，则window会被分为如下的形式： 1234[00:00:00,00:00:10)[00:00:10,00:00:20)...[00:00:50,00:01:00)","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Hadoop 学习：hdfs shell 命令","date":"2019-10-30T08:27:45.000Z","path":"2019/10/30/apache-hadoop:study-hdfs-shell/","text":"Apache Hadoop 学习：hdfs shell 命令 ls1hdfs dfs -ls / put1hadoop fs -put localfile /user/hadoop/hadoopfile get1hadoop fs -get /user/hadoop/hadoopfile localfile","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"},{"name":"Hdfs","slug":"Hdfs","permalink":"https://yangyichao-mango.github.io/tags/Hdfs/"}]},{"title":"Mac安装Nginx-1.17.3以及相关配置文件","date":"2019-10-28T13:19:10.000Z","path":"2019/10/28/nginx:1-17-3-mac-install-and-confs-set/","text":"Mac安装Nginx-1.17.3以及相关配置文件 安装1brew install nginx 配置nginx是一个功能非常强大的web服务器加反向代理服务器，同时又是邮件服务器等等 在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器 这三个不同的功能的使用，都跟nginx的配置密切相关，nginx服务器的配置信息主要集中在nginx.conf这个配置文件中，并且所有的可配置选项大致分为以下几个部分 123456789101112131415161718192021222324252627282930313233343536main # 全局配置events &#123; # nginx工作模式配置&#125;http &#123; # http设置 .... server &#123; # 服务器主机配置 .... location &#123; # 路由配置 .... &#125; location path &#123; .... &#125; location otherpath &#123; .... &#125; &#125; server &#123; .... location &#123; .... &#125; &#125; upstream name &#123; # 负载均衡配置 .... &#125;&#125; 如上述配置文件所示，主要由6个部分组成： 1.main：用于进行nginx全局信息的配置2.events：用于nginx工作模式的配置3.http：用于进行http协议信息的一些配置4.server：用于进行服务器访问信息的配置5.location：用于进行访问路由的配置6.upstream：用于进行负载均衡的配置 main模块1234567# user nobody nobody;worker_processes 2;# error_log logs/error.log# error_log logs/error.log notice# error_log logs/error.log info# pid logs/nginx.pidworker_rlimit_nofile 1024; 上述配置都是存放在main全局配置模块中的配置项 1.user：用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行2.worker_processes：指定nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍3.error_log：定义错误日志文件的位置及输出级别【debug / info / notice / warn / error / crit】4.pid：用来指定进程id的存储文件的位置5.worker_rlimit_nofile：用于指定一个进程可以打开最多文件数量的描述 events模块12345events &#123; worker_connections 1024; multi_accept on; use epoll;&#125; 上述配置是针对nginx服务器的工作模式的一些操作配置 1.worker_connections：指定最大可以同时接收的连接数量，这里一定要注意，最大连接数量是和worker processes共同决定的2.multi_accept：配置指定nginx在收到一个新连接通知后尽可能多的接受更多的连接3.use epoll：配置指定了线程轮询的方法，如果是linux2.6+，使用epoll，如果是BSD如Mac请使用Kqueue http模块作为web服务器，http模块是nginx最核心的一个模块，配置项也是比较多的，项目中会设置到很多的实际业务场景，需要根据硬件信息进行适当的配置，常规情况下，使用默认配置即可！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354http &#123; ## # 基础配置 ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL证书配置 ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # 日志配置 ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip 压缩配置 ## gzip on; gzip_disable &quot;msie6&quot;; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # 虚拟主机配置 ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125; 基础配置1.sendfile on：配置on让sendfile发挥作用，将文件的回写过程交给数据缓冲去去完成，而不是放在应用中完成，这样的话在性能提升有有好处2.tc_nopush on：让nginx在一个数据包中发送所有的头文件，而不是一个一个单独发3.tcp_nodelay on：让nginx不要缓存数据，而是一段一段发送，如果数据的传输有实时性的要求的话可以配置它，发送完一小段数据就立刻能得到返回值，但是不要滥用哦 4.keepalive_timeout 10：给客户端分配连接超时时间，服务器会在这个时间过后关闭连接。一般设置时间较短，可以让nginx工作持续性更好5.client_header_timeout 10：设置请求头的超时时间6.client_body_timeout 10：设置请求体的超时时间7.send_timeout 10：指定客户端响应超时时间，如果客户端两次操作间隔超过这个时间，服务器就会关闭这个链接 8.limit_conn_zone $binary_remote_addr zone=addr:5m ：设置用于保存各种key的共享内存的参数，9.limit_conn addr 100: 给定的key设置最大连接数 10.server_tokens：虽然不会让nginx执行速度更快，但是可以在错误页面关闭nginx版本提示，对于网站安全性的提升有好处哦11.include /etc/nginx/mime.types：指定在当前文件中包含另一个文件的指令12.default_type application/octet-stream：指定默认处理的文件类型可以是二进制13.type_hash_max_size 2048：混淆数据，影响三列冲突率，值越大消耗内存越多，散列key冲突率会降低，检索速度更快；值越小key，占用内存较少，冲突率越高，检索速度变慢 日志1.access_log logs/access.log：设置存储访问记录的日志2.error_log logs/error.log：设置存储记录错误发生的日志 压缩配置1.gzip：是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量。2.gzip_disable：为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。3.gzip_static：告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。4.gzip_proxied：允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。5.gzip_min_length：设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。6.gzip_comp_level：设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。7.gzip_type：设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。 文件缓存配置1.open_file_cache：打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。2.open_file_cache_valid：在open_file_cache中指定检测正确信息的间隔时间。3.open_file_cache_min_uses：定义了open_file_cache中指令参数不活动时间期间里最小的文件数。4.open_file_cache_errors：指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。 server模块server模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息 12345678910server &#123; listen 80; server_name localhost 192.168.1.100; root /nginx/www; index index.php index.html index.html; charset utf-8; access_log logs/access.log; error_log logs/error.log; ......&#125; 核心配置信息如下： 1.server：一个虚拟主机的配置，一个http中可以配置多个server 2.server_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔 3.root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录 4.index：用户访问web网站时的全局首页 5.charset：用于设置www/路径中配置的网页的默认编码格式 6.access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径 7.error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径 location模块location模块是nginx配置中出现最多的一个配置，主要用于配置路由访问信息 在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location模块也是一个非常重要的配置模块 基本配置1234location / &#123; root /nginx/www; index index.php index.html index.htm;&#125; location /：表示匹配访问根目录 root：用于指定访问根目录时，访问虚拟主机的web目录 index：在不指定访问具体资源时，默认展示的资源文件列表 反向代理配置方式通过反向代理代理服务器访问模式，通过proxy_set配置让客户端访问透明化 12345location / &#123; proxy_pass http://localhost:8888; proxy_set_header X-real-ip $remote_addr; proxy_set_header Host $http_host;&#125; uwsgi配置wsgi模式下的服务器配置访问方式 1234location / &#123; include uwsgi_params; uwsgi_pass localhost:8888&#125; upstream模块upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器 简单的配置方式如下 12345678upstream name &#123; ip_hash; server 192.168.1.100:8000; server 192.168.1.100:8001 down; server 192.168.1.100:8002 max_fails=3; server 192.168.1.100:8003 fail_timeout=20s; server 192.168.1.100:8004 max_fails=3 fail_timeout=20s;&#125; 核心配置信息如下 1.ip_hash：指定请求调度算法，默认是weight权重轮询调度，可以指定 2.server host:port：分发服务器的列表配置 – down：表示该主机暂停服务 – max_fails：表示失败最大次数，超过失败最大次数暂停服务 – fail_timeout：表示如果请求受理失败，暂停指定的时间之后重新发起请求","tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://yangyichao-mango.github.io/tags/Nginx/"}]},{"title":"Elastic-Job学习：分布式任务调度框架","date":"2019-10-26T14:08:15.000Z","path":"2019/10/26/elastic-job:study-distributed-scheduled-job-framework/","text":"分布式任务调度框架学习 官方文档 elastic-job github","tags":[{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"},{"name":"分布式调度框架","slug":"分布式调度框架","permalink":"https://yangyichao-mango.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yangyichao-mango.github.io/tags/SpringBoot/"}]},{"title":"Vue学习：Vue前端项目部署到SpringBoot工程下","date":"2019-10-26T07:29:37.000Z","path":"2019/10/26/vue:study-vue-project-deploy-in-springboot-project/","text":"Vue项目部署到SpringBoot工程下 Vue前端项目1npm run build 运行上述命令，将前端Vue项目打包，命令运行完成之后会在项目根目录下生成一个生成一个dist文件夹, 编译好的静态文件就在这里面 部署在SpringBoot项目下将前端项目中dist文件夹下的所有文件拷贝到SpringBoot工程的src/main/resources/static文件夹下 运行后端项目，可以看到控制台会有这样的输出，证明将静态页面加入了容器中，现在就可以访问到前端页面了 12019-10-26 15:47:09.607 INFO 1967 --- [ main] o.s.b.a.w.s.WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yangyichao-mango.github.io/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"https://yangyichao-mango.github.io/tags/Vue/"}]},{"title":"Maven学习：使用maven-shade-plugin解决依赖包冲突","date":"2019-10-25T06:23:20.000Z","path":"2019/10/25/apache-maven:study-maven-shade-resolve-jar-conflicts/","text":"java 依赖包冲突，使用maven-shade-plugin解决 错误场景详情1java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor; 错误原因出现这样的错误详情一般是由于有下面这样的包依赖情况 12A - B - C(guava version 18) \\ D - C(guava version 23.6-jre) A：代表我们所开发的当前项目B和D：代表当前项目所依赖的项目C：代表当前项目依赖的项目所依赖的项目 由于我们当前所开发的项目A依赖了B和D，B和D又依赖了项目C我们打包运行项目时，maven只会将一个版本C(guava)打进包内（maven打包遇到相同依赖，最短路径优先，在路径相同时先在pom中声明优先）比如此时打进包的版本是C(guava version 23.6-jre)，那么很有可能在运行B中的一个方法时，调用C的一个方法，这个方法是C(guava version 18)中的一个方法，在C(guava version 23.6-jre)中并不存在，这时候就会报出java.lang.NoSuchMethodError 解决方案使用maven-shade-plugin将所有B项目依赖的包全部打进B.jar中，并且给guava包的路径重命名为我们的自定义路径\\ maven-shade-plugin基本功能maven-shade-plugin提供了两大基本功能： 1、将依赖的jar包打包到当前jar包（常规打包是不会将所依赖jar包打进来的）2、对依赖的jar包进行重命名（用于类的隔离，解决包冲突就是使用了这个功能） 解决示例如下例，就可以在B项目中使用C(guava version 18)，只不过import路径变成了我们自定的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;RpcModule&lt;/groupId&gt; &lt;artifactId&gt;RpcModule&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;RpcModule&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;guava.version&gt;18&lt;/guava.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;$&#123;guava.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;configuration&gt; &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;!-- 给guava包的路径重命名为我们的自定义路径 --&gt; &lt;configuration&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;com.google.guava&lt;/pattern&gt; &lt;shadedPattern&gt;shade.com.google.guava&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;relocation&gt; &lt;pattern&gt;org.joda&lt;/pattern&gt; &lt;shadedPattern&gt;shade.com.google.joda&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;relocation&gt; &lt;pattern&gt;com.google.common&lt;/pattern&gt; &lt;shadedPattern&gt;shade.com.google.common&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;/relocations&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;/&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 使用maven-shade-plugin之前 12345678910import Entity.Request;import Entity.Response;import java.io.*;import java.net.Socket;import com.google.common.collect.ImmutableMap;public class SocketClient &#123;&#125; 使用maven-shade-plugin之后编译后反编译结果 12345678910import Entity.Request;import Entity.Response;import java.io.*;import java.net.Socket;import shade.com.google.common.collect.ImmutableMap;public class SocketClient &#123;&#125; 最后将打好的包上传至我们的maven仓库，然后再在当前项目A中依赖，就没有依赖冲突了 12A - B - C(guava version 18, shade.com.google.common.collect.ImmutableMap) \\ D - C(guava version 23.6-jre, com.google.common.collect.ImmutableMap) 这样就可以做到将两个不同版本的包都引入使用，由于引入包路径不同，因此也没有冲突","tags":[{"name":"Apache Maven","slug":"Apache-Maven","permalink":"https://yangyichao-mango.github.io/tags/Apache-Maven/"}]},{"title":"Apache Zookeeper 学习：Zookeeper实现统一配置管理中心","date":"2019-10-24T10:40:24.000Z","path":"2019/10/24/apache-zookeeper:study-zookeeper-implement-unified-configuration-management-center/","text":"Apache Zookeeper 学习：模拟三台节点组成的Zookeeper集群实现的统一配置管理中心 模拟Zookeeper集群架构图 创建zookeeper集群节点模拟三台节点组成的zookeeper集群，需要在本机zookeeper目录下创建三个zookeeper集群节点配置文件 1234$ cd conf/$ cp zoo_sample.cfg zoo1.cfg$ cp zoo_sample.cfg zoo2.cfg$ cp zoo_sample.cfg zoo3.cfg 创建所配置的各个文件夹123456789$ mkdir /tmp/zookeeper1$ mkdir /tmp/zookeeper1/data$ mkdir /tmp/zookeeper1/dataLog$ mkdir /tmp/zookeeper2$ mkdir /tmp/zookeeper2/data$ mkdir /tmp/zookeeper2/dataLog$ mkdir /tmp/zookeeper3$ mkdir /tmp/zookeeper3/data$ mkdir /tmp/zookeeper3/dataLog /tmp/zookeeperX/data文件夹下创建myid文件123$ echo 1 &gt; /tmp/zookeeper1/data/myid$ echo 2 &gt; /tmp/zookeeper2/data/myid$ echo 3 &gt; /tmp/zookeeper3/data/myid 配置zookeeper节点信息zoo1.cfg 1234567891011121314151617181920212223242526272829303132333435# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper1/datadataLogDir=/tmp/zookeeper1/dataLog# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1# 格式:server.num=xxxx:port1:port2# num对应myid中的内容，port1是zookeeper集群中各服务间的通信端口，port2是zookeeper集群选举leader的端口server.1=localhost:2888:3888server.2=localhost:2899:3899server.3=localhost:2877:3877 zoo2.cfg 1234567891011# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper2/datadataLogDir=/tmp/zookeeper2/dataLog# the port at which the clients will connectclientPort=2182...server.1=localhost:2888:3888server.2=localhost:2899:3899server.3=localhost:2877:3877 zoo3.cfg 1234567891011# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper3/datadataLogDir=/tmp/zookeeper3/dataLog# the port at which the clients will connectclientPort=2183...server.1=localhost:2888:3888server.2=localhost:2899:3899server.3=localhost:2877:3877 配置文件中dataDir，dataLogDir，clientPort，三个zookeeper节点配置信息都不同搭建zookeeper集群，需要在每个zookeeper安装目录下的data文件中创建名为myid的文件，修改zooX.cfg内容如下： 123server.1=xxx:2888:3888server.2=xxx:2899:3899server.3=xxx:2877:3877 格式:server.num=xxxx:port1:port2num对应myid中的内容，port1是zookeeper集群中各服务间的通信端口，port2是zookeeper集群选举leader的端口 启动模拟集群节点123456789101112$ ./zkServer.sh start ../conf/zoo1.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo1.cfgStarting zookeeper ... STARTED$ ./zkServer.sh start ../conf/zoo2.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo2.cfgStarting zookeeper ... STARTED$ ./zkServer.sh start ../conf/zoo3.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo3.cfgStarting zookeeper ... STARTED 查看集群状态 123456789101112$ ./zkServer.sh status ../conf/zoo1.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo1.cfgMode: follower$ ./zkServer.sh status ../conf/zoo2.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo2.cfgMode: leader$ ./zkServer.sh status ../conf/zoo3.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo3.cfgMode: follower 创建zookeeper集群client创建监听节点变化的server（zookeeper集群client）模拟监听节点变化server，启动两个BaseWatcher程序作为监听server（对zookeeper集群来说是client） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class BaseWatcher implements Watcher &#123; private static ZooKeeper zookeeper; /** * 超时时间 */ private static final int SESSION_TIME_OUT = 2000; private static CountDownLatch defaultCountDownLatch = new CountDownLatch(1); private static CountDownLatch childrenCountDownLatch = new CountDownLatch(1); private static CountDownLatch dataCountDownLatch = new CountDownLatch(1); @Override public void process(WatchedEvent event) &#123; if (event.getState() == KeeperState.SyncConnected) &#123; LOGGER.info(&quot;Watch received event&quot;); defaultCountDownLatch.countDown(); &#125; if (event.getType() == EventType.NodeCreated) &#123; LOGGER.info(&quot;创建节点&quot;); &#125; if (event.getType() == EventType.NodeDataChanged) &#123; LOGGER.info(&quot;节点改变&quot;); &#125; if (event.getType() == EventType.NodeChildrenChanged) &#123; LOGGER.info(&quot;子节点节点改变&quot;); &#125; if (event.getType() == EventType.NodeDeleted) &#123; LOGGER.info(&quot;节点删除&quot;); &#125; &#125; /** * 连接zookeeper * @param host * @throws Exception */ public static void connectZookeeper(String host, Watcher defaultWatcher) throws Exception &#123; zookeeper = new ZooKeeper(host, SESSION_TIME_OUT, defaultWatcher); defaultCountDownLatch.await(); LOGGER.info(&quot;zookeeper connection success&quot;); &#125; /** * 获取路径下所有子节点 * @param path * @return * @throws KeeperException * @throws InterruptedException */ public static List&lt;String&gt; getChildren(String path, Watcher childrenWatcher) throws KeeperException, InterruptedException &#123; return zookeeper.getChildren(path, childrenWatcher); &#125; /** * 获取节点上面的数据 * @param path 路径 * @return * @throws KeeperException * @throws InterruptedException */ public static String getData(String path, Watcher dataWatcher) throws KeeperException, InterruptedException &#123; byte[] data = zookeeper.getData(path, dataWatcher, null); if (data == null) &#123; return &quot;&quot;; &#125; return new String(data); &#125; /** * 关闭连接 * @throws InterruptedException */ public static void closeConnection() throws InterruptedException &#123; if (zookeeper != null) &#123; zookeeper.close(); &#125; &#125; private static final String HOST = &quot;localhost:2181,localhost:2182,localhost:2183&quot;; private static final Logger LOGGER = LoggerFactory.getLogger(BaseWatcher.class); public static void main(String[] args) throws Exception &#123; /** * 运行程序之前需要启动zookeeper服务端，&#123;@link BaseWatcher.HOST&#125; 根据zookeeper服务端具体配置去修改 * * 除了默认watcher外其他watcher一旦触发就会失效，需要充新注册，本示例中因为 * 还未想到比较好的重新注册watcher方式(考虑到如果在Watcher中持有一个zk客户端的 * 实例可能存在循环引用的问题)，因此暂不实现watcher失效后重新注册watcher的问题， * 后续可以查阅curator重新注册watcher的实现方法。 */ BaseWatcher defaultWatcher = new BaseWatcher(); // 连接zookeeper并设置一个默认的watcher监听zookeeper文件节点的变化 connectZookeeper(HOST, defaultWatcher); TimeUnit.SECONDS.sleep(1000000); &#125;&#125; 创建改变节点数据的server（zookeeper集群client）如果一个节点向被监听节点中写数据，其他节点就会接受到zookeeper的 NodeDataChanged event 模拟改变数据server，启动一个BaseWatcher程序作为改变数据server（对zookeeper集群来说是client） 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; /** * 运行程序之前需要启动zookeeper服务端，&#123;@link BaseWatcher.HOST&#125; 根据zookeeper服务端具体配置去修改 * * 除了默认watcher外其他watcher一旦触发就会失效，需要充新注册，本示例中因为 * 还未想到比较好的重新注册watcher方式(考虑到如果在Watcher中持有一个zk客户端的 * 实例可能存在循环引用的问题)，因此暂不实现watcher失效后重新注册watcher的问题， * 后续可以查阅curator重新注册watcher的实现方法。 */ BaseWatcher defaultWatcher = new BaseWatcher(); // 连接zookeeper并设置一个默认的watcher监听zookeeper文件节点的变化 connectZookeeper(HOST, defaultWatcher); // 向/GetChildren节点写数据之前需要先创建此文件夹 // 向/GetChildren节点写数据，则监听程序就会收到zookeeper的 [NodeDataChanged] event setData(&quot;/GetChildren&quot;, &quot;8&quot;); TimeUnit.SECONDS.sleep(1000000);&#125; 运行结果两个监听程序收到zookeeper的 NodeDataChanged event，log如下 123411:24:27.295 [main-SendThread(localhost:2183)] DEBUG org.apache.zookeeper.ClientCnxn - Got notification sessionid:0x300001251b5000311:24:27.297 [main-SendThread(localhost:2183)] DEBUG org.apache.zookeeper.ClientCnxn - Got WatchedEvent state:SyncConnected type:NodeDataChanged path:/GetChildren for sessionid 0x300001251b5000311:24:27.297 [main-EventThread] INFO com.github.xxx.bigdata.demo.zookeeper.BaseWatcher - Watch received event11:24:27.297 [main-EventThread] INFO com.github.xxx.bigdata.demo.zookeeper.BaseWatcher - 节点改变","tags":[{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"Apache Druid 学习：组件以及查询类型","date":"2019-10-22T02:40:12.000Z","path":"2019/10/22/apache-druid:study-components-and-query-types/","text":"Apache Druid 学习：组件以及查询类型 OLAP基本概念维度(Dimension): 指的是观察数据的一个角度，是考虑问题的一类属性，这些属性的集合统称为一个维。维的级别(Level): 对数据的观察还存在细节程度的不同，在druid中一般表示为时间的粒度(granularity)，比如一秒，一分钟，一小时，一天…… 度量(Measure): 度量是用来聚合分析计算的数字信息，在druid中称为”metrics”，它可以是存储在数据库中，也可以是通过策略计算得出的。比如一篇文章的点击数、或者是根据评论数、点击数、转发数计算出的热点值 对于数据处理向下钻取(Drill-down)/上卷(Roll-up): 改变维的层次和级别，变换分析的粒度。Roll-up在于提升维的级别（或者称粒度）或者减少维度来聚合数据，展现总览，Drill-down反之，降低维的级别(或者称粒度)或增加维度来查看细节切片(slice)和切块(dice): 当维度为两个时，我们对获取数据(查询)的操作称之为切片，当维度的数量大于两个时，我们称之为切块旋转(Pivoting): 变换维的方向，例如表格中的行列互换 查询条件参数 字段名 描述 是否必须 queryType 查询类型，对应聚合查询下的类型值：timeseries、topN、groupBy等 是 dataSource 数据源，类似关系数据库中表的概念，对应数据导入时Json配置属性dataSource值 是 descending 返回结果是否逆序，默认值为否（正序） 否 intervals 查询时间区间 是 filter 对Dimension进行过滤，可以根据情况对几个维度组合不同的filter类型(and、or、not、bound)，还可以根据需要定义javascript function进行过滤 否 aggregations 指定度量在聚合时候的计算策略，例如相加、或者求平均值、又或者取最后一个值，在内置类型不满足的情况下可以使用javascript。比如某手游中我统计了我每一局击杀小怪数量，以及野怪的数量，通过聚合策略sum，我能知道我从开号以来击杀了多少小怪和野怪。 否 postAggregations 后聚合策略，提供了多个度量组合生成新度量的能力，主要有利于聚合计算的抽象，避免对一些指标的重复计算。举个例子，假如我需要一个度量，是我击杀小怪和野怪的总和，那么，我只需要在后聚合阶段计算，只需要拿小怪和野怪的数量相加一次，大大地提高了计算效率。 否 granularity 查询的时间粒度，最细粒度为秒，最大粒度为all，提供了时间维度级别的调整并对数据进行上卷和向下钻取的能力 是 dimensionSpec 提供了维度在聚合前输出展示值定制的能力，比如在Dimension age一列中，拿到的是字符串类型的数字，我希望转成数字类型，又或者定制一个javascript function，统一以 ${age} year old的形式展现 否 limit 返回结果数量限制 否 context 表示对当前查询本身的一些配置，比如设置查询超时的时间，又比如是否使用缓存，在通用的配置基础上，每种查询类型还有特定的配置，详见文档 否 基本组件filter过滤器，在查询语句中是一个json对象，用来对维度进行筛选，表示满足filter的是我们需要的数据。类似于SQL中的where。 类型 功能 SelectorFilter 功能类似于SQL中的where key=value AndFilter, OrFilter, NotFilter 功能类似于SQL中and、or、not三种过滤器。支持递归嵌套，可以构造出丰富的逻辑表达式 RegexFilter 正则表达式，支持任意维度值的java正则 SearchFilter 通过字符串匹配维度，支持多种表达式 InFilter 功能类似于SQL中where key in (value1, value2) IntervalFilter 针对于时间维度过滤 BoundFilter 功能类似于SQL中的大于、小于、等于三种算子 JavaScriptFilter 上述filter均不能满足可以自己写JavaScript来过滤维度 aggregator聚合可以在采集数据时规格部分的一种方式，汇总数据进入Druid之前提供。聚合也可以被指定为在查询时多查询的部分，聚合类型如下： 类型 功能 CountAggregator SQL count(key) SumAggregator SQL sum(key) MaxAggregator, MinAggregator SQL max(key), min(key) DistinctCountAggregator SQL count(distinct key) JavaScriptAggregator 上述aggregator均不能满足可以自己写JavaScript来定义计算 post-aggregator 类型 功能 ArithmeticPostAggregator 支持对聚合后指标进行”+ - * / quotient”计算 FieldAccessPostAggregator 直接获取聚合的字段（维度，指标） ConstantPostAggregator 返回常数 JavaScriptPostAggregator 上述postAggregator均不能满足可以自己写JavaScript来定义计算 查询类型聚合查询timeseries时序查询，实际上即是对数据基于时间点(timestamp)的一次上卷。适合用来看某几个度量在一个时间段内的趋势。排序可按时间降序或升序 字段名 描述 是否必须 queryType 查询类型，必须为 “timeseries” 是 dataSource 数据源，比如 “wikipedia” 是 descending 返回结果是否逆序，默认值为否（正序） 否 intervals 查询时间区间 是 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 aggregations 否 postAggregations 否 limit 否 context 否 context： 1.grandTotal 2.零填充如果时间范围内没有值，则会填充0时间序列查询通常用零填充空的内部时间段。例如，如果您对间隔2012-01-01 / 2012-01-04发出“天”粒度时间序列查询，而2012-01-02没有数据存在，您将收到： 1234567891011121314[ &#123; &quot;timestamp&quot;: &quot;2012-01-01T00:00:00.000Z&quot;, &quot;result&quot;: &#123; &quot;sample_name1&quot;: &lt;some_value&gt; &#125; &#125;, &#123; &quot;timestamp&quot;: &quot;2012-01-02T00:00:00.000Z&quot;, &quot;result&quot;: &#123; &quot;sample_name1&quot;: 0 &#125; &#125;, &#123; &quot;timestamp&quot;: &quot;2012-01-03T00:00:00.000Z&quot;, &quot;result&quot;: &#123; &quot;sample_name1&quot;: &lt;some_value&gt; &#125; &#125;] topN在时间点的基础上，又增加了一个维度(OLAP的概念算两个维度)，进而对源数据进行切片，切片之后分别上卷，最后返回一个聚合集，你可以指定某个指标作为排序的依据。官方文档称这对比单个druid dimension 的groupBy 更高效。适合看某个维度下的时间趋势，（比如美国和中国十年内GDP的增长趋势比对，在这里除了时间外国家就是另外一个维度） 字段名 描述 是否必须 queryType 查询类型，必须为 “topN” 是 dataSource 数据源，比如 “wikipedia” 是 intervals 查询时间区间 是 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 aggregations 否 postAggregations 否 dimension 除了时间之外聚合的维度，只能定义一个维度 是 threshold topN中的N，例如：希望查询到top2，则值为2 是 metric topN中用来排序的指标 是 context 否 groupBy适用于两个维度以上的查询，druid会根据维度切块，并且分别上卷，最后返回聚合集。相对于topN而言，这是一个向下钻取的操作，每多一个维度意味着保留更多的细节。(比如增加一个行业的维度，就可以知道美国和中国十年内，每一年不同行业贡献GDP的占比)注意：如果要使用时间作为唯一分组进行聚合，或者在单个维度上使用有序groupBy进行聚合，请优先考虑使用Timeseries和TopN查询。在某些情况下，它们的性能可能会更好。有关更多详细信息，请参见下面的替代方法。 字段名 描述 是否必须 queryType 查询类型，必须为 “groupBy” 是 dataSource 数据源，比如 “wikipedia” 是 dimensions 需要聚合的所有维度 是 limitSpec 同关系型数据库中的limit 否 having 同关系型数据库中的having 否 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 aggregations 否 postAggregations 否 intervals 查询时间区间 是 subtotalsSpec 类似于的grouping sets 否 context 否 普通查询select类似SQL中的select操作，select用来查看Druid中存储的数据，并支持按照指定过滤器和时间查看指定维度和指标。不支持aggregations和post aggregations 注意：建议您尽可能使用scan查询类型而不是select。在涉及大量segment的情况下，select查询可能具有很高的内存和性能开销，但是scan查询没有此问题。两者之间的主要区别是“扫描”查询不支持分页。但是，即使没有分页，scan查询类型也能够返回几乎无限数量的结果，使得分页在许多情况下是不必要的。 字段名 描述 是否必须 queryType 查询类型，必须为 “select” 是 dataSource 数据源，比如 “wikipedia” 是 intervals 查询时间区间 是 descending 返回结果是否逆序，默认值为否（正序） 否 filter 否 dimensions 需要查询的维度列表 否 metrics 需要查询的指标列表 否 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块，默认是Granularity.ALL 否 pagingSpec 分页 是 context 否 scan扫描查询以流模式返回行，Select查询和Scan查询之间的最大区别是，Scan查询子返回给客户端数据之前不会将所有行数据保留在内存中而select查询将把行保留在内存中，如果返回太多行，则会导致内存压力。扫描查询可以返回所有行，而无需发出另一个分页查询。 除了将scan查询发送给server的用法外，还可以直接向historical历史记录进程或streaming ingestion流式提取任务发出扫描查询。如果要并行检索大量数据，这将很有用。 字段名 描述 是否必须 queryType 查询类型，必须为 “scan” 是 dataSource 数据源，比如 “wikipedia” 是 intervals 查询时间区间 是 resultFormat 返回结果类型：list，compactedList或valueVector。目前仅list和compactedList受支持。默认是list 否 filter 否 columns 需要scan的维度和指标，默认为所有 否 batchSize 返回数据之前默认缓存最多多少行 否 limit 查询返回最大的数据条目，如果不指定，则返回所有的数据 否 order 返回数据的order，基于timestamp，并且只有__time被包含在columns中才生效 否 legacy 否 context 否 search类似SQL中的Like操作，但是支持更多的匹配操作 字段名 描述 是否必须 queryType 查询类型，必须为 “search” 是 dataSource 数据源，比如 “wikipedia” 是 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 limit 每个历史进程的最大查询返回数据条目（默认是1000） 否 intervals 查询时间区间 是 searchDimensions 需要search的维度（默认是所有维度），key like value中的key 否 query search维度需要匹配的value，key like value中的value 是 sort 指定应如何对搜索结果进行排序，包括字典编排（默认排序），字母数字，strlen和数字排序 否 context 否 元数据查询time boundingsegment metadatadataSource metadata","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"}]},{"title":"Apache Druid 学习：kafka to druid","date":"2019-10-21T07:08:45.000Z","path":"2019/10/21/apache-druid:study-kafka-to-druid/","text":"Apache Druid 学习：kafka to druid demo Druid Web操作官网教程 Java Demo","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"},{"name":"Apache Kafka","slug":"Apache-Kafka","permalink":"https://yangyichao-mango.github.io/tags/Apache-Kafka/"}]},{"title":"Mac安装Apache Druid-0.16.0-incubating","date":"2019-10-21T06:21:53.000Z","path":"2019/10/21/apache-druid:0.16.0-incubating-mac-install/","text":"Mac安装Apache Druid-0.16.0-incubating教程 安装参考官网教程 brew安装1brew install druid quer 下载安装123$ curl https://www-us.apache.org/dist/incubator/druid/0.16.0-incubating/apache-druid-0.16.0-incubating-bin.tar.gz$ tar -xzf apache-druid-0.16.0-incubating-bin.tar.gz$ cd apache-druid-0.16.0-incubating 配置启动启动druid服务之前需要先启动zookeeper，下面有两种方式启动和使用zookeeper 使用集成zookeeper1234$ cd $DRUID_HOME // 需要在~/.bash_profile中进行配置$ curl https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz -o zookeeper-3.4.14.tar.gz$ tar -xzf zookeeper-3.4.14.tar.gz$ mv zookeeper-3.4.14 zk 使用外部zookeeper修改 $DRUID_HOME/conf/supervise/single-server/micro-quickstart.conf 中的配置将 !p10 zk bin/run-zk conf 注释掉 123456789101112131415$ vi $DRUID_HOME/conf/supervise/single-server/micro-quickstart.conf:verify bin/verify-java:verify bin/verify-default-ports:kill-timeout 10# !p10 zk bin/run-zk conf // 这里是运行集成zookeeper的代码，所以要注释掉coordinator-overlord bin/run-druid coordinator-overlord conf/druid/single-server/micro-quickstartbroker bin/run-druid broker conf/druid/single-server/micro-quickstartrouter bin/run-druid router conf/druid/single-server/micro-quickstarthistorical bin/run-druid historical conf/druid/single-server/micro-quickstart!p90 middleManager bin/run-druid middleManager conf/druid/single-server/micro-quickstart# Uncomment to use Tranquility Server#!p95 tranquility-server tranquility/bin/tranquility server -configFile conf/tranquility/wikipedia-server.json -Ddruid.extensions.loadList=[] 修改 $DRUID_HOME/conf/druid/single-server/micro-quickstart/_common/common.runtime.properties 中的配置修改zookeeper的client配置 1234567$ vim $DRUID_HOME/conf/druid/single-server/micro-quickstart/_common/common.runtime.properties# 配置外部zookeeper的信息# zookeeper，大概在46~55行中间，对zk进行配置# zookeeper的server运行在2181端口上druid.zk.service.host=127.0.0.1:2181druid.zk.paths.base=/druid 修改 $DRUID_HOME/bin/verify-default-ports 中的配置因为使用了外部zookeeper，并且外部zookeeper的ip:port为127.0.0.1:2181所以需要将zookeeper的2181端口删除，否则会校验本机2181端口是否被占用，因为本机zookeeper已经将其占用，则会报错，服务不能启动如果使用的zookeeper的不在本机部署，则可以不注释2181 12345$ vi $DRUID_HOME/bin/verify-default-ports# my @ports = (1527, 2181, 8081, 8082, 8083, 8090, 8091, 8200, 9095);my @ports = (1527, 8081, 8082, 8083, 8090, 8091, 8200, 9095); 启动服务1$ ./bin/start-micro-quickstart 可以到http://localhost:8888查看是否启动成功","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"},{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"Apache Flink 学习：hbase作为sink","date":"2019-10-20T06:27:49.000Z","path":"2019/10/20/apache-flink:study-hbase-sink/","text":"Apache Flink 学习：hbase作为sink的demo 依赖项1234567891011&lt;properties&gt; &lt;hbase.version&gt;2.0.5&lt;/hbase.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;$&#123;hbase.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; demo代码使用了hbase作为source，hbase作为sink 运行之前需要运行hadoop集群（zookeeper集群），hbase集群flink根据部署的集群信息（比如zookeeper的ip:port为127.0.0.1:2181等的信息）去连接hbase hbase-site.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Autogenerated by Cloudera Manager--&gt;&lt;configuration&gt; &lt;!-- zk configuration --&gt; &lt;property&gt; &lt;name&gt;zookeeper.session.timeout&lt;/name&gt; &lt;value&gt;60000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;zookeeper.znode.parent&lt;/name&gt; &lt;value&gt;/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;127.0.0.1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt; &lt;value&gt;2181&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; HBaseReaderHBase作为source 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class HBaseReader extends RichSourceFunction&lt;String&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(HBaseReader.class); private transient HBaseClient hBaseClient; private static final String DEFAULT_HBASE_SOURCE_TABLE_NAME = &quot;student&quot;; private static final String DEFAULT_HBASE_SOURCE_START_ROW = &quot;row1&quot;; private static final String DEFAULT_HBASE_SOURCE_STOP_ROW = &quot;row1&quot;; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; hBaseClient = new HBaseClient(); hBaseClient.initialize(); &#125; &#125; &#125; &#125; @Override public void run(SourceContext&lt;String&gt; ctx) throws Exception &#123; List&lt;byte[]&gt; results = hBaseClient.scan( DEFAULT_HBASE_SOURCE_TABLE_NAME , DEFAULT_HBASE_SOURCE_START_ROW , DEFAULT_HBASE_SOURCE_STOP_ROW); results.forEach(result -&gt; ctx.collect(new String(result))); &#125; @Override public void cancel() &#123; if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; try &#123; hBaseClient.destroy(); &#125; catch (IOException e) &#123; LOGGER.error(&quot;&quot;, e); &#125; &#125; &#125; &#125; &#125;&#125; HBaseWriterHBase作为sink 12345678910111213141516171819202122232425262728293031323334353637383940414243public static class HBaseWriter extends RichSinkFunction&lt;Tuple2&lt;String, Integer&gt;&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(HBaseWriter.class); private transient HBaseClient hBaseClient; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; hBaseClient = new HBaseClient(); hBaseClient.initialize(); &#125; &#125; &#125; &#125; @Override public void invoke(Tuple2&lt;String, Integer&gt; value, Context context) throws IOException &#123; String result = value.toString(); Put put = hBaseClient.createPut(&quot;row2&quot;); hBaseClient.addValueOnPut(put, &quot;description&quot;, &quot;age&quot;, &quot;19&quot;); hBaseClient.put(&quot;student&quot;, put); &#125; @Override public void close() throws Exception &#123; super.close(); if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; try &#123; hBaseClient.destroy(); &#125; catch (IOException e) &#123; LOGGER.error(&quot;&quot;, e); &#125; &#125; &#125; &#125; &#125;&#125; 定义dag12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; final SourceFunction&lt;String&gt; source; final ParameterTool params = ParameterTool.fromArgs(args); /******************************* hbase source *******************************/ source = new HBaseReader(); /******************************* define dag *******************************/ // create the environment to create streams and configure execution final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // make parameters available in the web interface env.getConfig().setGlobalJobParameters(params); DataStream&lt;String&gt; sentenceStream = env.addSource(source); DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCountStream = sentenceStream .flatMap(new LineSplitter()) .keyBy(0) .sum(1); /******************************* hbase sink *******************************/ wordCountStream.addSink(new HBaseWriter()); wordCountStream.print(); env.execute(&quot;Java hbase Word Count&quot;);&#125; 查看hbase文件12345678910hbase(main):001:0&gt; scan &#x27;student&#x27;ROW COLUMN+CELL row1 column=description:age, timestamp=1571460125600, value=18 row1 column=description:name, timestamp=1571460129987, value=li u # 记录以及被写入hbase row2 column=description:age, timestamp=1571576517072, value=192 row(s) in 0.2010 secondshbase(main):002:0&gt; 发现columnFamilyName为description，columnName为age，rowkey为row2，value为19的记录已经被写入hbase","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"},{"name":"Apache HBase","slug":"Apache-HBase","permalink":"https://yangyichao-mango.github.io/tags/Apache-HBase/"}]},{"title":"Mac安装Apache Zookeeper-3.4.12","date":"2019-10-20T03:23:17.000Z","path":"2019/10/20/apache-zookeeper:3.4.12-mac-install/","text":"Mac安装Apache Zookeeper-3.4.12教程 安装安装方式1-brew安装1$ brew install zookeeper 安装方式2-下载压缩包从此地址下载http://mirrors.hust.edu.cn/apache/zookeeper/stable/ 解压配置文件 1234$ tar -zxvf zookeeper-3.4.12.tar.gz // 解压$ cd zookeeper-3.4.12/conf // 切换到配置目录下$ mv zoo_sample.cfg zoo.cfg // 更改默认配置文件名称$ vi zoo.cfg // 编辑配置文件，自定义dataDir 启动启动sever端切换到bin目录 1234567891011$ pwd/user/local/Celler/zookeeper/3.4.12/bin$ lsREADME.txt zkCli.cmd zkEnv.cmd zkServer.cmd zookeeper.outzkCleanup.sh zkCli.sh zkEnv.sh zkServer.sh$ ./zkServer.sh startZooKeeper JMX enabled by defaultUsing config: /user/local/Celler/zookeeper/3.4.12/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 启动client端12345678910111213141516171819./zkCli.sh -server 127.0.0.1:2181Connecting to 127.0.0.1:21812019-10-20 12:17:25,861 [myid:] - INFO [main:Environment@100] - Client environment:zookeeper.version=3.4.12-e5259e437540f349646870ea94dc2658c4e44b3b, built on 03/27/2018 03:55 GMT2019-10-20 12:17:25,864 [myid:] - INFO [main:Environment@100] - Client environment:host.name=localhost2019-10-20 12:17:25,864 [myid:] - INFO [main:Environment@100] - Client environment:java.version=1.8.0_1912019-10-20 12:17:25,866 [myid:] - INFO [main:Environment@100] - Client environment:java.vendor=Oracle Corporation2019-10-20 12:17:25,866 [myid:] - INFO [main:Environment@100] - Client environment:java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre2019-10-20 12:17:25,868 [myid:] - INFO [main:ZooKeeper@441] - Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@799f7e29Welcome to ZooKeeper!2019-10-20 12:17:25,896 [myid:] - INFO [main-SendThread(127.0.0.1:2181):ClientCnxn$SendThread@1028] - Opening socket connection to server 127.0.0.1/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)JLine support is enabled2019-10-20 12:17:25,959 [myid:] - INFO [main-SendThread(127.0.0.1:2181):ClientCnxn$SendThread@878] - Socket connection established to 127.0.0.1/127.0.0.1:2181, initiating session2019-10-20 12:17:25,966 [myid:] - INFO [main-SendThread(127.0.0.1:2181):ClientCnxn$SendThread@1302] - Session establishment complete on server 127.0.0.1/127.0.0.1:2181, sessionid = 0x10000112e160008, negotiated timeout = 30000WATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: 127.0.0.1:2181(CONNECTED) 0] ls /[zookeeper, hbase] 停止server端1234&gt; ./zkServer.sh stop //停止后，如果CLi没有关闭，将报错ZooKeeper JMX enabled by defaultUsing config: zookeeper-3.4.12/bin/../conf/zoo.cfgStopping zookeeper ... STOPPED 配置文件123456789101112131415161718192021222324252627282930# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes. # 内存数据快照的保存目录；如果没有自定义Log也使用该目录dataDir=/tmp/zookeeper# the port at which the clients will connect# zookeeper服务端的端口，客户端启动时需要连接的端口clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1","tags":[{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"Apache Flink 学习：hdfs作为sink","date":"2019-10-19T11:33:38.000Z","path":"2019/10/19/apache-flink:study-hdfs-sink/","text":"Apache Flink 学习：hdfs作为source和sink的demo 依赖项1234567891011&lt;properties&gt; &lt;flink.version&gt;1.9.0&lt;/flink.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-filesystem_2.12&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt; demo代码使用了kafka作为source，hdfs作为sink运行之前需要运行kafka集群，hadoop集群（zookeeper集群） 123456789101112131415161718192021222324/******************************* define dag *******************************/// create the environment to create streams and configure executionfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();// make parameters available in the web interfaceenv.getConfig().setGlobalJobParameters(params);DataStream&lt;String&gt; sentenceStream = env.addSource(source);DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCountStream = sentenceStream .flatMap(new LineSplitter()) .keyBy(0) .sum(1);wordCountStream.print();DataStream&lt;String&gt; kafkaSinkStream = wordCountStream .map(new WordBuilder());/******************************* hdfs sink *******************************/BucketingSink&lt;String&gt; bucketingSink = new BucketingSink&lt;&gt;(&quot;/user/xxx/flink/from-kafka&quot;); //hdfs上的路径bucketingSink.setWriter(new StringWriter&lt;&gt;()) .setBatchSize(1024 * 1024L) .setBatchRolloverInterval(2000) .setInactiveBucketThreshold(1000);kafkaSinkStream.addSink(bucketingSink); 上面例子将创建一个 Sink，写入遵循下面格式的分桶文件中： 1/base/path/&#123;date-time&#125;/_part-&#123;parallel-task&#125;-&#123;count&#125; date-time：是从setBucketer()自定义的日期/时间格式的字符串，如果不进行设置，默认Bucketer是DateTimeBucketer，默认值是yyyy-MM-dd–HH（DateTimeBucketer.DEFAULT_FORMAT_STRING） _part-{parallel-task}-{count}： 1234567891011121314151617private static final String DEFAULT_VALID_PREFIX = &quot;_&quot;;private static final String DEFAULT_PART_PREFIX = &quot;part&quot;;private static final String DEFAULT_PENDING_SUFFIX = &quot;.pending&quot;;private void openNewPartFile(Path bucketPath, BucketState&lt;T&gt; bucketState) throws Exception &#123; Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter); Path inProgressPath = getInProgressPathFor(partPath);&#125;private Path assemblePartPath(Path bucket, int subtaskIndex, int partIndex) &#123; String localPartSuffix = partSuffix != null ? partSuffix : &quot;&quot;; return new Path(bucket, String.format(&quot;%s-%s-%s%s&quot;, partPrefix, subtaskIndex, partIndex, localPartSuffix));&#125;private Path getInProgressPathFor(Path path) &#123; return new Path(path.getParent(), inProgressPrefix + path.getName()).suffix(inProgressSuffix);&#125; 查看hdfs文件1234567891011$ ./hdfs dfs -ls /user/xxx/flink/from-kafka/2019-10-19--192019-10-19 20:08:31,244 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 15 items-rw-r--r-- 1 xxx supergroup 4 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-0-0.pending-rw-r--r-- 1 xxx supergroup 2 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-1-0.pending-rw-r--r-- 1 xxx supergroup 5 2019-10-19 19:44 /user/xxx/flink/from-kafka/2019-10-19--19/_part-2-0.pending-rw-r--r-- 1 xxx supergroup 11 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-2-1.pending-rw-r--r-- 1 xxx supergroup 10 2019-10-19 19:44 /user/xxx/flink/from-kafka/2019-10-19--19/_part-3-0.pending-rw-r--r-- 1 xxx supergroup 13 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-3-1.pending-rw-r--r-- 1 xxx supergroup 9 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-4-0.pending-rw-r--r-- 1 xxx supergroup 10 2019-10-19 19:44 /user/xxx/flink/from-kafka/2019-10-19--19/_part-5-0.pending","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"},{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"}]},{"title":"Mac安装Apache HBase-1.3.5","date":"2019-10-18T15:14:59.000Z","path":"2019/10/18/apache-hbase:1.3.5-mac-install/","text":"Mac安装Apache HBase-1.3.5教程 HBase安装1$ brew install hbase 安装在/usr/local/Cellar/hbase/1.3.5 HBase配置hbase-env.sh在conf/hbase-env.sh设置JAVA_HOME 1234$ cd /usr/local/Cellar/hbase/1.3.5/libexec/conf$ vim hbase-env.shexport JAVA_HOME=&quot;$(/usr/libexec/java_home --version 1.8)&quot; Apache HBase-1.3.5中JAVA_HOME已经默认被配置好了如果JAVA_HOME没有配置好，则需要设置JAVA_HOME，可以通过下面的命令查看JAVA_HOME 12$ /usr/libexec/java_home/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home hbase-site.xml在conf/hbase-site.xml设置HBase的核心配置 1234567891011121314$ vim hbase-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; // 这里设置让HBase存储文件的地方 &lt;value&gt;file:///usr/local/Cellar/hbase/tmp/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; // 这里设置让HBase存储内建zookeeper文件的地方 &lt;value&gt;/usr/local/Cellar/hbase/tmp/zookeeper&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动HBase/usr/local/Cellar/hbase/1.3.5/bin/start-hbase.sh提供HBase的启动 12$ ./start-hbase.shstarting master, logging to /usr/local/var/log/hbase/hbase-xxx-master-xxx.local.out 验证是否安装成功12345$ jps722 Launcher1142 HMaster726 Launcher1256 Jps 启动HBase Shell1234567$ ./hbase shell2019-10-19 11:58:34,879 WARN [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableHBase Shell; enter &#x27;help&lt;RETURN&gt;&#x27; for list of supported commands.Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase ShellVersion 1.3.5, rb59afe7b1dc650ff3a86034477b563734e8799a9, Wed Jun 5 15:57:14 PDT 2019hbase(main):001:0&gt; 停止HBase运行12$ ./stop-hbase.shstopping hbase............... 伪分布式模式必须先关闭HBase 修改hbase-env.sh1HBASE_MANAGE_ZK = true 修改hbase-site.xml设置HBase使用分布式模式运行 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; // Here you have to set the path where you want HBase to store its files. &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hbase.rootdir路径一定要跟hadoop中core-site.xml中fs.default.name相同 change the hbase.rootdir from the local filesystem to the address of your HDFS instance —offical quick start 如何两处设置不同会引起ERROR: Can’t get master address from ZooKeeper; znode data == null错误错误 在启动HBase之前, 请先启动Hadoop, 使之运行 123456789101112131415161718$ ./start-hbase.shlocalhost: starting zookeeper, logging to /usr/local/var/log/hbase/hbase-xxx-zookeeper-xxx.local.outstarting master, logging to /usr/local/var/log/hbase/hbase-xxx-master-xxx.local.outstarting regionserver, logging to /usr/local/var/log/hbase/hbase-xxx-1-regionserver-xxx.local.out$ jps #验证是否启动成功, 包含HMaster和HRegionServer说明启动成功5614 HRegionServer2222 NameNode722 Launcher2323 DataNode5461 HMaster726 Launcher2650 ResourceManager2747 NodeManager2459 SecondaryNameNode5405 HQuorumPeer2855726 Jps 查看hdfs中文件夹 123456$ ./hdfs dfs -ls /2019-10-19 12:39:03,895 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 3 itemsdrwxr-xr-x - xxx supergroup 0 2019-10-19 12:38 /hbasedrwxrwxr-x - xxx supergroup 0 2019-10-17 14:41 /tmpdrwxr-xr-x - xxx supergroup 0 2019-10-17 11:44 /user HBase Shell123456789101112131415161718192021222324252627$ hbase shell #启动HBase Shell# 创建表&gt; create &#x27;student&#x27;, &#x27;description&#x27;, &#x27;course&#x27; #创建表名为student的表, 指明两个列名, 分别为description和course# 信息明细&gt; list &#x27;student&#x27; #列出list表信息# 插入数据# 意思为在student表row1处插入description:age的数据为18# rowKey为row1，columnFamilyName为description，columnName为age&gt; put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;description:age&#x27;, &#x27;18&#x27;&gt; put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;description:name&#x27;, &#x27;liu&#x27;&gt; put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;course:chinese&#x27;, &#x27;100&#x27;# 一次扫描所有数据&gt; scan &#x27;student&#x27;# 使表失效 / 有效&gt; disable &#x27;student&#x27;&gt; enable &#x27;student&#x27;# 删除表(要先disable)&gt; drop &#x27;student&#x27;# 退出shell&gt; quit","tags":[{"name":"Apache HBase","slug":"Apache-HBase","permalink":"https://yangyichao-mango.github.io/tags/Apache-HBase/"},{"name":"Mac安装","slug":"Mac安装","permalink":"https://yangyichao-mango.github.io/tags/Mac%E5%AE%89%E8%A3%85/"}]},{"title":"IntelliJ IDEA 中如何查看一个类的所有继承关系","date":"2019-10-18T06:09:17.000Z","path":"2019/10/18/idea-mac:show-class-hierarchy/","text":"IntelliJ IDEA 中如何查看一个类的所有继承关系，包括父类与子类 查看方式IntelliJ IDEA 中最上端的Navigate，下拉选择Type Hierarchy，就会出现层级关系列表 关于该类的父类和子类继承关系 关于该类的父类继承关系 关于该类的子类继承关系","tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://yangyichao-mango.github.io/tags/IntelliJ-IDEA/"}]},{"title":"Apache Hive环境搭建错误：java.lang.IllegalArgumentException: java.net.URISyntaxException:...","date":"2019-10-17T07:44:01.000Z","path":"2019/10/17/apache-hive:error-URISyntaxException:Relative-path-in-absolute-URI:{system:java.io.tmpdir}{system-user-name}/","text":"出现错误：Exception in thread “main” java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D 错误场景详情1234567891011121314151617181920212223$ $HIVE_HOME/bin/hiveHive Session ID = 41e2ad09-81b3-4700-9b87-f42b25a29731Logging initialized using configuration in jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/hive-common-3.1.2.jar!/hive-log4j2.properties Async: trueException in thread &quot;main&quot; java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D at org.apache.hadoop.fs.Path.initialize(Path.java:263) at org.apache.hadoop.fs.Path.&lt;init&gt;(Path.java:221) at org.apache.hadoop.hive.ql.session.SessionState.createSessionDirs(SessionState.java:710) at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:627) at org.apache.hadoop.hive.ql.session.SessionState.beginStart(SessionState.java:591) at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:747) at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:683) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:323) at org.apache.hadoop.util.RunJar.main(RunJar.java:236)Caused by: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D at java.net.URI.checkPath(URI.java:1823) at java.net.URI.&lt;init&gt;(URI.java:745) at org.apache.hadoop.fs.Path.initialize(Path.java:260) ... 12 more 错误原因hive-site.xml里的临时目录没有设置好，一共有三个 1234567891011121314151617&lt;property&gt; &lt;name&gt;Hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;$&#123;system:Java.io.tmpdir&#125;/$&#123;system:user.name&#125;&lt;/value&gt; &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;$&#123;system:Java.io.tmpdir&#125;/$&#123;system:user.name&#125;/operation_logs&lt;/value&gt; &lt;description&gt;Top level directory where operation logs are stored if logging functionality is enabled&lt;/description&gt;&lt;/property&gt; 解决方案将hive-site.xml文件中的${system:java.io.tmpdir}替换为hive的临时目录例如我替换为/usr/local/Cellar/hive/tmp，该目录如果不存在则要自己手工创建，并且赋予读写权限 1234567891011121314151617&lt;property&gt; &lt;name&gt;Hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hive/tmp&lt;/value&gt; &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hive/tmp/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hive/tmp/root/operation_logs&lt;/value&gt; &lt;description&gt;Top level directory where operation logs are stored if logging functionality is enabled&lt;/description&gt;&lt;/property&gt;","tags":[{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Mac安装Apache Hive-3.2.1","date":"2019-10-17T06:58:34.000Z","path":"2019/10/17/apache-hive:3.1.2-mac-install/","text":"Mac安装Apache Hive-3.2.1教程 安装Hadoop下载包进行安装，则hadoop需要独立安装 安装Hivebrew安装1$ brew install hive 此命令会把hive依赖的hadoop安装，所以就不需要单独进行安装hadoop该命令默认安装的版本较新，我的hive是3.1.2，hadoop是3.2.1，安装位置：/usr/local/Cellar/hive/ 环境变量修改12345$ vim ~/.bash_profileexport HIVE_HOME=/usr/local/Cellar/hive/3.1.2export PATH=&quot;$HIVE_HOME/bin:$PATH&quot;$ source ~/.bash_profile 使用mysql作为hive元数据存储在mysql中为hive 创建用户，及初始化数据库以下在mysql 中操作，注意：这里创建的用户名是 hadoop， 密码 mysql第一行：创建数据库第二、三行 创建用户，赋予权限第四行 权限生效 1234create database hive;CREATE USER &#x27;hadoop&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mysql&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;hadoop&#x27;@&#x27;%&#x27; WITH GRANT OPTION;flush privileges; 查看权限是否已经存储 1SELECT * FROM mysql.user; 修改配置文件hive-site.xml修改hive配置文件，我的配置文件位置在 /usr/local/Cellar/hive/3.1.2/libexec/conf如果不存在hive-site.xml文件，则使用下面这个命令创建一个默认的hive-site.xml 1$ cp hive-default.xml.template hive-site.xml 修改配置文件 123456789101112131415161718&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;mysql&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;mysql &lt;value&gt;jdbc:mysql://localhost:3306/hive&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; javax.jdo.option.ConnectionUserName – 连接mysql的账号，hadoopjavax.jdo.option.ConnectionPassword – 连接mysql的密码，mysqljavax.jdo.option.ConnectionURL – 对应上一步创建的数据库，localhost:3306/hive hadoop中创建hive所需仓库1234$ $HADOOP_HOME/bin/hadoop fs -mkdir /tmp$ $HADOOP_HOME/bin/hadoop fs -mkdir -p /user/hive/warehouse$ $HADOOP_HOME/bin/hadoop fs -chmod g+w /tmp$ $HADOOP_HOME/bin/hadoop fs -chmod g+w /user/hive/warehouse $HADOOP_HOME – 代表您的hadoop工作目录 hive初始化mysql中的数据库hive命令1$ $HIVE_HOME/bin/schematool -dbType msyql -initSchema 可能出现错误1：java.lang.NoSuchMethodError: com.google.common…解决方案：java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument 可能出现错误2：java.lang.ClassNotFoundException: com.mysql…解决方案：java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 启动Hive的Metastore Server服务进程1$ $HIVE_HOME/bin/hive --service metastore &amp; 登录hive客户端命令1$ $HIVE_HOME/bin/ hive 可能出现的错误1：java.lang.IllegalArgumentException: java.net.URISyntaxException:…解决方案：Exception in thread “main” java.lang.IllegalArgumentException: java.net.URISyntaxException:","tags":[{"name":"Mac安装","slug":"Mac安装","permalink":"https://yangyichao-mango.github.io/tags/Mac%E5%AE%89%E8%A3%85/"},{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Apache Hive环境搭建错误：com.mysql.jdbc.Driver was not found in the CLASSPATH","date":"2019-10-17T06:35:11.000Z","path":"2019/10/17/apache-hive:error-ClassNotFoundException:com.mysql.jdbc.driver/","text":"Apache Hive环境搭建错误：com.mysql.jdbc.Driver was not found in the CLASSPATH 错误场景详情12345678910111213$ $HIVE_HOME/bin/schematool -dbType mysql -initSchemaSLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Metastore connection URL: jdbc:mysql://localhost:3306/hive?characterEncoding=UTF-8Metastore Connection Driver : com.mysql.jdbc.DriverMetastore connection User: hadooporg.apache.hadoop.hive.metastore.HiveMetaException: Failed to load driverUnderlying cause: java.lang.ClassNotFoundException : com.mysql.jdbc.DriverUse --verbose for detailed stacktrace.*** schemaTool failed *** 错误原因在配置hive-site.xml文件时配置了mysql驱动，而hive/lib目录下没有mysql驱动包。 解决方案官网下载mysql驱动下载地址 (https://dev.mysql.com/downloads/connector/j/)把下载好的压缩包（mysql-connector-java-8.0.18.zip）进行解压unzip mysql-connector-java-8.0.18.zip复制到hive/lib下cp mysql-connector-java-8.0.18/mysql-connector-java-8.0.18.jar hive/lib","tags":[{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Apache Hive环境搭建错误：java.lang.NoSuchMethodError: com.google.common...","date":"2019-10-17T06:14:27.000Z","path":"2019/10/17/apache-hive:error-NoSuchMethodError:com.google.common.base.Preconditions.checkArgument/","text":"Apache Hive环境搭建错误：java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument 错误场景详情12345678910111213141516171819202122$ $HIVE_HOME/bin/schematool -dbType mysql -initSchemaSLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.mapred.JobConf.setJar(JobConf.java:536) at org.apache.hadoop.mapred.JobConf.setJarByClass(JobConf.java:554) at org.apache.hadoop.mapred.JobConf.&lt;init&gt;(JobConf.java:448) at org.apache.hadoop.hive.conf.HiveConf.initialize(HiveConf.java:5141) at org.apache.hadoop.hive.conf.HiveConf.&lt;init&gt;(HiveConf.java:5104) at org.apache.hive.beeline.HiveSchemaTool.&lt;init&gt;(HiveSchemaTool.java:96) at org.apache.hive.beeline.HiveSchemaTool.main(HiveSchemaTool.java:1473) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:323) at org.apache.hadoop.util.RunJar.main(RunJar.java:236) 错误原因这是因为hive内依赖的guava.jar和hadoop内的版本不一致造成的。 解决方案查看hadoop安装目录下share/hadoop/common/lib内guava.jar版本查看hive安装目录下lib内guava.jar的版本，如果两者不一致，删除版本低的，并拷贝高版本的，问题解决！","tags":[{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Apache Hadoop错误：Unable to load native-hadoop library for your platform","date":"2019-10-17T03:34:57.000Z","path":"2019/10/17/apache-hadoop:error-unable-to-load-native-hadoop-library-from-you-platform/","text":"Apache Hadoop错误：Unable to load native-hadoop library for your platform 错误场景详情12$ hadoop fs -ls /WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 错误原因Hadoop是使用Java语言开发的,但是有一些需求和操作并不适合使用java所以会引入了本地库（Native Libraries）的概念，通过本地库，Hadoop可以更加高效地执行某一些操作.当我们在linux 输入 hdoop fs -ls / 去查看 hdfs 文件系统上的资源时会出现下面错误 解决方案解决方案1在Hadoop的配置文件core-site.xml中可以设置是否使用本地库：（Hadoop默认的配置为启用本地库） 12345&lt;property&gt; &lt;name&gt;hadoop.native.lib&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;description&gt;Should native hadoop libraries, if present, be used.&lt;/description&gt;&lt;/property&gt; 解决方案2有博客说可以直接下载编译好的位包，替换原来的native包由于在我本地安装的Apache Hadoop 3.2.1版本中没有找到lib文件夹，所以在3.2.1版本中暂时不能使用此种方法 执行查看文件命令 1234$ hadoop fs -ls /2019-10-17 11:33:09,369 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 1 itemsdrwxr-xr-x - xxx supergroup 0 2019-10-17 11:23 /tmp","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"}]},{"title":"Mac安装Apache Hadoop-3.2.1","date":"2019-10-17T02:12:31.000Z","path":"2019/10/17/apache-hadoop:3.2.1-mac-install/","text":"Mac安装Apache hadoop-3.2.1教程 Java环境配置安装Java，查看Java版本以测试是否安装成功1234$ java -versionjava version &quot;1.8.0_191&quot;Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 查看Java安装位置信息，之后配置Hadoop运行环境需要使用12$ /usr/libexec/java_home/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home ssh配置配置ssh12$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys$ chmod 0600 ~/.ssh/authorized_keys 创建ssh公钥如果没有ssh公钥，执行以下命令创建 1$ ssh-keygen -t rsa 开启远程登录 测试远程登录是否开启1$ ssh localhost 安装hadoopbrew安装hadoopbrew安装的一般都是最新的hadoop，我这里是hadoop 3.2.1 如果需要安装其他版本的hadoop，通过brew安装指定版本的软件进行安装 123456$ brew install hadoopUpdating Homebrew...==&gt; Downloading https://www.apache.org/dyn/closer.cgi?path=hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz==&gt; Downloading from http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz######################################################################## 100.0%🍺 /usr/local/Cellar/hadoop/3.2.1: 21,686 files, 774.1MB, built in 10 minutes 1 second 注意上面的下载信息中 默认brew是会从apache官方的镜像中下载 1==&gt; Downloading https://www.apache.org/dyn/closer.cgi?path=hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz 如果下载很慢，可以配置国内镜像进行下载(清华大学开源软件镜像站) 1==&gt; Downloading from http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz 安装完之后查看hadoop安装位置 1234567891011121314151617$ brew info hadoophadoop: stable 3.2.1Framework for distributed processing of large data setshttps://hadoop.apache.org/Conflicts with: yarn (because both install `yarn` binaries)/usr/local/Cellar/hadoop/hdfs (20 files, 1MB) Built from source/usr/local/Cellar/hadoop/3.2.1 (22,408 files, 815.8MB) Built from source on 2019-10-17 at 09:46:37From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/hadoop.rb==&gt; RequirementsRequired: java &gt;= 1.8 ✔==&gt; Analyticsinstall: 4,572 (30 days), 10,774 (90 days), 44,762 (365 days)install_on_request: 3,822 (30 days), 9,128 (90 days), 38,206 (365 days)build_error: 0 (30 days) 配置hadoop需要修改的配置文件都在/usr/local/Cellar/hadoop/3.2.1/libexec/etc/hadoop这个目录下 hadoop-env.sh配置 export JAVA_HOME 将/usr/libexec/java_home查到的 Java 路径配置进去，记得去掉注释 #。 1export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home core-site.xml修改core-site.xml 文件参数,配置NameNode的主机名和端口号 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hadoop/hdfs/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml变量dfs.replication指定了每个HDFS数据库的复制次数。 通常为3, 由于我们只有一台主机和一个伪分布式模式的DataNode，将此值修改为1 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 格式化格式化hdfs操作只要第一次才使用，否则会造成数据全部丢失 1$ hdfs namenode -format 启动服务启动服务 1$ ./start-all.sh 启动成功后，可以在http://localhost:9870/http://localhost:8088/cluster进行查看 关闭服务 1$ ./stop-all.sh","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"},{"name":"Mac安装","slug":"Mac安装","permalink":"https://yangyichao-mango.github.io/tags/Mac%E5%AE%89%E8%A3%85/"}]},{"title":"useful-api-for-java","date":"2019-10-16T02:16:10.000Z","path":"2019/10/16/java-api:useful-api/","text":"API Retrofit（http请求工具包） Resilience4j（接口重试，限流，熔断器工具）","tags":[{"name":"Java Api","slug":"Java-Api","permalink":"https://yangyichao-mango.github.io/tags/Java-Api/"}]},{"title":"Apache Flink 零基础入门（四）：DataStream API 编程 学习心得","date":"2019-10-15T07:57:16.000Z","path":"2019/10/15/apache-flink:study-4-datastream-api/","text":"学习心得 DataStreamRichParallelSourceFunction用户通过实现SourceFunction自定义DataSource 如果设置了并行度，则会产生指定并行度个数的DataSource消费客户端去消费DataSource 1StreamExecutionEnvironment.setParallelism(int) 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class GroupedProcessingTimeWindow &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GroupedProcessingTimeWindow.class); private static class DataSource extends RichParallelSourceFunction&lt;Tuple2&lt;String, Integer&gt;&gt; &#123; private volatile boolean isRunning = true; @Override public void run(SourceContext&lt;Tuple2&lt;String, Integer&gt;&gt; ctx) throws Exception &#123; Random random = new Random(); while (isRunning) &#123; TimeUnit.MILLISECONDS.sleep((getRuntimeContext().getIndexOfThisSubtask() + 1) * 1000 * 5); String key = &quot;类别&quot; + (char) (&#x27;A&#x27; + random.nextInt(3)); int value = random.nextInt(10) + 1; LOGGER.info(&quot;Thread: &#123;&#125;, key: &#123;&#125;, value: &#123;&#125;, dataSource object: &#123;&#125;)&quot; , Thread.currentThread().getName() , key , value , this); ctx.collect(new Tuple2&lt;&gt;(key, value)); &#125; &#125; @Override public void cancel() &#123; isRunning = false; &#125; &#125; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(2); DataSource dataSource = new DataSource(); LOGGER.info(&quot;dataSource object: &#123;&#125;&quot;, dataSource); DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; ds = env.addSource(dataSource); KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = ds.keyBy(0); // KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = ds.keyBy(&quot;f0&quot;); 通过指定字段名 f0 keyedStream .sum(1) // .sum(&quot;f1&quot;) 通过制定字段名 f1 .keyBy((KeySelector&lt;Tuple2&lt;String, Integer&gt;, Object&gt;) stringIntegerTuple2 -&gt; StringUtils.EMPTY) .fold(new HashMap&lt;String, Integer&gt;(), new FoldFunction&lt;Tuple2&lt;String, Integer&gt;, HashMap&lt;String, Integer&gt;&gt;() &#123; @Override public HashMap&lt;String, Integer&gt; fold(HashMap&lt;String, Integer&gt; accumulator, Tuple2&lt;String, Integer&gt; value) throws Exception &#123; accumulator.put(value.f0, value.f1); return accumulator; &#125; &#125;) .addSink(new SinkFunction&lt;HashMap&lt;String, Integer&gt;&gt;() &#123; @Override public void invoke(HashMap&lt;String, Integer&gt; value, Context context) throws Exception &#123; // 每个类型的商品成交量 LOGGER.info(&quot;&#123;&#125;&quot; , value); // 商品成交总量 LOGGER.info(&quot;&#123;&#125;&quot; , value.values().stream().mapToInt(v -&gt; v).sum()); &#125; &#125;); env.execute(); &#125;&#125; 通过查看dataSource object:的log就会发现上面这个例子中国产生了3个DataSource实例。 EvictorCountEvictor：保持窗口内元素数量符合用户指定数量，如果多于用户指定的数量，从窗口缓冲区的开头丢弃剩余的元素。DeltaEvictor：使用 DeltaFunction和 一个阈值，计算窗口缓冲区中的最后一个元素与其余每个元素之间的 delta 值，并删除 delta 值大于或等于阈值的元素。TimeEvictor：以毫秒为单位的时间间隔作为参数，对于给定的窗口，找到元素中的最大的时间戳max_ts，并删除时间戳小于max_ts - interval的所有元素。 keyedStreamKeyedStream.fold(R initialValue, FoldFunction&lt;T, R&gt; folder)添加一个合并key分组的算子，FoldFunction会接收到同一key的value，只有key相同的值才会被分发到同一个folder。 可能出现的问题Apache Flink: Return type of function could not be determined automatically due to type erasure错误场景：在用户定义DAG图算子的时候，可能会出现不支持lambda表达式的情况 原因：为了执行程序，Flink需要知道要处理的值的类型，因为它需要序列化和反序列化数据。Flink的类型系统基于描述数据类型的TypeInformation进行序列化和反序列化，会将Java中的基本类型以及Object类型与TypeInformation进行映射。当您指定一个函数时，Flink会尝试推断该函数的返回类型。但是某些Lambda函数由于类型擦除而丢失了此信息（可以自己编译后再对编译成的.class文件进行反编译，然后查看函数签名，发现函数签名具体类型被擦除），因此Flink无法通过此自动推断类型。Flink Java Lambda表达式 因此，必须显式声明返回类型。 解决方案1：用户自己定义返回类型 1234567DataStream&lt;String&gt; wordDataStream = dataStream.flatMap( (String sentence, Collector&lt;String&gt; out) -&gt; &#123; for(String word: sentence.split(&quot;\\\\W+&quot;)) &#123; out.collect(word); // collect objects of type String &#125; &#125;).returns(Types.STRING); 解决方案2：显示声明返回类型 12345678910111213141516DataStream&lt;String&gt; wordDataStream = dataStream.flatMap( new FlatMapFunction&lt;String, String&gt;() &#123; @Override public void flatMap(String sentence, Collector&lt;String&gt; out) &#123; // normalize and split the line String[] words = sentence.toLowerCase().split(&quot;\\\\W+&quot;); // emit the pairs for (String word : words) &#123; if (word.length() &gt; 0) &#123; out.collect(word); &#125; &#125; &#125; &#125;)","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Hello World","date":"2019-10-14T12:54:25.000Z","path":"2019/10/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"生产实践 | 基于 Flink 的视频直播核心指标监控","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/apache-flink:learning-files/","text":"Flink 学习资料 Flink 系列官网文档还是最准确的。直接上视频和资料，懒癌患者直接拿走即可~ 视频b站链接，很多大厂的实战，讲解很详细，很适合初学者。 资料 链接：https://pan.baidu.com/s/1GzVJYpUxkucLS9ZikZWuRw、提取码：64n4 其他视频链接可点击公众号 [call me] 联系博主私聊获取 文档1.Flink 官网文档、Flink 官网中文文档 2.《Stream Processing with Apache Flink》 这本由 Flink PMC 写的 Flink 书籍也是很适合初学者，并且中文版已经出版了 ：《基于 Apache Flink 的流处理》，由 Flink committer 崔星灿大佬翻译 3.ververica 中文网和 Flink 钉钉群直播教程 4.微信公众号(由Flink 中文社区维护)：Flink 中文社区 以及 Flink 5.Flink 知识图谱以及社区专刊 6.加入 Apache Flink China社区 钉钉群（群号：23138101），很多大佬活跃 7.订阅 Flink user、user-zh 邮件列表，可在官网查看订阅方式，邮件列表中有很多解决方案，也有大佬们活跃解答 8.Flink 视频系列 github地址 oreilly 流模型介绍 Streaming 101: The world beyond batch Streaming 102: The world beyond batch Flink 源码 github gitee 书籍社刊书籍《Stream Processing with Apache Flink》 《基于 Apache Flink 的流处理》 社刊源自 ververica，社刊链接，总共分为 4 期，可以直接在 ververica 官网下载。 系列博客1.云邪原理系列 2.金竹漫谈系列 3.杨华的源码 4.Apache Flink 零基础入门系列 5.zhisheng 6.彻底明白Flink系统学习系列 7.kangqi 8.flink菜鸟","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时开发需求确认模板","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/apache-flink:realtime-demand-template/","text":"实时开发需求确认模板 实时指标整个链路开发过程中的一些经验。 需求评估分析实时指标是否符合该需求场景，以及在该场景中实时指标能够发挥的价值。 1.实时指标所能提供的分析能力实时计算的输出内容，以及提供的分析能力：OLAP 分析，key-value 实时数据服务，维度填充，数据打标等。 2.产出维度，指标的合理性从需求出发，评估实时指标产出的维度和指标的合理性。 3.需求可配置变量 评估维度 评估指标 监控数据范围 监控数据范围动态配置改变？ 监控数据起止时间 监控数据的起止时间动态配置改变？ 监控数据的某些配置变量 当变量发生变动时，可能会对产出的实时数据有什么影响，对计算链路有什么影响，会决定实时计算链路的实现方式。 4.面向用户范围评估 SLA 等服务质量等级保障，以及提供的实时数据服务的可用性等级，并且提前和业务方确认可用性和出现故障时的恢复时间等问题。 评估维度 评估指标 时间语义 事件时间、处理时间？事件时间：可以通过获取数据的时间戳，使用处理时间来真实反映和还原事件，但是可能会出现数据条数过小窗口不能触发，或者在一些有截止日期的活动结束的最后一个窗口不能触发的问题；处理时间：处理时间一般和事件时间差距很小，经验值一般 diff 小于 1%，只能反映流式框架处理数据时的时间戳，但是不会出现上述事件时间的两个问题。因此需要评估需求的逻辑精确度是否要求很高？ 数据一致性 至少一次、精确一次？至少一次：受限于目前的上下游以及依赖中间件的能力，比如 010 版本及以下的 Kafka 不支持两阶段提交，所以只能达到至少一次的语义；精确一次：整条实时计算链路中的所有组件都需要支持精确一次的语义（从技术层面或者业务逻辑层面达到精确一次）。评估需求逻辑是否可接受任务发生失败时有重复数据产生？ SLA 要求 评估需求的 SLA 要求，整条实时计算链路的 SLA 要求，产出数据最多延迟多长时间？数据准确率几个9？提供的接口服务是否需要考虑跨集群、机房备份、双写；是否需要建立多条计算链路以供故障切换？一旦发生故障，下游消费方能容忍的最大故障时长？下游消费方在发生故障时的兜底策略？ 可行性评估1.技术可行性 评估维度 评估指标 QPS 确定 QPS 以评估实时上下游以及依赖组件的选型以及能力。 数据输入 首先确定数据输入是否能够计算实时指标，然后评估上游提供的数据在计算实时指标时整个实时计算链路的逻辑以及复杂度。比如：是否需要用到双流 join，需要评估双流 join 所存在的误差是否在可接受范围内，一般可通过离线误差对比或经验值给出结论。常见输入中间件：消息队列，接口等，常用中间件：Kafka，rpc，http。 数据依赖 调研目前可用的哪些中间件可以提供能力来支持当前指标计算？举例：key-value等，常用依赖中间件：Redis。 数据输出 确定输出下游消费方的消费需求以及能力，以评估实时产出的数据以及存储组件是否能够满足其需求？常见输出中间件：消息队列，OLAP，key-value，接口等，常用中间件：Kafka，Druid，Redis，rpc。产出维度，一般场景下，维度值不建议是大数量级别的数据，比如说使用 user_id，device_id。 2.成本可行性 评估维度 评估指标 QPS 确定 QPS 以评估实时上下游以及依赖中间件的资源消耗。确定资源消耗是否在可接受范围之内？ 数据输入 确定整个实时计算链路的逻辑以及复杂度，来评估可能的资源消耗。 数据依赖 确定整个实时计算链路的逻辑以及复杂度，来评估可能的资源消耗。 数据输出 由输出内容以及存储组件来评估下游存储中间件的资源消耗。举例：维度值不建议是大数量级别的数据，比如说使用 user_id，device_id 作为维度或者产出明细数据，虽然使用 OLAP 在维度聚合场景下很灵活，但是这些场景下使用 OLAP 可能会造成很大的资源消耗。 综合以上技术和成本可行性以及需求收益等指标，以评估实时指标的 ROI。 3.数据输入消息队列日志最常见的实时数据源就是消息队列日志，首先我们需要确定日志类型，不同的日志类型决定了指标或者维度字段是否可以产出以及其准确性，一般情况下有以下三种类型日志： 日志类型 备注 埋点日志 维度最全，数据准确 web server log 维度次全，数据准确度一般 binlog 数据库真实数据，反映的是真实数据，数据最准确，维度信息一般很少 接口这里的接口一般是用来根据需求圈定一批需要进行监控的数据内容。接口的提供方式可以是http，配置中心配置，rpc接口等。 4.数据依赖实时一般情况下都会或多或少依赖到外部组件，最常见的就是 key-value 存储。场景：很常见的一类需求就是对数据源中的数据进行打标然后产出，这里的标签数据就会存储在 key-value 中间件中。需要评估访问外存的 QPS，以及外存提供的能力。 5.数据输出 输出组件 备注 消息队列 常见中间件：kafka等 key-value存储 常见中间件：Redis，HBase，服务化接口等 OLAP 常见中间件：Druid，ClickHouse等 技术方案评估","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/broadcast/","text":"实时新增类指标标准化处理方案 实时指标整个链路开发过程中的一些经验。 实时新增类指标大体上可以将实时新增类指标以以下两种维度进行分类。 identity id 类型维度 identity id 类型 备注 number(long) 类型 identity id 数值类型 identity id 的好处在于可以使用 Bitmap 类组件做到精确去重。 字符类型 identity id 字符类型 identity id 去重相对复杂，有两种方式，在误差允许范围之内使用 BloomFilter 进行去重，或者使用 key-value 组件进行精确去重。 产出数据类型维度 产出数据类型 备注 明细类数据 此类数据一般是要求将新增的数据明细产出，uv 的含义是做过滤，产出的明细数据中的 identity id 不会有重复。输出明细数据的好处在于，我们可以在下游使用 OLAP 引擎对明细数据进行各种维度的聚合计算，从而很方便的产出不同维度下的 uv 数据。 聚合类数据 将一个时间窗口内的 uv 进行聚合，并且可以计算出分维度的 uv，其产出数据一般都是[维度 + uv_count]，但是这里的维度一般情况下是都是固定维度。如果需要拓展则需要改动源码。 计算链路因此新增产出的链路多数就是以上两种维度因子的相互组合。 number(long) 类型 identity id 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public interface RoaringBitmapDuplicateable&lt;Model&gt; &#123; long DEFAULT_DUPLICATE_MILLS = 24 * 3600 * 1000L; BiPredicate&lt;Long, Long&gt; ROARING_BIT_MAP_CLEAR_BI_PREDICATE = (start, end) -&gt; end - start &gt;= DEFAULT_DUPLICATE_MILLS; // 初始化 default ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; getBitMapValueState(String name) &#123; return this.getRuntimeContext().getState( new ValueStateDescriptor&lt;&gt;(name, TypeInformation.of( new TypeHint&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt;() &#123; &#125;)) ); &#125; RuntimeContext getRuntimeContext(); long getLongId(Model model); Optional&lt;Logger&gt; getLogger(); default BiPredicate&lt;Long, Long&gt; roaringBitMapClearBiPredicate() &#123; return ROARING_BIT_MAP_CLEAR_BI_PREDICATE; &#125; default List&lt;Model&gt; duplicateAndGet(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Date, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Date, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Map&lt;Long, Model&gt; idModelsMap = models .stream() .collect(Collectors.toMap(this::getLongId, Function.identity(), (oldOne, newOne) -&gt; oldOne)); Set&lt;Long&gt; ids = idModelsMap.keySet(); List&lt;Model&gt; newModels = Lists.newArrayList(); for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; if (idModelsMap.containsKey(id)) &#123; newModels.add(idModelsMap.get(id)); &#125; &#125; &#125; newModels.stream() .map(this::getLongId) .forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return newModels; &#125; default long duplicateAndCount(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Set&lt;Long&gt; ids = models .stream() .map(this::getLongId) .collect(Collectors.toSet()); List&lt;Long&gt; newIds = Lists.newArrayList(); int count = 0; for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; newIds.add(id); count++; &#125; &#125; newIds.forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return count; &#125; default Tuple2&lt;Long, Roaring64NavigableMap&gt; checkAndGetState(long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitmap = bitMapValueState.value(); if (null == bitmap) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;New RoaringBitMapValueState Timestamp=&#123;&#125;&quot;, windowStartTimestamp)); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else if (this.roaringBitMapClearBiPredicate().test(bitmap.f0, windowStartTimestamp)) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;Clear RoaringBitMapValueState, from start=&#123;&#125; to end=&#123;&#125;&quot;, bitmap.f0, windowStartTimestamp)); bitMapValueState.clear(); bitmap.f1.clear(); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else &#123; return bitmap; &#125; &#125;&#125; 字符类型 identity id使用 Flink state 使用 key-value 外存 如果选用的是 Redis 作为 key-value 过滤，那么这里会有一个巧用 Redis bit 特性的优化。举一个一般场景下的方案与使用 Redis bit 特性的方案做对比： 场景：假如需要同一天有几十场活动，并且都希望计算出这几十场活动的 uv，那么我们就可以按照下图设计 Redis bit 结构。 通常方案： 这种场景下，如果有 1 亿用户，需要同时计算 50 个活动或者 50 个不同维度下的 uv。那么理论上最大 key 数量为 1 亿 * 50 = 50 亿个 key。 Redis bit 方案： 这样做的一个优点，就是这几十场活动的 uv 计算都使用了相同的 Redis key 来计算，可以大幅度减少 Redis 的容量占用。使用此方案的话，以上述相同的用户和活动场数，理论上最大key 数量仅仅为 1 亿，只是 value 数量会多占几十个 bit。","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"},{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"快手 Java 内推 - 实习场","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/02_java/04_inc_java/","text":"快手 Java 内推 - 实习场 不仅限于以下 JD，hc 满满，有意可以直接加博主微信私聊。 Java开发实习生-【音视频技术部】工作地点：北京职位描述 将快手音视频核心能力进行产品化封装，针对场景开发针对性解决方案，为各类应用提供一站式. 全链路覆盖的音视频能力，包括并不限于短视频. 直播. 音视频会议等； 接受高并发. 海量数据的挑战，分析和发现系统的优化点，负责推动系统的性能和可用性的提升； 跟进业内最新技术进展，优化业务音视频体验，构建一流的音视频云平台。任职要求 计算机. 通信等相关专业本科以上学历，有NOI. ACM. TopCoder等相关竞赛经验者优先； java基础扎实，理解io. 多线程. 集合等基础框架，对JVM原理有一定了解，熟悉面向对象设计开发；掌握Linux操作系统和大型数据库；熟悉容器化运维，熟悉Linux下的DevOps； 对用过的开源框架能了解它的原理和机制，如服务框架. RPC. service mesh. 服务注册中心. 定时任务. 动态配置. 服务治理. 应用容器等；熟悉微服务和领域设计；熟悉前后端分离的系统结构； 熟悉分布式系统的设计和应用，熟悉分布式. 缓存. 消息等机制，能对分布式常用技术进行合理应用和解决问题； 热爱技术，对代码质量和开发规范有近乎苛刻的要求，善于沟通与团队协作；了解业内技术的发展方向； 有音视频技术背景，有视频云相关开发经验者优先。 Java开发实习生-【用户画像】工作地点：北京职位描述 负责快手画像平台及标签系统研发工作；通过敏捷开发支持产品需求快速迭代，不断优化系统架构，支撑业务规模增长，保障服务稳定； 对现有系统的不足进行分析，找到目前系统的瓶颈，改进提高系统性能； 参与解决大数据分布式处理. 高效查询. 数据一致性. 准确性等方面带来的各种技术难题和挑战。任职要求 本科及以上学历，计算机. 软件相关专业优先； 熟悉Java，有扎实的计算机基础，对数据结构. 算法基础有深入理解； 熟悉面向对象的设计思想，了解软件开发流程； 有实际项目经验或互联网公司实习经历者优先，有OI. ICPC等竞赛经验者优先； 热爱互联网，对互联网产品和技术有浓厚的兴趣，热衷于追求技术极致与创新； 具有良好的沟通能力和团队合作精神. 优秀的分析问题和解决问题的能力。 Java开发实习生-【电商生态】工作地点：北京职位描述 参与快手电商c端需求开发，深入理解业务需求，撰写技术方案和系统设计，并完成相关代码的开发工作； 愿意接受多种差异化资源投放业务逻辑复杂性. 海量数据挑战. 服务高可用的挑战，推动系统可用性和可扩展性的提升； 为团队引入创新的技术. 创新的解决方案，用创新的思路解决问题。任职要求 计算机科学或其他相关专业，本科及以上学历，每周至少4天，连续实习3个月以上； 精通多线程编程，熟悉JVM，熟悉常见的开源分布式中间件.缓存.消息队列等，有分布式系统设计相关经验，熟悉MySQL； 精通Spring MVC.Spring boot编程； 熟悉面向对象设计，有一定的系统架构设计能力。 JAVA开发实习生-【国内用户增长】工作地点：北京职位描述 负责快手各内外部产品后端系统. 平台系统的研发工作，通过敏捷开发支持产品需求快速迭代，不断优化系统架构，支撑业务规模增长，保障服务稳定； 对现有系统的不足进行分析，找到目前系统的瓶颈，改进提高系统性能； 参与解决海量数据分布式处理. 高效查询. 数据一致性. 准确性等方面带来的各种技术难题和挑战。任职要求 本科及以上学历，计算机. 软件相关专业优先； 熟悉Java，有扎实的计算机基础，对数据结构. 算法基础有深入理解； 熟悉面向对象的设计思想，了解软件开发流程； 有实际项目经验或互联网公司实习经历者优先，有OI. ICPC等竞赛经验者优先； 热爱互联网，对互联网产品和技术有浓厚的兴趣，热衷于追求技术极致与创新； 具有良好的沟通能力和团队合作精神. 优秀的分析问题和解决问题的能力。 Java开发实习生-【服务端效能】工作地点：北京职位描述 负责快手研发效能相关平台及工具的设计研发工作； 负责服务高可扩展性. 高可用性方向的提升和优化； 参与平台框架研究. 设计和实现，关键技术路径可行性研究及技术选型。【此岗位需立刻入职，如暑期才能入职请投递暑期实习生的相关岗位】任职要求 2022届本科及以上学历，计算机科学与技术.软件工程或相关专业方向； 熟悉Java，有扎实的计算机基础，对数据结构.算法基础有深入理解，有ACM等竞赛经验者优先； 熟悉面对对象的设计思想，了解软件开发流程，有实际项目经验或互联网公司实习经历者优先； 对技术充满热情，有较强的责任心和抗压能力，愿意接受千万级并发的大型分布式系统开发过程中面临的各种挑战； 有较好的沟通能力，能快速融入团队，有较强的学习能力，能快速掌握最前沿的技术。【此岗位需立刻入职，如暑期才能入职请投递暑期实习生的相关岗位】 Java开发实习生- 【商业化研发】工作地点：北京职位描述 参与聚星（原快接单）内容营销撮合交易平台产品后台服务的设计. 开发. 优化等研发工作，保证产品的质量和开发进度； 和产品等团队合作，确保前后端模块的协同工作； 参与研究新兴技术，对产品进行持续优化。任职要求 岗位面向2022届毕业生：本科及以上学历，计算机相关专业，每周实习3天及以上. 可实习4个月以上者优先； 熟悉面向对象编程，掌握Java/C++/Python/PHP中的至少一门语言； 学习能力强. 有独立解决问题的能力； 有良好的沟通能力和业务理解能力。 【暑期实习】Java开发实习生-海外业务工作地点：北京 负责海外快速增长的产品需求，深入发掘和分析业务需求，撰写技术方案和系统设计，以及相关的代码开发； 迎接高并发. 海量数据的挑战，分析和发现系统的优化点，负责推动系统的性能和可用性的提升； 积极尝试新技术. 新方案，拥抱技术革新，用创新的思路解决问题。任职要求 2022届计算机. 通信等相关专业本科及以上学历； 熟悉Java，有扎实的计算机基础，对数据结构. 算法基础有深入理解； 熟悉面向对象的设计思想，了解软件开发流程； 有实际项目经验或互联网公司实习经历者优先，有OI. ICPC等竞赛经验者优先； 热爱互联网，对互联网产品和技术有浓厚的兴趣，热衷于追求技术极致与创新； 具有良好的沟通能力和团队合作精神. 优秀的分析问题和解决问题的能力。 【暑期实习】Java开发实习生（iHR）-【效率工程】工作地点：北京负责快手相关产品服务器端的研发工作，通过敏捷开发支持产品需求快速迭代，不断优化系统架构，支撑业务规模增长，保障服务稳定。 任职要求 2021届. 2022届本科及以上学历，计算机科学与技术.软件工程或相关专业方向； 熟悉Java，有扎实的计算机基础，对数据结构.算法基础有深入理解，有ACM等竞赛经验者优先； 熟悉面对对象的设计思想，了解软件开发流程，有实际项目经验或互联网公司实习经历者优先； 对技术充满热情，有较强的责任心和抗压能力，愿意接受千万级并发的大型分布式系统开发过程中面临的各种挑战； 有较好的沟通能力，能快速融入团队，有较强的学习能力，能快速掌握最前沿的技术。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"快手大数据内推","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/05_数据团队建设/01_招聘/01_inc_de/","text":"快手大数据 DE 内推 不仅限于以下 JD，hc 满满，有意可以直接加博主微信私聊。 （大数据专场）数据研发工程师/专家-【数据资产】工作地点：北京职位描述 建设全站的基础数据能力，提供丰富、稳定的短视频社区公共基础数据，探索更多数据能力的增量价值； 各类数据专题体系（如社交、内容生产/消费、直播等）的建设，通过数据+算法+产品，赋能业务，提供全链路、可分析、可复用的数据能力，提供更直观、更具分析指导性的产品化能力； 建设公司层面的核心数据资产，与业务场景深度结合，为社区服务提供数据服务化、数据业务化的数据&amp;产品解决方案； 建设全站数据治理和管理体系，结合业务+元数据+技术，保障公司各个业务服务的数据质量和产出稳定。任职要求 较为丰富的数据仓库及数据平台架构经验，期望通过对业务的深入理解，进行数据仓库、数据体系和数据价值的建设和优化； 有从事分布式数据存储与计算平台应用开发经验，熟悉Hive，Kafka，Spark，Storm，Hbase，Flink 等相关技术并有相关开发经验； 有系统化的思维和工程化的能力，掌握JAVA和前端技术，有工程化落地的经验尤佳； 有较丰富的应用算法开发经验，对机器学习和AI有一定的了解； 3-5年及更长的经验均有需求。 （大数据专场）数据研发工程师/专家-【商业化】工作地点：北京职位描述 负责数据中台-商业化各个业务线数据仓库建设，构建商业化垂直数据集市； 定义并开发业务核心指标数据，负责垂直业务数据建模，如用户画像； 根据具体问题，设计并实现合适的可视化展示，构建数据持续观测平台； 参与数据平台的搭建，优化数据处理流程具体工作； 数据收集，反作弊数据仓库，用户数据仓库，UGC数据仓库，审核数据仓库的研发； A/B测试实时ETL研发，转化漏斗分析平台研发。任职要求 5-10年工作经验优先，3年以上也可看； 有Hive，Kafka，Spark，Storm，Hbase，Flink等两种以上两年以上使用经验； 熟悉数据仓库建设方法和ETL相关技术，对于数据的设计有自己的思考，具备优秀的数学思维和建模思维； 熟练使用SQL，对类SQL有过优化经验，对数据倾斜有深度的理解。了解特征工程常用方法； 具备扎实的编程功底，很强的学习、分析和解决问题能力，良好的团队意识和协作精神，有较强的内外沟通能力。 （大数据专场）数据研发工程师/专家-【国际化】工作地点：北京职位描述 建设全站的基础数据能力，提供丰富、稳定的短视频社区公共基础数据，探索更多数据能力的增量价值； 各类数据专题体系（如社交、内容生产/消费、直播等）的建设，通过数据+算法+产品，赋能业务，提供全链路、可分析、可复用的数据能力，提供更直观、更具分析指导性的产品化能力； 建设公司层面的核心数据资产，与业务场景深度结合，为社区服务提供数据服务化、数据业务化的数据&amp;产品解决方案； 建设全站数据治理和管理体系，结合业务+元数据+技术，保障公司各个业务服务的数据质量和产出稳定。任职要求 较为丰富的数据仓库及数据支持业务经验，期望通过对业务的深入理解，进行数据仓库、数据体系和数据价值的建设和优化； 有从事分布式数据存储与计算平台应用开发经验，熟悉Hive，Kafka，Spark，Storm，Hbase，Flink 等相关技术并有相关开发经验； 熟练掌握数据质量的保障规范和执行步骤，擅长系统性的解决问题； 3-5年及更长的经验均有不同岗位。 （大数据专场）数据研发工程师/专家-【杭州】工作地点：杭州职位描述 建设全站的基础数据能力，提供丰富、稳定的短视频社区公共基础数据，探索更多数据能力的增量价值； 各类数据专题体系（如社交、内容生产/消费、直播等）的建设，通过数据+算法+产品，赋能业务，提供全链路、可分析、可复用的数据能力，提供更直观、更具分析指导性的产品化能力； 建设公司层面的核心数据资产，与业务场景深度结合，为社区服务提供数据服务化、数据业务化的数据&amp;产品解决方案； 建设全站数据治理和管理体系，结合业务+元数据+技术，保障公司各个业务服务的数据质量和产出稳定。任职要求 较为丰富的数据仓库及数据平台架构经验，期望通过对业务的深入理解，进行数据仓库、数据体系和数据价值的建设和优化； 有从事分布式数据存储与计算平台应用开发经验，熟悉Hive，Kafka，Spark，Storm，Hbase，Flink 等相关技术并有相关开发经验； 有系统化的思维和工程化的能力，掌握JAVA和前端技术，有工程化落地的经验尤佳； 有较丰富的应用算法开发经验，对机器学习和AI有一定的了解； 3-5年及更长的经验均有需求。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"快手大数据内推","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/05_数据团队建设/01_招聘/02_inc_de_shixi/","text":"快手大数据实习内推 不仅限于以下 JD，hc 满满，有意可以直接加博主微信私聊。 （大数据专场）【暑期实习】数据研发实习生-数据平台工作地点：北京职位描述 协助建设全站的基础数据能力，提供丰富、稳定的短视频社区公共基础数据，探索更多数据能力的增量价值； 各类数据专题体系（如社交、内容生产/消费、直播、增长等）的建设，通过数据+算法+产品，赋能业务，提供全链路、可分析、可复用的数据能力，提供更直观、更具分析指导性的产品化能力； 建设公司层面的核心数据资产，与业务场景深度结合，为社区服务提供数据服务化、数据业务化的数据&amp;产品解决方案。任职要求 22届及以后毕业的本科或研究生，能够连续实习3个月及以上，每周能保证全勤者优先； 计算机相关专业，有一定Java代码功底； 熟悉Hadoop数据体系，擅长实时或离线计算的实施优化； 有数据仓库或者PB级数据处理经验的优先。 （大数据专场）数据研发实习生-【电商】工作地点：北京职位描述 紧密协助业务分析师或其他部门，用快速而有效的方式满足他们对数据的需求； 利用Hive，Spark等组件处理千亿级以上数据，支持电商业务的数据需求； 基于onedata的建模思路进行电商数仓的建模实践； 日常报表数据的开发和维护，保证自动报表的准时和有效； 承担其他电商大数据相关的开发和维护工作； 使用Flink建设秒级别响应实时处理链路，支持电商大促、营销等线上业务。任职要求 计算机以及相关专业毕业； 熟练使用SQL，有相关项目经历； 了解 Hadoop 生态系统，掌握 Hive／Spark / Flink/HBase等一种数据开发技术优先； 了解大型数据仓库架构、模型设计、ETL等。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"快手大数据内推","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/05_数据团队建设/01_招聘/03_inc_dpm/","text":"快手大数据 DPM 内推 不仅限于以下 JD，hc 满满，有意可以直接加博主微信私聊。 （大数据专场）数据产品经理-【数据内容】工作地点：北京职位描述 主动深入业务，理解业务运作逻辑，提炼或者对接业务数据需求，协调业务方和数据研发，通过工具、流程让数据供应做到及时、准确； 通过业务数据需求，抽象库表需求，辅助数据开发进行数据仓库模型设计，库表验收并及时把库表同步给业务方，数据字典建设与维护； 对接业务埋点需求，跟进埋点全流程，交付结果，推进埋点质量相关建设，辅助优化数据采集和埋点方案； 负责收集和挖掘各业务线的数据需求，协调数据分析师和数据开发团队完成需求，根据业务需要协助制定数据运营策略，规划和完善数据平台； 抽象数据分析需求，形成数据产品，通过数据描绘出整个业务流程、用户行为和重点环节的转化，帮助业务方更深刻的理解、使用和运营数据。任职要求 本科及以上学历，3年以上产品、分析或咨询工作经验，统计、数学、计算机相关专业优先； 良好的数据敏感度，了解大数据相关基础知识，熟悉常见的数据分析和处理方法； 熟练使用SQL，熟悉数据仓库，能够从业务需求抽象库表，熟悉业内埋点方案的使用场景，参与制定过产品埋点方案及规范设计； 能深刻理解业务，对数据分析、用户增长、数据化运营有一定了解，与业务部门数据需对接设计过业务型数据产品相关工作优先； 自我驱动，有Owner意识，交付能力强，面对复杂情况能够独立工作，结果导向，跨团队与部门的沟通能力强，有较强的团队协作意识和能力。 （大数据专场）数据产品经理-【数据质量监控】工作地点：北京职位描述 设计并落地数据全链路监控平台，实现端到端监控报警，通过工具协助数据开发快速发现及定位数据问题； 负责监控体系搭建，与关键用户合作，构建质量指标体系，提升组织质量管理效率； 负责产品需求文档撰写、产品交互设计，协助研发团队理解和实现用户需求，对产品的用户体验负责； 跟踪和分析国内外同行的发展动态，保证产品竞争力； 把控产品研发项目进度和风险，推动协调资源和外部合作。任职要求 5年以上互联网数据产品经验，有数据质量监控产品的相关经验（必备条件）； 对于Hadoop生态相关的技术有一定的了解，了解离线数据开发以及流式数据开发； 具备良好的用户思维，能够从用户角度出发思考问题； 积极主动，具备良好的沟通能力、抗压能力和团队合作能力； 有数据开发经验者优先。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时数开吊打面试官系列","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/01_大数据/01_数据仓库/01_实时数仓/05_数据团队建设/02_面试/01_interview_de/","text":"实时数开吊打面试官系列1.面试官会想考察候选人的什么能力？2.面试官会围绕哪些方面考察候选人？做数据的就是建、管、用数三个方向考察","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]}]