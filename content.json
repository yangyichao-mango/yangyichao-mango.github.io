[{"title":"深入浅出 | 全局一致性快照（一）","date":"2021-03-12T06:21:53.000Z","path":"2021/03/12/wechat-blog/apache-flink:state-1/","text":"1.目录 什么是状态？发散思维的去思考状态。我们所理解的状态不仅仅只限于 flink 的状态。让大家了解到状态是一个无处不在的东西 什么是全局一致性快照？和状态有什么关系？全局一致性快照的一些生活、工作中应用的例子 为什么需要一致性快照？全局一致性快照和 flink 的关系？jvm GC，分布式应用做故障恢复（比如 flink），死锁检测等 全局一致性快照的分布式应用举例通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（类似拍照片）。flink 做 cp，sp，类似于每隔固定的时间从时间轴上的一个点拿出来这个时间点对应的一个全局一致性状态 全局一致性快照的标准定义假如说有两个事件，a和b，在绝对时间下，如果a发生在b之前，且b被包含在快照当中，那么则a事件或者其对快照产生的影响也被包含在快照当中 怎么实现全局一致性快照？同步去做，包括时钟同步、Stop-the-world，但是这两种方法都不可接受；既然同步无法做，那如果异步能做出相同的全局一致性状态也可以 分布式应用的全局一致性快照其 Process 状态和 Channel状态到底需要记录什么？其之间需要满足什么关系的一些思考？不是必须要在同一时刻嘛，为啥还能异步去做？只要异步做出来的状态和同步做出来的状态效果一致也可以。 Chandy-Lamport 算法流程、例子介绍 Chandy-Lamport 算法流程并以一个例子介绍其执行过程 flink 实现的全局一致性快照介绍 2.什么是状态？（了解状态）目标：首先想让大家发散思维的去思考状态？我们所理解的状态不仅仅只限于 flink 的状态。让大家了解到状态是一个普遍存在的东西定义：就是当前计算需要依赖到之前计算的结果，那么之前计算的结果就是状态举例： 比如生活中的例子：为什么我知道这个是电脑，因为眼睛接收到外界的图案，然后我的大脑接收到这个图案后，拿记忆中存储的图案进行对比，匹配得到这是电脑。那么记忆中存储的图案就是状态；日久生情等都存在状态 比如 web server 应用中的状态：打开 github 页面，列表展示了我的归属仓库。其中就是 web client 发了查询我的归属仓库请求，web server 接收到请求之后，然后去 mysql 中进行查询匹配返回。那么 mysql 中存储的内容就是状态 比如 flink 应用中的状态：要去重，就要存储所有的 key；要获取当前最大值，那么历史最大值就是状态 3.什么是全局一致性快照？（了解全局一致性快照）全局：代表是一个分布式的一致性快照：代表绝对时间的同一时刻的状态相当于打开上帝视角，去观察同一时刻的应用所有的状态其实这里的快照 = 状态，文章之后我可能会把这两个词混用，大家明白他们的意思一致即可 比如生活中的例子：比如拍了一个照片，那么照片的内容就是当时的一个全局一致性快照；每一个首脑都是一个进程，所有的进程的状态在同一时刻的组合就是一个全局一致性快照 比如分布式应用的例子：首先是一个分布式应用，它有多个进程分布在多个服务器上；其次，它在应用内部有自己的处理逻辑和状态；第三，应用间是可以互相通信的；第四，在这种分布式的应用，有内部状态，硬件可以通信的情况下；某一时刻的全局状态，就叫做全局的快照。 分布式应用某一时刻的全局一致性快照 = 各个 process 的本地状态 + channel 中正在传递的消息 4.为什么需要一致性快照？全局一致性快照和 flink 的关系？ 实时案例- 做检查点（全局一致性快照）用来故障恢复，重点就在于我们不必要从历史起点开始重跑所有的数据；（1.kafka 不可能存储历史所有数据 2.重跑历史数据的情况下，时效性是达不到要求的） - 可以做任务的死锁检测 6.全局一致性快照的分布式应用案例？通过一个简单分布式应用介绍一下全局一致性状态是每时每刻都存在的。时间轴上的每一个时刻都存在一个全局一致性快照（拍照片）。 示例下面分布式应用的一个示例： 每时每刻都存在全局一致性快照上面这个只是四个时刻的四个快照，其实应用的每一个时刻都存在一个全局一致性快照。 7.全局一致性快照的标准定义定义假如说有两个事件，a和b，在绝对时间下，如果a发生在b之前，且b被包含在快照当中，那么则a也被包含在快照当中。满足这个条件的全局快照，就称为全局一致性快照。 本质就是如果将做了绝对时刻 T 的一个快照，那么这个绝对时刻 T 之前发生的所有事件以及其影响都会被包含在这个快照中 8.怎么实现全局一致性快照？同步实现方式 NTP（https://baike.baidu.com/item/NTP%E6%9C%8D%E5%8A%A1%E5%99%A8/8633994?fr=aladdin）: NTP服务器【Network Time Protocol（NTP）】是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒）结论：无法实现 同步实现方式：Stop-The-World（https://www.jianshu.com/p/b210f9db19a3） 结论：不满足需求，无法采用 异步实现方式如果同步实现方式不满足需求，那么能使用异步做到同步相同的快照也是可以满足需求的 异步实现方式：chandy-lamport论文：https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Determining-Global-States-of-a-Distributed-System.pdf?ranMID=24542&amp;ranEAID=J84DHJLQkR4&amp;ranSiteID=J84DHJLQkR4-mVoVymFnAblBx3zwyf98Pw&amp;epi=J84DHJLQkR4-mVoVymFnAblBx3zwyf98Pw&amp;irgwc=1&amp;OCID=AID2000142_aff_7593_1243925&amp;tduid=%28ir__1hs2uuow6wkfq3oxkk0sohzzwm2xpc33lxd0o6g200%29%287593%29%281243925%29%28J84DHJLQkR4-mVoVymFnAblBx3zwyf98Pw%29%28%29&amp;irclickid=_1hs2uuow6wkfq3oxkk0sohzzwm2xpc33lxd0o6g200 9.分布式应用的全局一致性快照其 Process 状态和 Channel状态记录了什么？怎么记录 Channel 的状态？分布式应用要记录的状态如下图案例 Single-Token conservation，是一个分布式应用，有 p 和 q 两个进程，p 可以通过 Channel pq（记为 Cpq） 向 q 发消息，q 可以通过 Channel qp（记为 Cqp） 向 p 发消息，其中有一个叫 token 的消息，在这个系统中一直不停的流转 如之前所述，分布式应用的全局一致性快照包含 Process 状态和 Channel 状态那么上图 Single-Token conservation 示例中的全局一致性快照 S = S(p) + S(Cpq) + S(q) + S(Cqp)其中： S：全局一致性快照 S(p)：p 进程的状态 S(Cpq)：p 进程到 q 进程的 Channel 状态 S(q)：q 进程的状态 S(Cqp)：q 进程到 p 进程的 Channel 状态 问题：这里大家可能会提到一个问题：做全局一致性快照时，其中 S(p)，S(q) 好理解，但是 S(Cpq)，S(Cqp) 到底应该记录什么东西？接下来详细讲讲我的理解 Process 状态应该记录什么内容？记录和用户业务需求相关的状态内容，用到了关于状态的地方，进行记录就好了举例：uid 去重就存储历史所有的 uid 就可以了 Channel 状态应该记录什么内容？一个全局一致性状态记录的 token 都在相同的地方全局一致性快照token 在 p 时，对应第一张图，这时的全局一致性快照为：S(token-in-p) = S(p-token-in-p) + S(Cpq-token-in-p) + S(q-token-in-p) + S(Cqp-token-in-p) ；其中： S(token-in-p)：token 在 p 时，做的全局一致性快照 S(p-token-in-p)：token 在 p 时，p 进程的状态 S(Cpq-token-in-p)：token 在 p 时，p 进程到 q 进程的 Channel 状态 S(q-token-in-p)：token 在 p 时，q 进程的状态 S(Cqp-token-in-p)：token 在 p 时，q 进程到 p 进程的 Channel 状态 注意，上述这个表达式其实是结论，这个结论是很好理解的，但是你有想过站在实际应用的角度去思考怎样才能做一个实际快照时x下面的问题吗？ 问题1：为什么第一张图的全局一致性状态是 Process 和 Channel 做的快照都有 token-in-p 呢？根据之前的拍照片的类比，当前这个绝对时刻做快照时，token 在 p；那么所有的 process 和 channel 记录状态时，token 都应该在 p。 S(Cpq) 记录了什么内容？简单的理解这里我们简单先理解下，S(Cpq) 其实就是在 S(p) 和 S(q) 自己的状态做成时，还在 Channel pq 之间发送的那些消息。 那么我们怎么用数学的方式理解 Cpq 记录的这些消息以及 Process 和 Channel 做状态时需要满足的条件呢？让我们往下看 变量定义 n：在 p 的状态记录前，p 记录的 p 发往 Cpq 的 msg 数； n′：在 Cpq 的状态记录前，Cpq 记录的 p 发往 Cpq 的 msg 数； m：在 q 的状态记录前，q 记录的 q 从 Cpq 中接收到的 msg 数； m′：在 Cpq 的状态记录前，Cpq 记录的 q 从 Cpq 中接收到的 msg 数； 结论Cpq 记录 S(Cpq) 时，必然会有 n = n’ ≥ m = m’；即一个 Channel 要记录的状态是，它 sender 记录自己状态之前它所接收到的 msg 列表，再减去 receiver 记录自己状态之前它已经收到的 msg 列表，减去的之后的数据列表就是还在通道中的数据列表，这个列表是需要 Channel 作为状态记录下来的。而如果 n′=m′，那么 Channel c 中要记录的 msg 列表就是 empty 列表。如果 n′&gt;m′，那么要记录的列表是 (m′+1),…n′ 号消息对应的 msg 列表。 证明首先是 n = n’，利用反证法：如果 n != n’，则会有两种情况： n &gt; n’ 时： ○ 可能会出现 n = 10（p 记录状态前，p 记录 p 发往 Cpq msg 数为 10（msg 编号 1 - 10））； ○ n’ = 7（Cpq 记录状态前，Cpq 记录 p 发往 Cpq 的 msg 数为 7（msg 编号 1 - 7））； ○ 那么假设 token 的编号为 9，就会出现 p 记录的状态为 S(p-token-in-Cpq)，Cpq 记录的状态为 S(p-token-in-p)，实际是不可能出现的； n &lt; n’ 时： ○ 可能会出现 n = 7（p 记录状态前，p 记录 p 发往 Cpq msg 数为 7（编号 1 - 7））； ○ n’ = 10（Cpq 记录状态前，Cpq 记录 p 发往 Cpq 的 msg 数为 10（编号 1 - 10））； ○ 那么假设 token 的编号为 9，就会出现 p 记录的状态为 S(p-token-in-p)，Cpq 记录的状态为 S(p-token-in-Cpq)，实际是不可能出现的； n = n’ 时：保障了无论什么情况下，只要 p 做出 S(p-token-in-p) 的状态时，因为 n = n’，代表 p 没有把 token 发出去，Cpq 也没有接受到 token，就能让 Cpq 也做出 S(Cpq-token-in-p)； 然后是 m = m’，同样利用反证法 m &gt; m’ 时： ○ 可能会出现 n = n’ = m &gt; m’，q 记录状态前，Cpq 记录 q 从 Cpq 接收到的 msg 数为 10（编号 1 - 10，因为 n = n’ = m 也即 Cpq 记录的 p 发往 Cpq 的那些 msg）； ○ Cpq记录状态前，Cpq 记录的 q 从 Cpq 接收到的 msg 数为 7（编号 1 - 7）； ○ 那么假设 token 的编号为 9，就会出现 Cpq 记录的状态为 S(Cpq-token-in-Cpq)，q 记录的状态为 S(q-token-in-p)，实际是不可能出现的； 最后是 n′≥m′ and n≥m：在任何一种情况下，做全局一致性快照时，都会有 Cpq 下游接收到的 msg 数不可能超过 p 发送给 Channel 的 msg 条数，即：n′≥m′以及 n≥m（也可使用反证法证明） 来段伪代码描述全局一致快照伪代码12345678910111213141516171819202122// S_all 即全局一致性快照S_all = null;// 假设总共有 x 个 processfor (int i = 1; i &lt;= x; i++) &#123; // 第 i 个 process 的状态为 S_i，直接按照 += 写，勿喷 S_all += S_i;&#125;// 假设总共有 y 个 channelfor (int i = 1; i &lt;= y; i++) &#123; // 1.S_C_out_in_i：第 i 个 channel 的状态，in 代表第 i 个 channel 的输入，out 含义为第 i 个 channel 的输出 // 2.m_out_in_i 和 n_out_in_i 其实就是上文中的 n 和 m // 2.m_out_in_i：第 i 个 channel 做快照前，发往 in process（下游）的消息个数 // 3.n_out_in_i：第 i 个 channel 做快照前，接受到 out process（上游） 的消息个数 // 4.需要注意，每一个 channel 的 m_out_in_i 和 n_out_in_i 都可能是不一样的，这里是伪代码所以直接按照下面的方式写了 S_C_out_in_i = Message[m_out_in_i + 1] + ... + Message[n_out_in_i]; S_all += S_C_out_in_i;&#125;// 状态做完啦~ 怎样去记录 S(Cpq)？通过上面的分析，我们已经讨论得到了 S(Cpq) 都包含了什么内容，并且其之间要满足什么样的数学关系。但是在现实实际生活中，消息在 Channel 上乱飞时，我们是无法记录这些消息作为 Channel 的状态的。但是这些消息终究会到达目的地，我们可以在消息的目的地去记录这些消息作为 Channel 的状态。即我们可以在 q 中记录 Channel pq 的 S(Cpq)，在 p 中记录 Channel pq 的 S(Cqp)。 伪代码顺便那么上面那段伪代码就可以简化为下面这样： 12345678910111213141516171819202122232425262728// S_all 即全局一致性快照S_all = null;// 假设总共有 x 个 processfor (int i = 1; i &lt;= x; i++) &#123; // S_i_all：第 i 个 process 要记录的状态 S_i_all = null; // S_i：第 i 个 process 的状态 S_i_all += S_i; // 【直接按照 += 写，勿喷】 // 第 i 个 process 总共有 y 个 input channel，即有 y 个上游 process，下文中 j 即指代第 j 个 channel，也代指 j channel 的上游 j process for (int j = 1; j &lt;= y; j++) &#123; // 1.S_C_j_i：第 i 个 channel 的状态 // 2.m_j_i 和 n_j_i 其实就是上文中的 n 和 m // 2.m_j_i：第 j 个 channel 做快照前，发往 i（下游）的消息个数 // 3.n_j_i：第 j 个 channel 做快照前，接受到 j（上游） 的消息个数 // 4.需要注意，每一个 channel 的 m_j_i 和 n_j_i 都可能是不一样的，这里是伪代码所以直接按照下面的方式写了 S_C_j_i = Message[m_j_i + 1] + ... + Message[n_j_i]; S_i_all += S_C_j_i; &#125; S_all += S_i_all;&#125;// 状态做完啦~ 记录 S(Cpq) 需要满足的条件重点重点重点！！！分析上面的伪代码后，我们可以发现，要得到 S_all，其中只有一个变量在进程做快照时不知道的，那就是 n_j_i（即第 i 个 channel 做快照前，接受到 j（上游） 的消息个数），别忘了 n = n‘，即也可以定义为 j 做快照前，j 发往 channel 的消息个数。那么实际上这个值 j process 是知道的，就代表 i 进程需要知道 j 告诉他 n_j_i 的值是多少。重点来了，当 i process 做完快照之后，直接发一个 marker 下去，这个 marker 不会对计算有任何影响（即不会对状态产生任何影响），marker 只是一个标识，j process 做完自己的快照之后，直到接收到 marker 之间的消息就是Channel ij 的状态。i 就是通过 marker 来告诉 j process n_j_i 的值是多少的。 Chandy-Lamport 记录 Channel 状态中内容的方法当消息在 Channel 上乱飞时，我们是无法记录这些消息作为 Channel 的状态的，但是这些消息终究会到达目的地，我们可以在消息的目的地去记录这些消息作为 Channel 的状态。那么可以得到一个算子应该记录的状态就是自己的状态和 input Channel 的状态； 那么具体怎么做的？就是在发送数据中插入一条特殊的数据 —— marker 数据，这条数据不会对计算有任何影响，即不会对应用的状态有任何影响，只是一个标识；q 在没有记录自己的状态时，接收到了 Cpq 传来的 marker，那么 q 就开始记录自己的状态，并且把 Cpq 记录为空；如果 q 已经记录了自己的状态，那么在收到 marker 之前从 Cpq 接收到 msg 列表就是 Cpq 的状态 分布式应用全局一致性快照方法总结 有一个 manager process（这个 manager 可以是所有 process 中的任意一个 process，也可以是一个单独的中央管理者）告诉所有的 process 说可以开始做状态了； 所有 process 就开始记录自己本地的状态（非所有 input channel）了，记录完本地状态，然后发 marker 给下游所有的 channel，然后开始记录上游所有 input channel 的消息（直到接收到上游所有的 marker）； 每个 process 对于每一个 input channel，都将自己做完状态后直到收到 marker 之间的消息记录下来，作为这个 input channel 的状态；这里注意，其实每接收到一个消息，process 都是可以进行处理的，这和记录 input channel 的状态并不冲突。 当收到上游所有 marker 之后，这个 process 要记录的状态就全部得到了，然后告诉 manager process 说做完状态了； manager process 接收到所有 process 做完的消息之后，就标记所有的状态以及完成了。 10.Chandy-Lamport 算法流程、示例算法流程 发起快照解读：本次快照的起始点，先把起始点的快照给做了，然后发出 marker（这个 Marker 消息是干啥用的呢？？？），开始记录 input channel 执行快照解读： Pi 记录本地快照，标记 Cki 为空：因为从 Cki 接收到了 marker，这时的状态是 Pk 刚刚做完快照，Pk 做完快照发往 Cki 的消息个数 = Pi 做完快照从 Cki 接收到的消息个数。即 n = n’ = m’ = m；即 Cki = [Empty]； Pi 开始向所有 output Channle 发 marker，开始记录除 Cki 之外的 input channel 消息，因为本地快照已经做完了；然后上游还有部分进程没有做完快照，为了记录除 Cki 之外的 input Channel 消息， 解读：结合前一张图说的开始记录 input channel 消息，Pi 停止记录 Cki 的消息，同时将此前记录所有 Cki 收到的消息作为本次快照中的最终状态；n’ &gt; m’，在 Pi 这里记录了 Cki 的状态，即 Cki = [m‘ + 1, m’ + 2…n] 终止快照 示例 11.flink 实现的全局一致性快照介绍（flink 容错机制）Chandy-Lamport与 Flink之间的关系论文：https://arxiv.org/pdf/1506.08603.pdf Flink 是分布式系统，所以 Flink 会采用全局一致性快照的方式形成检查点，来支持故障恢复。Flink的异步全局一致性快照算法跟Chandy-Lamport算法的区别主要有以下几点： 第一，Chandy-Lamput支持强连通图，而 Flink支持弱连通图； 第二，Flink采用的是裁剪的（Tailored）Chandy-Lamput异步快照算法； 第三，Flink的异步快照算法在DAG场景下不需要存储 Channel state，从而极大减少快照的存储空间。 flink 的容错机制 端到端的Exactly onceExactly once的意思是，作业结果总是正确的，但是很可能产出多次；所以它的要求是需要有可重放的source。端到端的Exactly once，是指作业结果正确且只会被产出一次，它的要求除了有可重放的source外，还要求有事务型的sink和可以接收幂等的产出结果。 flink 的全局一致性快照 Barrier 对齐 状态后端JVM Heap第一种，JVM Heap，它里面的数据是以Java对象形式存在的，读写也是以对象形式去完成的，所以速度很快。但是也存在两个弊端：第一个弊端，以对象方式存储所需的空间是磁盘上序列化压缩后的数据大小的很多倍，所以占用的内存空间很大；第二个弊端，虽然读写不用做序列化，但是在形成snapshot时需要做序列化，所以它的异步snapshot过程会比较慢。 RocksDB第二种，RocksDB，这个类型在读写时就需要做序列化，所以它读写的速度比较慢。但是它有一个好处，基于LSM的数据结构在快照之后会形成sst文件，它的异步checkpoint过程就是文件拷贝的过程，CPU消耗会比较低。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时数据时效监控体系建设","date":"2020-12-01T06:21:53.000Z","path":"2020/12/01/wechat-blog/apache-flink:realtime-time-monitor/","text":"本系列介绍了实时数据时效监控体系的建设。 前言数据延迟为是实时数据的一个最大问题。其实不管是哪部分产生延迟，最终的结果是都会直接影响到上层指标（数据质量问题 + 数据时效问题）。为了方便我们在开发阶段，运维阶段快速定位、解决延迟导致的问题；以及为后续可能的报警能力提供基础能力，因此需要建设实时数据流时效监控体系。 以一张图描述整个传输链路与耗时相关的问题。 总结上述图总共分为以下三部分。 数据延迟监控 数据乱序监控 数据加工延迟监控","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | Flink + 直播（三）| 如何建设当前正在直播 xx 数？","date":"2020-11-11T06:21:53.000Z","path":"2020/11/11/wechat-blog/apache-flink:realtime-live-stream-3/","text":"生产实践 | Flink + 直播（三）| 如何建设当前正在直播 xx 数？ 本系列每篇文章都是从一些实际的 case 出发，分析一些生产环境中经常会遇到的问题，抛砖引玉，以帮助小伙伴们解决一些实际问题。本篇文章主要介绍直播间生产侧指标的建设过程，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 整体架构本文主要介绍生产侧指标的建设，比如当前正在直播直播间数，或者主播数等。在介绍生产侧指标的建设过程之前，我们先回顾下上一节的架构图。 而本篇要介绍的生产侧指标的数据链路主要对应以下几个模块。 数据源：读取直播生产，比如开播，关播等 kafka 数据源日志； 数据处理：使用生产侧数据源 + 实时画像维表 + flink 建设生产侧实时指标； 数据汇：将处理完成的指标数据写入到 kafka 中。 我用另一张图进行了标注，图中标红模块为生产侧指标的数据链路涉及到的模块。 其中直播间实时画像维表的介绍已经在上节进行了介绍，感兴趣的话可以点击以下链接，跳转到上节进行阅读~ 本小节就不针对生产侧指标的建设中所有涉及指标的建设过程进行详细介绍了，我们主要以当前分钟正在开播直播间数作为生产侧指标建设的一个代表性案例，介绍这个指标的整个建设过程。来为大家还原生产侧指标的业务过程以及技术方案。 Question仍然从几个问题入手，介绍当前分钟正在开播直播间数的建设过程。 当前分钟正在开播直播间数的定义什么？业务过程是怎么样的？举例？ 怎样去建设这个指标？整体的指标计算流程？ 1.聊聊定义？当前分钟正在开播直播间数，其定义就是整个平台中，当前分钟正在开播的直播间数 + 单层维度下钻的当前分钟正在开播的直播间数。 举例： 现在的时间点是 2020-11-11 12:42，真实直播的直播间数为 3000 个（平台维度下钻：IOS 平台为 1500，安卓平台为 1500） 到了 12:43 时，有 200 个直播间进行了关播（其中 100 个为 IOS，100 个为安卓），有 100 个直播间开播（全部为 IOS），则当前正在直播的直播间数为 2900（平台维度下钻：IOS 平台为 1500，安卓平台为 1400）。 其中 2020-11-11 12:42 的 3000 以及 2020-11-11 12:43 的 2900 以及按照平台下钻的数值就为当前时间正在开播的直播间数。 因此根据上述定义和分析，我们可以直接将数据源和数据汇的 schema 定义下来，主体信息如下。 数据源 schema 字段 备注 live_stream_id 直播间 id author_id 主播 id start_or_end 开播还是关播 timestamp 时间戳 … … 数据汇 schema 字段 备注 timestamp 时间戳，汇总到分钟粒度 metric_name 指标名，举例：开播直播间数 metric_value 指标值，举例：3000（开播直播间数） dim_name 维度名，举例：平台，版本 dim_value 维度值，举例：IOS，8.1 … … Notes: metric_name 和 metric_value： 这两个字段是为了之后进行指标扩充时进行的设计。比如后续如果需要加入开播主播数，开播时长等指标，不用修改数据汇 schema，只需要加一种 metric_name，就可以使用原有 schema 进行数据产出。 dim_name 和 dim_value： 目前我们建设的指标只提供了进行单维度下钻的能力，所以设计了 dim_name 和 dim_value 两个字段，可满足用户查看平台为 IOS 的当前开播直播间数或者使用开播软件版本为 8.1 的当前开播直播间数。如果后续业务场景需要多维下钻能力，可以在字段上面进行扩充。或者也可以提供明细数据在 OLAP 中进行多维下钻。 2.怎样建设？对于当前分钟正在开播直播间数来说，其计算方式很简单，就是下面这个数学公式： 当前分钟正在开播直播间数 = 上一分钟正在开播直播间数 + 当前分钟开播直播间数 - 当前分钟关播直播间数 可以从上面的公式可以看出，对于当前分钟正在开播直播间数的计算来说，是依赖上下文信息的，即上一分钟正在开播直播间数，这也就是我们所说的状态。 指标处理逻辑从获取到数据源，到产出指标的整体处理逻辑如下图所示。这里就不进行赘述了。 其中标为粉色的模块为任务中的状态，即任务中一直存储的当前分钟正在开播直播间数。 状态上述指标涉及到了，状态，那么我这里讲一下我对状态的理解。如有错误，请在文末讨论中进行指出，我会和大家讨论。 状态其实就是一个记录上下文信息的东西，如果当前的计算过程依赖到上次计算的结果，那么上次计算的结果就是状态。举几个🌰； 流处理：如本节介绍的当前分钟正在开播直播间数的计算，就是依赖上一分钟的正在开播直播间数（状态）进行的计算。可能有小伙伴会说，我不依赖上一分钟，我从头开始计算可以不？答案是可以的，但是从头开始计算，也需要将所有历史数据进行存储，这些历史数据其实也就是状态，只不过我们将其优化为了上一分钟开播直播间数。 批处理：今天的全量表 = 昨天全量表（状态） + 今天的增量表。 数据库存储：最常见的 mysql 主键自增，unique key 等。为什么新插入一条数据主键会自增？因为 mysql 存储了主键的上一个值（状态）。为什么插入相同数据时，由于 unique key 会导致报错，就是因为 mysql 存储了所有 unique key 的字段的数据（状态）。 生活：当前的手机电量 = 上一分钟的手机电量（状态） + （充电/用电量）。为什么你越来越喜欢你的另一半？因为你对她的感觉 = 前一秒你对她的感觉（状态） + 当前这一秒她亲了你一下。 生活中随处可见状态，即使你不是程序员，我相信也都可以理解状态的概念。 指标计算代码示例按照最简单的实现方式举例如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class LiveStreamRealtimeMetricProdProcessorJob &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); DataStream&lt;SourceModel&gt; source = SourceFactory.getSourceDataStream(...); DataStream&lt;SinkModel&gt; result = source .keyBy(new KeySelector&lt;SourceModel, Long&gt;() &#123; @Override public Long getKey(SourceModel commonModel) throws Exception &#123; return commonModel.getLiveStreamId() % 1000; &#125; &#125;) .timeWindow(Time.seconds(60)) .process(new ProcessWindowFunction&lt;SourceModel, SinkModel, Long, TimeWindow&gt;() &#123; private ValueState&lt;Long&gt; playingLiveStreamNumberValueState; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.playingLiveStreamNumberValueState = getRuntimeContext().getState(...); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;SourceModel&gt; iterable, Collector&lt;SinkModel&gt; collector) throws Exception &#123; Long playingLiveStreamNumber = this.playingLiveStreamNumberValueState.value(); if (null == playingLiveStreamNumber) &#123; playingLiveStreamNumber = 0L; &#125; List&lt;SourceModel&gt; sourceModels = (List&lt;SourceModel&gt;) iterable; for (SourceModel sourceModel : sourceModels) &#123; if (BizType.I == sourceModel.getBizType()) &#123; playingLiveStreamNumber++; &#125; else &#123; playingLiveStreamNumber--; &#125; &#125; this.playingLiveStreamNumberValueState.update(playingLiveStreamNumber); collector.collect( SinkModel.builder().build() ); &#125; &#125;); SinkFactory.setSinkDataStream(...); env.execute(); &#125; @Data @Builder static class SourceModel &#123; // 直播间id private Long liveStreamId; // 开播时间，关播时间 private Long time; // 主播id private Long authorId; // binlog 时间戳 private long binlogTimestamp; // 开播，关播 private BizType bizType; &#125; enum BizType &#123; I, // 开播 D, // 关播 ; &#125; @Data @Builder static class SinkModel &#123; // 时间戳，汇总到分钟粒度 private Long timestamp; // 指标名 private String metricName; // 指标值 private double metricValue; // 维度名 private String dimName; // 维度值 private String dimValue; &#125;&#125; 总结本文衔接上文，主要介绍直播间生产侧指标的建设，以当前分钟正在开播直播间数为代表举例。提出定义以及建设过程相关的问题，以这两个个问题出发，引出了以下两小节。 第一节简单介绍了当前分钟正在开播直播间数的定义。 第二节主要介绍了当前分钟正在开播直播间数的建设逻辑以及过程，并对状态这个概念进行了一个拓展介绍。 最后一节对本文进行了总结。 如果你也有相同的指标建设需求，或者存在一些指标建设过程中的问题，欢迎关注博主公众号，或者添加博主微信，互相交流~ 记得点赞 + 再看喔~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | Flink + 直播（二）| 如何建设实时公共画像维表？","date":"2020-11-02T06:21:53.000Z","path":"2020/11/02/wechat-blog/apache-flink:realtime-live-stream-2/","text":"生产实践 | Flink + 直播（二）| 如何建设实时公共画像维表？ 本系列每篇文章都是从一些实际生产实践需求出发，解决一些生产实践中的问题，抛砖引玉，以帮助小伙伴们解决一些实际生产问题。本篇文章主要介绍直播间画像实时维表建设的整个过程，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 技术架构回顾上一节的技术架构图。 整个架构相对来说是比较好理解的。从数据源到数据处理以及最后到数据汇部分。 但是大家的疑惑点可能就集中在三个维表的建设上，包含主播用户画像维表，观众用户画像维表，直播间画像维表。 我们依然从以下几个角度的问题出发，通过分析场景，解答这几个问题来给大家介绍以上三个维表的建设过程。 Question WHAT：直播实时公共画像维表是指什么？离线公共画像维表又指什么？区别？ WHY：为什么架构图中的三类公共画像维表要按照实时和离线进行划分？为什么需要建设实时公共画像维表，离线公共画像维表不能满足需求？ HOW：怎样才能建设满足直播实时数据的实时公共画像维表？ WHO：需要使用什么样的组件建设直播实时公共画像维表？为什么选用这些组件进行建设？ WHAT：实时 &amp; 离线公共画像维表？概念首先简单介绍下，实时 &amp; 离线公共画像维表中存储的内容就是实体的固有属性（比如用户的年龄等），我理解这两个词本身是高层抽象的概念，本文中介绍的主播用户画像维表，观众用户画像维表，直播间画像维表是其具体实现。 其他大佬的文章解释中会对实时公共画像维表 &amp; 离线公共画像维表有更加深度的理解，这里我只说明我在直播实时数据建设过程中的理解~ 区别其实这两个词的区别从名字上就可以区分出来，实时公共画像维表和离线公共画像维表的最大区别就是数据建设和应用场景要求的时效性不同。 离线公共画像维表特点： 场景：适合离线场景，时效性要求比较弱的场景，为指标提供画像维度填充或者打标服务 建设：一般都是以离线 t + 1 的方式进行建设 应用：使用的数据为离线 t + 1 的数据 举例：数据仓库中的用户画像维表，为应用层数据提供画像服务；比如不但需要统计总 uv，还需要统计分年龄段的 uv。 实时公共画像维表特点： 场景：适合实时场景，时效性要求比较强的场景，为指标提供画像维度填充或者打标服务 建设：实时的进行建设，延迟一般在秒级别 应用：使用的数据都是实时建设好的，必须可以实时获取（秒级别延迟后获取到）并使用 WHY：为什么建设实时公共画像维表？为什么架构图中的三类公共画像维表要按照实时和离线进行划分？为什么需要建设实时公共画像维表，离线公共画像维表不能满足需求？ 这几个问题其实围绕着我们的直播实时数据建设以及应用的场景就可以展开解答。 接上篇技术架构图，其中直播实时数据需要建设的公共维表分为以下三类： 直播间画像维表：包含直播对应的直播类别、开播客户端、标题、开播地址等信息 主播画像维表：主播对应的主播名、主播类别、性别、年龄段等 观众画像维表：观众对应的观众性别、年龄段等 直播间画像维表首先抛出结论：直播间画像都是直播间的固有属性画像，直播间画像维表的建设过程是实时的。 由于大多数直播的时长都在几小时不等，随着直播的开始，主播域观众的互动也随即产生，从而直播生产和消费的指标也开始产出，随着直播的结束，主播和观众的互动也就结束了，对应的直播生产和消费指标也就不存在了，因此直播间画像的所能提供给其他指标作为维表的价值也就快速消失了，所以直播间画像（标题，开播地址）的应用场景特点就是时效性很强。因此直播间画像维表对于直播生产消费指标的建设和应用来说，需要满足可实时建设、可实时查询获取的要求。 主播 &amp; 观众用户画像维表结论：这类画像都是用户的固有属性画像，而非直播间固有属性，和直播间是非强相关的。主播 &amp; 观众用户画像维表的建设过程可以是离线的。 无论直播间的开播关播，直播过程中的生产消费，主播画像和观众画像基本上不会产生变动。（举例：大多数情况下，当已经判定一个用户的年龄段画像为 18 - 23 时，即使这个用户开了 10 场直播，或者这个用户观看了 10 场直播，其年龄段判定也基本不会有变化）。因此主播用户画像维表 &amp; 观众用户画像维表对于直播生产消费指标的建设和应用来说，可以满足离线 t + 1 建设，提供数据服务进行实时获取的要求。 Notes： 主播 &amp; 观众用户画像需要根据用户生产消费行为以及其他信息，使用到机器学习进行性别和年龄段等的用户画像信息判定产出。也有非常多的场景将这类画像进行实时建设，用于实时个性化推荐等。只不过本文的直播实时数据建设对于这两类画像的时效性要求较弱，所以采用了离线的方式进行建设。 HOW + WHO：怎样建设？用什么建设？直播间生命周期 &amp; 数据流转直播间整个生命周期如图所示。 1.主播创建直播间，直播间进入开播的状态； 2.观众进入直播间后，在直播间内与主播进行互动； 3.最后就是主播对直播间进行关播，标识着直播间生命周期的结束状态。 直播间画像维表-实时实时画像维表的建设。上图中红色的字体为实时画像维表的建设和应用过程。 直播间画像实时数据流转 1.当主播开播，直播间进行直播后，直播间产生了直播间画像信息，这时可以将画像信息实时的建设到直播间画像实时维表中。并且可以同时建设生产侧的实时指标，利用建设好的直播间画像实时维表 + 主播 &amp; 观众画像离线维表进行生产侧指标的维度填充； 2.当观众进入直播间后，与主播进行互动，产生一系列的消费行为，随即可以建设消费侧的实时指标，利用建设的直播间画像实时维表 + 主播 &amp; 观众画像离线维表进行消费侧指标的维度填充； 3.当主播对直播间进行关播的时候，从直播间画像实时维表中就可以对该直播间的画像进行删除。 组件选型通过上文的分析，可以了解到直播间画像实时维表建设的要求如下： 实时画像：首先需要支持实时建设，实时访问； 实时画像：建设的数据都为实时指标，即要求低延迟的请求响应时间； 公共画像：需要支撑多个大流量生产消费实时任务的访问请求，即提供高 QPS 画像数据服务； 公共画像：高稳定性。 因此组件选型就自然落在了高速缓存的范畴中，我们最后经过方案对比之后，选择了 redis 作为我们的实时维表的存储引擎。 使用了 redis 中的 hash 作为维表存储结构，其中直播间画像维度存储设计如下图。 flink 实时维表建设代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LiveStreamRealtimeDimBuilderJob &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); DataStream&lt;byte[]&gt; source = SourceFactory.getSourceDataStream(); source.process(new ProcessFunction&lt;byte[], String&gt;() &#123; @Override public void processElement(byte[] bytes, Context context, Collector&lt;String&gt; collector) throws Exception &#123; CommonModel c = CommonModel.parseFrom(bytes); // 开播 if (c.isStartLiveStream()) &#123; RedisConfig .get() .hmset(c.getLiveStreamId() , ImmutableMap.&lt;String, String&gt;builder() .put(&quot;type&quot;, c.getType()) .put(&quot;client&quot;, c.getClient()) .put(&quot;title&quot;, c.getTitle()) .put(&quot;address&quot;, c.getAddress()) .build() ); RedisConfig .get() .expire(c.getLiveStreamId(), 30 * 24 * 60 * 60); &#125; else if (c.isEndLiveStream()) &#123; // 关播 RedisConfig .get() .expire(c.getLiveStreamId(), 2 * 24 * 60 * 60); &#125; &#125; &#125;); env.execute(); &#125; @Data public static class CommonModel &#123; private String liveStreamId; // 直播间 id private String type; // 直播间类型 private String client; // 开播客户端 private String title; // 直播间标题 private String address; // 直播间开播地址 public static CommonModel parseFrom(byte[] bytes) &#123; // 逻辑根据业务逻辑判定 return null; &#125; public boolean isStartLiveStream() &#123; // 逻辑根据业务逻辑判定 return false; &#125; public boolean isEndLiveStream() &#123; // 逻辑根据业务逻辑判定 return false; &#125; &#125;&#125; 主播 &amp; 观众用户画像维表-离线离线画像维表的建设。主要包含主播和观众的用户画像，性别，年龄等信息。如下图蓝色的字体为离线画像维表的应用过程。 主播 &amp; 观众画像数据流转在产出直播间生产侧、消费侧实时数据时，使用主播 &amp; 观众画像进行了画像维度填充。 存储组件其中离线画像维表的存储组件选型与实时相同，同为 redis，画像信息存储方式也是使用 redis hash 结构进行存储。 以 t + 1 的方式进行画像数据建设并进行数据同步，将建设好的全量主播和观众用户画像同步到 redis 高速缓存当中。 总结本文衔接上文，主要介绍直播间实时维表的建设过程。提出几个建设的问题，以这几个问题出发，引出了一下三小节。 第一节简单介绍了实时 &amp; 离线公共画像维表的概念。 第二节从数据应用场景的角度出发，介绍了为什么需要建设实时的公共画像维表。 第三节主要介绍了实时画像维表的建设过程以及详细的技术方案。 最后一节对本文进行了总结。 如果你也建设过实时画像维表，或者有相同的需求，欢迎留言或者留下你的文章链接，相互交流~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | 基于 Flink 的直播实时数据建设 （一）| 需求和架构篇","date":"2020-10-12T06:21:53.000Z","path":"2020/10/12/wechat-blog/apache-flink:realtime-live-stream-1/","text":"生产实践 | 基于 Flink 的直播实时数据建设 （一）| 需求和架构篇 本系列每篇文章都是从一些实际生产实践需求出发，解决一些生产实践中的问题，抛砖引玉，以帮助小伙伴们解决一些实际生产问题。相信大家或多或少都观看过直播，那大家有没有想过，如果自己负责建设公司内整体直播实时数据，会怎样去建设呢？本系列文章主要介绍直播实时数据建设的整个过程，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 首先思考几个问题 WHAT：相信大家或多或少都观看过直播，甚至自己就是一名主播或负责的业务就是直播相关的，那大家有没有思考过，在直播业务场景中，你最关心什么指标以及需要关注、建设什么数据？ WHY：为什么需要建设直播实时数据？离线建设不能满足吗？ HOW：直播实时数据怎样赋能业务的？怎样根据公司直播场景的需求去划分直播实时数据？怎样去建设直播实时数据体？ WHO：在建设直播实时数据的过程中，需要使用什么样的组件进行建设？每个组件都负责哪一部分？ 让我们带着以上几个问题出发~ 直播 + 短视频，内容运营的下一个战场随着互联网络技术的发展，网络直播受到越来越多人的关注，直播在经过几年前的喷涌式大爆发之后，近段时间热度有所降低。内容的同质化和变现困难是直播现在面临的主要问题，随着移动终端普及和网络的提速，短视频以短平快的大流量传播方式快速获得各大平台、粉丝和资本的青睐，所以众多直播软件开始接入短视频的功能。同时，一些以短视频为主发展起来的 app 也在软件中加入了直播功能，直播和短视频两者互相弥补不足，相辅相成，给用户带来了更好的使用体验，也给各大平台带来更多的流量，”直播 + 短视频”的模式已经也成为新的发展趋势。 本系列文章主要围绕着直播实时数据建设而展开。本文是本系列文章的的第一篇，需求和架构篇，主要分为三个部分，按顺序为WHY - WHAT - HOW，以这三个角度出发，解答开头提出的三个问题，其中 WHO部分在本系列文章的后续建设细节章节进行介绍！ WHY：为什么建设直播实时数据？相比短视频的生产消费来说，直播的主播和观看直播的观众的纽带都是在直播间建立的，相互之间的互动行为也都只在直播间内产生，并且通常情况下，一场直播的时长也就在几个小时之内，因此直播的生产消费时效性相比短视频会更强，因而直播数据对于实时性的诉求也就更高。 WHAT：需要关注、建设什么直播实时数据？需要关注、建设什么直播实时数据？换一句话来说就是根据数据分析业务的需求出发，决定建设什么样的直播实时数据？ 直播就是一个主播和观众联络互动的纽带，其中一切操作都是围绕着主播和观众而展开的，数据分析的同学都会以这个最基础的角度出发进行分析，因此首先我们就可以将整个直播的数据按照直播生产和直播消费进最基本的划分。 除此角度之外，数据分析的同学也还会从全局直播业务洞察和单个直播间洞察不同粒度上进行分析洞察，因此还可以按照大盘数据、单直播间数据进行划分。 从这两个角度出发，基本可以涵盖对于直播业务分析场景的诉求，因此直播实时数据也自然可以从这两个角度进行划分和建设。 综上则整体直播实时数据业务划分和赋能应用架构如下图所示。 其中 直播大盘实时数据在宏观上监控直播业务，提供预测大盘的能力；其中分钟粒度时间序列可快速定位直播各行为的高峰时刻，可以基于该时刻进行详细归因。除此之外，当直播在做运营活动时，也能快速基于实时数据来看运营活动的活动效果，赋能活动策略实时优化。 单直播间直播实时数据可以以细粒度监控单直播间的直播业务，用来在直播过程中对外输出直播数据战报、以及可基于数据战报效果实时对单直播间进资源投放进行实时效果评估和合理调配。 详细的直播实时数据需求和样例如下文。 大盘生产侧 指标：总体开播直播间数… 维度：直播间画像、主播用户画像 举例：[开播直播间为游戏类直播]的[总开播主播数] 消费侧 指标：总体观众观看、点赞、评论数… 维度：观众用户画像、日志上报其他维度 举例：[目前在河北观看直播]的[总观众数] 单直播间生产侧单直播间一般都是一些画像信息，所以此类指标较少，暂时不做讨论。 消费侧 指标：单直播间观众观看、点赞、评论数… 维度：观众用户画像、日志上报其他维度 举例：某直播间[18-23岁年龄段]的[总观众数] 目前已经了解了要建设直播实时数据都包含了什么内容，接下来就是大干一场的时候了。 HOW：怎样去建设？怎样去建设？换一句话来说就是从技术的角度出发，怎样将直播实时数据的业务需求转化为直播实时数据的技术方案进行落地？ 从技术角度出发，上述直播实时数据需要建设的需求内容总结下来就是一个词：直播实时多维指标。 多维即产出指标是多维度的，包含公共维度和非公共维度。 第一类是公共维度。包含三部分，直播间画像，主播用户画像，观众用户画像，公共两字代表这类维度是可以被多个指标进行共享使用的。举例：某直播间开播之后，该直播间画像只需要一次建设，就可以被多个指标多次重复使用，不但可以作为大盘侧生产、消费指标的维度，也可以作为单直播间生产、消费指标的维度。 第二类是非公共维度。非公共维度是和特定消费行为绑定的，也就是和某个指标绑定的，随着日志上报一同上报的维度。举例：某观众观看直播时的客户端类型（安卓？IOS？），观看直播时的省份等维度，这类维度只和当前的消费行为相关，不能被其他指标所共享。 指标其实都是 pv，uv 类指标。简单理解就是各个维度下对应的 xx 量。 实时数据建设技术架构对应到直播实时数据建设的过程主要包含两部分：公共部分和非公共部分。 公共部分就是实时公共维表的建设。 非公共部分就是指标非公共维度以及对应生产、消费指标建设。 直接给出总体技术架构图，本系列后续的文章进行介绍这样进行整体架构设计的详细原因。 简单说明下。 其中数据源包含生产侧，消费侧数据源； 数据处理部分包含公共实时维表建设，和指标建设，其中一部分公共维表的建设也使用了离线的方式提供了支持； 最后就是数据汇部分，产出了生产侧，消费侧的多维指标供数据分析师使用。 下节预告下节主要介绍直播实时公共画像的建设，其中是技术架构图中的主播用户、关注用户画像、以及直播间画像的建设方案。 总结本文首先提出了几个关于直播实时数据建设的问题。以这几个问题触发，引出了一下三小节。 第一节简单介绍了直播时效性强的原因，因此直播对于实时数据的需求更加强烈。 第二节从数据分析的角度出发，引出了我们需要建设的直播实时数据都包含哪些内容，并且从大盘/单直播间，生产/消费角度进行了模块划分。 第三节对数据需求进行了技术方案的整体架构设计。 最后一节对本文进行了总结。 如果你也有相同的建设需求或者你以及建设了直播实时数据，欢迎留言或者留下你的文章链接，相互交流~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Tips | Flink 使用 union 代替 join、cogroup","date":"2020-10-03T06:21:53.000Z","path":"2020/10/03/wechat-blog/apache-flink:realtime-tips-2-union-join/","text":"Tips | Flink 使用 union 代替 join、cogroup 本系列每篇文章都比较短小，不定期更新，从一些实际的 case 出发抛砖引玉，提高小伙伴的姿♂势水平。本文介绍在满足原有需求、实现原有逻辑的场景下，在 Flink 中使用 union 代替 cogroup(或者join) ，简化任务逻辑，提升任务性能的方法，阅读时长大概一分钟，话不多说，直接进入正文！ 需求场景分析需求场景需求诱诱诱来了。。。数据产品妹妹想要统计单个短视频粒度的点赞，播放，评论，分享，举报五类实时指标，并且汇总成 photo_id、1 分钟时间粒度的实时视频消费宽表（即宽表字段至少为：photo_id + play_cnt + like_cnt + comment_cnt + share_cnt + negative_cnt + minute_timestamp）产出至实时大屏。 问题在于对同一个视频，五类视频消费行为的触发机制以及上报时间是不同，也就决定了对实时处理来说五类行为日志对应着五个不同的数据源。sql boy 们自然就想到了 join 操作将五类消费行为日志合并，可是实时 join(cogroup) 真的那么完美咩~，下文细谈。 source 输入以及特点首先我们分析下需求中的 source 特点： photo_id 粒度 play（播放）、like（点赞）、comment（评论）、share（分享）、negative（举报）明细数据，用户播放（点赞、评论…）n 次，客户端\\服务端就会上传 n 条播放（点赞、评论…）日志至数据源 五类视频消费行为日志的 source schema 都为：photo_id + timestamp + 其他维度 sink 输出以及特点sink 特点如下： photo_id 粒度 play（播放）、like（点赞）、comment（评论）、share（分享）、negative（举报）1 分钟级别窗口聚合数据 实时视频消费宽表 sink schema 为：photo_id + play_cnt + like_cnt + comment_cnt + share_cnt + negative_cnt + minute_timestamp source、sink 样例数据source 数据：| photo_id | timestamp | user_id | 说明 || ——— | – | ———– | ———– || 1 | 2020/10/3 11:30:33 | 3 | 播放 || 1 | 2020/10/3 11:30:33 | 4 | 播放 || 1 | 2020/10/3 11:30:33 | 5 | 播放 || 1 | 2020/10/3 11:30:33 | 4 | 点赞 || 2 | 2020/10/3 11:30:33 | 5 | 点赞 || 1 | 2020/10/3 11:30:33 | 5 | 评论 | sink 数据：| photo_id | timestamp | play_cnt | like_cnt | comment_cnt| ——— | – | ———– | ———– | ———– || 1 | 2020/10/3 11:30:00 | 3 | 1 | 1 || 2 | 2020/10/3 11:30:00 | 0 | 1 | 0 | 我们已经对数据源输入和输出有了完整的分析，那就瞧瞧有什么方案可以实现上述需求吧。 实现方案 方案1：本小节 cogroup 方案直接消费原始日志数据，对五类不同的视频消费行为日志使用 cogroup 或者 join 进行窗口聚合计算 方案2：对五类不同的视频消费行为日志分别单独聚合计算出分钟粒度指标数据，下游再对聚合好的指标数据按照 photo_id 进行合并 方案3：本小节 union 方案既然数据源 schema 相同，直接对五类不同的视频消费行为日志做 union 操作，在后续的窗口函数中对五类指标进行聚合计算。后文介绍 union 方案的设计过程 我们先上 cogroup 方案的示例代码。 cogroupcogroup 实现示例如下，示例代码直接使用了处理时间（也可替换为事件时间~），因此对数据源的时间戳做了简化（直接干掉）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Cogroup &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // Long -&gt; photo_id 播放一次 DataStream&lt;Long&gt; play = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 点赞一次 DataStream&lt;Long&gt; like = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 评论一次 DataStream&lt;Long&gt; comment = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 分享一次 DataStream&lt;Long&gt; share = SourceFactory.getDataStream(xxx); // Long -&gt; photo_id 举报一次 DataStream&lt;Long&gt; negative = SourceFactory.getDataStream(xxx); // Tuple3&lt;Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt 播放和点赞的数据合并 DataStream&lt;Tuple3&lt;Long, Long, Long&gt;&gt; playAndLikeCnt = play .coGroup(like) .where(KeySelectorFactory.get(Function.identity())) .equalTo(KeySelectorFactory.get(Function.identity())) .window(TumblingProcessingTimeWindows.of(Time.seconds(60))) .apply(xxx1); // Tuple4&lt;Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt 播放、点赞、评论的数据合并 DataStream&lt;Tuple4&lt;Long, Long, Long, Long, Long&gt;&gt; playAndLikeAndComment = playAndLikeCnt .coGroup(comment) .where(KeySelectorFactory.get(playAndLikeModel -&gt; playAndLikeModel.f0)) .equalTo(KeySelectorFactory.get(Function.identity())) .window(TumblingProcessingTimeWindows.of(Time.seconds(60))) .apply(xxx2); // Tuple5&lt;Long, Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt + share_cnt 播放、点赞、评论、分享的数据合并 DataStream&lt;Tuple5&lt;Long, Long, Long, Long, Long, Long&gt;&gt; playAndLikeAndCommentAndShare = playAndLikeAndComment .coGroup(share) .where(KeySelectorFactory.get(playAndLikeAndCommentModel -&gt; playAndLikeAndCommentModel.f0)) .equalTo(KeySelectorFactory.get(Function.identity())) .window(TumblingProcessingTimeWindows.of(Time.seconds(60))) .apply(xxx2); // Tuple7&lt;Long, Long, Long, Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt + share_cnt + negative_cnt + minute_timestamp 播放、点赞、评论、分享、举报的数据合并 // 同上~ DataStream&lt;Tuple7&lt;Long, Long, Long, Long, Long, Long, Long&gt;&gt; playAndLikeAndCommentAndShare = ***; env.execute(); &#125;&#125; 粗暴一想，上面这样一搞不就结束了么，事情没那么简单，我们来做一个详细点的分析。 上述实现可能会存在的问题点 从 flink 消费到 play 数据源的一条数据到最终产出这条数据被聚合后的数据，整个过程的数据延迟 &gt; 3 分钟… 如果数据源持续增加（比如添加其他视频消费操作数据源），则整个任务算子变多，数据链路更长，任务稳定性会变差，产出数据延迟也会随着窗口计算变多，延迟更久 数据产品妹妹：🤩，小哥哥好棒，既然问题点都分析出来了，技术小哥哥就帮人家解决一下嘛~ 头文字 ∩ 技术小哥哥：搞。 头文字 ∩ 技术小哥哥：既然可能由于过多的窗口导致数据产出延迟，job 不稳定，那有没有什么方法减少窗口数量呢，思路转换一下。我们直接以整个 job 中只包含一个窗口算子操作为基点，逆推一下，则有以下数据链路。 逆推链路1 - 5 为逆推的整条链路。 1.五类指标的数据都在单个窗口中计算 2.五类指标的窗口 model 相同 3.keyby 中的 key 一致（photo_id） 4.五类指标的数据源都为 photo_id 粒度，并且五类数据源的 model 都必须相同，并且可以做合并 5.union 算子可以对五类数据源做合并！！！ 话不多说直接上 union 方案代码。 union123456789101112131415161718192021222324252627282930public class Union &#123; public static void main(String[] args) throws Exception &#123; final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;PLAY&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; play = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;LIKE&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; like = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;COMMENT&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; comment = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;SHARE&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; share = SourceFactory.getDataStream(xxx); // Tuple2&lt;Long, String&gt; -&gt; photo_id + &quot;NEGATIVE&quot;标签 DataStream&lt;Tuple2&lt;Long, String&gt;&gt; negative = SourceFactory.getDataStream(xxx); // Tuple5&lt;Long, Long, Long, Long&gt; -&gt; photo_id + play_cnt + like_cnt + comment_cnt + window_start_timestamp DataStream&lt;Tuple3&lt;Long, Long, Long&gt;&gt; playAndLikeCnt = play .union(like) .union(comment) .union(share) .union(negative) .keyBy(KeySelectorFactory.get(i -&gt; i.f0)) .timeWindow(Time.seconds(60)) .process(xxx); env.execute(); &#125;&#125; 可以发现，无论上游数据源怎样进行变化，上述 union 方案中始终可以保持只有一个窗口算子处理和计算数据，则可以解决之前列举的数据延迟以及 flink 任务算子过多的问题。 在数据源的 schema 相同（或者不同但经过处理之后可以 format 成相同格式）的情况下，或者处理逻辑相同的话，可以使用 union 进行逻辑简化。 总结本文首先介绍了我们的需求场景，第二部分分析了使用 cogroup（案例代码）是如何解决此需求场景，再分析了此实现方案可能会存在一些问题，并引出了 union 解决方案的逆推和设计思路。在第三部分针对此场景使用 union 代替 cogroup 进行了一定程度上的优化。如果针对此场景，大佬们有更好的优化方案的话，期待留言喔。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"踩坑记 | Flink 天级别窗口中存在的时区问题","date":"2020-10-03T06:21:53.000Z","path":"2020/10/03/wechat-blog/apache-flink:realtime-tips-3-utc/","text":"踩坑记 | Flink 天级别窗口中存在的时区问题 本系列每篇文章都是从一些实际的 case 出发，分析一些生产环境中经常会遇到的问题，抛砖引玉，以帮助小伙伴们解决一些实际问题。本文介绍 Flink 时间以及时区问题，分析了在天级别的窗口时会遇到的时区问题，如果对小伙伴有帮助的话，欢迎点赞 + 再看~ 本文主要分为两部分： 第一部分（第 1 - 3 节）的分析主要针对 flink，分析了 flink 天级别窗口的中存在的时区问题以及解决方案。 第二部分（第 4 节）的分析可以作为所有时区问题的分析思路，主要以解决方案中的时区偏移量为什么是加 8 小时为案例做了通用的深度解析。 为了让读者能对本文探讨的问题有一个大致了解，本文先给出问题 sql，以及解决方案。后文给出详细的分析~ 1.问题以及解决方案问题 sqlsql 很简单，用来统计当天累计 uv。 12345678910111213141516171819--------------- 伪代码 ---------------INSERT INTO kafka_sink_tableSELECT -- 窗口开始时间 CAST( TUMBLE_START(proctime, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, -- 当前记录处理的时间 cast(max(proctime) AS BIGINT) AS current_ts, -- 每个桶内的 uv count(DISTINCT id) AS part_daily_full_uvFROM kafka_source_tableGROUP BY mod(id, bucket_number), -- bucket_number 为常数，根据具体场景指定具体数值 TUMBLE(proctime, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 你是否能一眼看出这个 sql 所存在的问题？（PS：数据源以及数据汇时区都为东八区） 没错，天级别窗口所存在的时区问题，即这段代码统计的不是楼主所在东八区一整天数据的 uv，这段代码统计的一整天的范围在东八区是第一天早 8 点至第二天早 8 点。 解决方案楼主目前所处时区为东八区，解决方案如下： 12345678910111213141516171819202122232425--------------- 伪代码 ---------------CREATE VIEW view_table ASSELECT id, -- 通过注入时间解决 -- 加上东八区的时间偏移量，设置注入时间为时间戳列 CAST(CURRENT_TIMESTAMP AS BIGINT) * 1000 + 8 * 60 * 60 * 1000 as ingest_timeFROM source_table;INSERT INTO target_tableSELECT CAST( TUMBLE_START(ingest_time, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, cast(max(ingest_time) AS BIGINT) - 8 * 3600 * 1000 AS current_ts, count(DISTINCT id) AS part_daily_full_uvFROM view_tableGROUP BY mod(id, 1024), -- 根据注入时间划分天级别窗口 TUMBLE(ingest_time, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 通过上述方案，就可以将统计的数据时间范围调整为东八区的今日 0 点至明日 0 点。下文详细说明整个需求场景以及解决方案的实现和分析过程。 2.需求场景以及实现方案需求场景coming，需求场景比较简单，就是消费上游的一个埋点日志数据源，根据埋点中的 id 统计当天 0 点至当前时刻的累计 uv，按照分钟级别产出到下游 OLAP 引擎中进行简单的聚合，最后在 BI 看板进行展示，没有任何维度字段（感动到哭😭）。 数据链路以及组件选型客户端用户行为埋点日志 -&gt; logServer -&gt; kafka -&gt; flink（sql） -&gt; kafka -&gt; druid -&gt; BI 看板。 实现方案以及具体的实现方式很多，这次使用的是 sql API。 flink sql schemasource 和 sink 表 schema 如下（只保留关键字段）： 12345678910111213141516171819202122--------------- 伪代码 ---------------CREATE TABLE kafka_sink_table ( -- 天级别窗口开始时间 window_start BIGINT, -- 当前记录处理的时间 current_ts BIGINT, -- 每个桶内的 uv（处理过程对 id 进行了分桶） part_daily_full_uv BIGINT) WITH ( -- ... );CREATE TABLE kafka_source_table ( -- ... -- 需要进行 uv 计算的 id id BIGINT, -- 处理时间 proctime AS PROCTIME()) WITH ( -- ... );--------------- 伪代码 --------------- flink sql transform12345678910111213141516171819--------------- 伪代码 ---------------INSERT INTO kafka_sink_tableSELECT -- 窗口开始时间 CAST( TUMBLE_START(proctime, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, -- 当前记录处理的时间 cast(max(proctime) AS BIGINT) AS current_ts, -- 每个桶内的 uv count(DISTINCT id) AS part_daily_full_uvFROM kafka_source_tableGROUP BY mod(id, bucket_number), -- bucket_number 为常数，根据具体场景指定具体数值 TUMBLE(proctime, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 使用 early-fire 机制（同 DataStream API 中的 ContinuousProcessingTimeTrigger），并设定触发间隔为 60 s。 在上述实现 sql 中，我们对 id 进行了分桶，那么每分钟输出的数据条数即为 bucket_number 条，最终在 druid 中按照分钟粒度将所有桶的数据进行 sum 聚合，即可得到从当天 0 点累计到当前分钟的全量 uv。 时区问题 激情场景还原： 头文字 ∩ 技术小哥哥：使用 sql，easy game，闲坐摸鱼… 头文字 ∩ 技术小哥哥：等到 00:00 时，发现指标还在不停地往上涨，难道是 sql 逻辑错了，不应该啊，试过分钟，小时级别窗口都木有这个问题 头文字 ∩ 技术小哥哥：抠头ing，算了，稍后再分析这个问题吧，现在还有正事要干😏 头文字 ∩ 技术小哥哥：到了早上，瞅了一眼配置的时间序列报表，发现在 08:00 点的时候指标归零，重新开始累计。想法一闪而过，东八区？（当时为啥没 format 下 sink 数据中的 window_start…） 3.问题定位问题说明flink 在使用时间的这个概念的时候是基于 java 时间纪元（即格林威治 1970/01/01 00:00:00，也即 Unix 时间戳为 0）概念的，窗口对齐以及触发也是基于 java 时间纪元。 问题场景复现可以通过直接查看 sink 数据的 window_start 得出上述结论。 但为了还原整个过程，我们按照如下 source 和 sink 数据进行整个问题的复现： source 数据如下：| id | proctime | proctime UTC + 0（格林威治） 格式化时间 | proctime UTC + 8（北京） 格式化时间| ——— | – | – | – || 1 | 1599091140000 | 2020/09/02 23:59:00 | 2020/09/03 07:59:00 || 2 | 1599091140000 | 2020/09/02 23:59:00 | 2020/09/03 07:59:00 || 3 | 1599091140000 | 2020/09/02 23:59:00 | 2020/09/03 07:59:00 || 1 | 1599091200000 | 2020/09/03 00:00:00 | 2020/09/03 08:00:00 || 2 | 1599091200000 | 2020/09/03 00:00:00 | 2020/09/03 08:00:00 || 3 | 1599091260000 | 2020/09/03 00:01:00 | 2020/09/03 08:01:00 | sink 数据（为了方便理解，直接按照 druid 聚合之后的数据展示）：| window_start | current_ts | part_daily_full_uv | window_start UTC + 8（北京） 格式化时间 | current_ts UTC + 8（北京） 格式化时间| ——— | – | ———– | ———– | ———– || 1599004800000 | 1599091140000 | 3 | 2020/09/02 08:00:00 | 2020/09/03 07:59:00 || 1599091200000 | 1599091200000 | 2 | 2020/09/03 08:00:00 | 2020/09/03 08:00:00 || 1599091200000 | 1599091260000 | 3 | 2020/09/03 08:00:00 | 2020/09/03 08:01:00 | 从上述数据可以发现，天级别窗口开始时间在 UTC + 8（北京）的时区是每天早上 8 点，即 UTC + 0（格林威治）的凌晨 0 点。 下文先给出解决方案，然后详细解析各个时间以及时区概念~ 解决方案 框架层面解决：Blink Planner 支持时区设置 sql层面解决：从 sql 实现层面给出解决方案 sql 层面解决方案12345678910111213141516171819202122232425--------------- 伪代码 ---------------CREATE VIEW view_table ASSELECT id, -- 通过注入时间解决 -- 加上东八区的时间偏移量，设置注入时间为时间戳列 CAST(CURRENT_TIMESTAMP AS BIGINT) * 1000 + 8 * 60 * 60 * 1000 as ingest_timeFROM source_table;INSERT INTO target_tableSELECT CAST( TUMBLE_START(ingest_time, INTERVAL &#x27;1&#x27; DAY) AS bigint ) AS window_start, cast(max(ingest_time) AS BIGINT) - 8 * 3600 * 1000 AS current_ts, count(DISTINCT id) AS part_daily_full_uvFROM view_tableGROUP BY mod(id, 1024), -- 根据注入时间划分天级别窗口 TUMBLE(ingest_time, INTERVAL &#x27;1&#x27; DAY)--------------- 伪代码 --------------- 我目前所属的时区是东八区（北京时间），通过上述 sql，设置注入时间，并对注入时间加上 8 小时的偏移量进行天级别窗口的划分，就可以对此问题进行解决（也可以在 create table 时，在 schema 中根据计算列添加对应的注入时间戳进行解决）。如果你在 sql 层面有更好的解决方案，欢迎讨论~ Notes： 东 n 区的解决方案就是时间戳 +n * 3600 秒的偏移量，西 n 区的解决方案就是时间戳 -n * 3600 秒的偏移量 DataStream API 存在相同的天级别窗口时区问题 这里提出一个问题，为什么东八区是需要在时间戳上加 8 小时偏移量进行天级别窗口计算，而不是减 8 小时或是加上 32（24 + 8） 小时，小伙伴们有详细分析过嘛~ 根据上述问题，引出本文的第二大部分，即深度解析时区偏移量问题，这部分可以作为所有时区问题的分析思路。 4.为什么东八区是加 8 小时？时间和时区基本概念时区：由于世界各国家与地区经度不同，地方时也有所不同，因此会划分为不同的时区。 Unix 时间戳(Unix timestamp)： Unix 时间戳(Unix timestamp)，或称 Unix 时间(Unix time)、POSIX 时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒（UTC/GMT的午夜）起至现在的总秒数。Unix 时间戳不仅被使用在 Unix 系统、类 Unix 系统中，也在许多其他操作系统中被广泛采用。 GMT：Greenwich Mean Time 格林威治标准时间。这是以英国格林威治天文台观测结果得出的时间，这是英国格林威治当地时间，这个地方的当地时间过去被当成世界标准的时间。 UT：Universal Time 世界时。根据原子钟计算出来的时间。 UTC：Coordinated Universal Time 协调世界时。因为地球自转越来越慢，每年都会比前一年多出零点几秒，每隔几年协调世界时组织都会给世界时 +1 秒，让基于原子钟的世界时和基于天文学（人类感知）的格林威治标准时间相差不至于太大。并将得到的时间称为 UTC，这是现在使用的世界标准时间。协调世界时不与任何地区位置相关，也不代表此刻某地的时间，所以在说明某地时间时要加上时区也就是说 GMT 并不等于 UTC，而是等于 UTC + 0，只是格林威治刚好在 0 时区上。 白话时间和时区当时看完这一系列的时间以及时区说明之后我大脑其实是一片空白。…ojbk…，我用自己现在的一些理解，尝试将上述所有涉及到时间的概念解释一下。 GMT：格林威治标准时间。 UTC：基于原子钟协调之后的世界标准时间。可以认为 UTC 时间和格林威治标准时间一致。即 GMT = UTC + 0，其中 0 代表格林威治为 0 时区。 时区：逆向思维来解释下（只从技术层面解释，不从其他复杂层面解释），没有时区划分代表着全世界都是同一时区，那么同一时刻看到的外显时间是一样的。举个🌰：假如全世界都按照格林威治时间作为统一时间，在格林威治时间 0 点时，对于北京和加拿大的两个同学来说，这两个同学感知到的是北京是太阳刚刚升起（清晨），加拿大是太阳刚刚落下（傍晚）。但是由于没有时区划分，这两个同学看到的时间都是 0 点，因此这是不符合人类对感知到的时间和自己看到的时间的理解的。所以划分时区之后，可以满足北京（东八区 UTC + 8）同学看到的时间是上午 8 点，加拿大（西四区 UTC - 4）同学看到的时间是下午 8 点。注意时区的划分是和 UTC 绑定的。东八区即 UTC + 8。 flink 时间：flink 使用的时间基于 java 时间纪元（GMT 1970/01/01 00:00:00，UTC + 0 1970/01/01 00:00:00）。 Unix 时间戳：世界上任何一个地方，同时接收到的数据的对应的 Unix 时间戳都是相同的，类似时区中我们举的不分时区的🌰，全世界同一时刻的 Unix 时间戳一致。 Unix 时间戳为 0：对应的格林威治时间：1970-01-01 00:00:00，对应的北京时间（东八区）：1970-01-01 08:00:00** 概念关系如图所示： 为什么东八区是加 8 小时？下述表格只对一些重要的时间进行了标注： Unix 时间戳 格林威治时间（外显） 北京时间（外显） -8 * 3600 - 1970/01/01 00:00:00 0 1970/01/01 00:00:00 1970/01/01 08:00:00 16 * 3600 - 1970/01/02 00:00:00 24 * 3600 1970/01/02 00:00:00 - 拿第一条数据解释下，其代表在北京时间 1970/01/01 00:00:00 时，生成的一条数据所携带的 Unix 时间戳为 -8 * 3600。 根据需求和上图和上述表格内容，我们可以得到如下推导过程： 需求场景是统计一个整天的 uv，即天级别窗口，比如统计北京时间 1970/01/01 00:00:00 - 1970/01/02 00:00:00 范围的数据时，这个日期范围内的数据所携带的 Unix 时间戳范围为 -8 * 3600 到 16 * 3600 对于 flink 来说，默认情况下它所能统计的一个整天的 Unix 时间戳的范围是 0 到 24 * 3600 所以当我们想通过 flink 实现正确统计北京时间（1970/01/01 00:00:00 - 1970/01/02 00:00:00）范围内的数据时，即统计 Unix 时间戳为 -8 * 3600 到 16 * 3600 的数据时，就需要对时间戳做个映射。 映射方法如下，就是将整体范围内的时间戳做在时间轴上做平移映射，就是把 -8 * 3600 映射到 0，16 * 3600 映射到 24 * 3600。相当于是对北京时间的 Unix 时间戳整体加 8 * 3600。 最后在产出的时间戳上把加上的 8 小时再减掉（因为外显时间会自动按照时区对 Unix 时间戳进行格式化）。 Notes： 可以加 32 小时吗？答案是可以。在东八区，对于天级别窗口的划分，加 8 小时和加 8 + n * 24（其中 n 为整数）小时后进行的天级别窗口划分和计算的效果是一样的，flink 都会将东八区的整一天内的数据划分到一个天级别窗口内。所以加 32（8 + 24），56（8 + 48），-16（8 - 24）小时效果都相同，上述例子只是选择了时间轴平移最小的距离，即 8 小时。注意某些系统的 Unix 时间戳为负值时会出现异常。 此推理过程适用于所有遇到时区问题的场景，如果你也有其他应用场景有这个问题，也可以按照上述方式解决 Appendix求输入 Unix 时间戳对应的东八区每天 0 点的 Unix 时间戳。 12345public static final long ONE_DAY_MILLS = 24 * 60 * 60 * 1000L;public static long transform(long timestamp) &#123; return timestamp - (timestamp + 8 * 60 * 60 * 1000) % ONE_DAY_MILLS;&#125; 5.总结本文首先介绍了直接给出了我们的问题 sql 和解决方案。 第二节从需求场景以及整个数据链路的实现方案出发，解释了我们怎样使用 flink sql 进行了需求实现，并进而引出了 sql 中天级别窗口存在的时区问题。 第三节确认了天级别窗口时区问题原因，引出了 flink 使用了 java 时间纪元，并针对此问题给出了引擎层面和 sql 层面的解决方案。也进而提出了一个问题：为什么我们的解决方案是加 8 小时偏移量？ 第四节针对加 8 小时偏移量的原因进行了分析，并详细阐述了时区，UTC，GMT，Unix 时间戳之间的关系。 最后一节对本文进行了总结。 如果你有更方便的时区偏移量理解方式，欢迎留言~","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Tips | Flink sink schema 字段设计小技巧","date":"2020-09-12T06:21:53.000Z","path":"2020/09/12/wechat-blog/apache-flink:realtime-tips-1/","text":"Tips | Flink sink schema 字段设计小技巧 本系列每篇文章都比较短小，不定期更新，从一些实际的 case 出发抛砖引玉，提高小伙伴的姿♂势水平。本文介绍 Flink sink schema 字段设计小技巧，阅读时长大概 2 分钟，话不多说，直接进入正文！ sink schema 中添加 version 版本字段如 title，直接上实践案例和使用方式。 实践案例及使用方式 非故障场景下产出的每条记录的 version 字段值为 1 故障场景下，可以在同一 sink 中产出 version &gt; 1（非 1）的数据，代表故障修复数据提供给下游消费 可应对的故障场景上游 flink 任务 A 发生故障导致产出脏数据至 kafka X，并且下游消费方可以按照下面两类进行划分： 下游为 flink 任务：flink 任务 B 消费 kafka X 中的脏数据，结果计算并产出错误数据 下游为 OLAP 引擎以及 BI 看板：结果导致看板展示数据异常 首先介绍下避免以及处理上述问题的整体思路： 1.优化逻辑，保障上游任务稳定性：首先通过一些优化手段，尽可能保证上游 flink 任务 A 不出现故障 2.配置作业监控报警：针对整条链路配置对应的监控报警等，以及时发现和定位问题 3.制定故障处理、修复预案：需要制定对应的故障处理、修复预案，一旦出现故障，需要有可处理故障的能力 4.下游针对数据源特性改进消费和处理方式：保障即使消费了脏数据也不会对业务逻辑产生影响 下文主要介绍第 2 点，出现上述故障时修复的方案，针对以上场景，目前有如下 3 种可选方案修复数据： 方案 1 - 离线方式修复：通过离线方式产出修复数据，对脏数据进行覆盖操作。缺点是故障修复延迟较高，需要切换离线、实时数据源，人工操作成本较高 方案 2 - 实时方式修复：重跑修数逻辑，产出修复数据至 kafka X-fix，下游 flink 任务 B 重新从 kafka X-fix 中的指定 offset 开始消费，计算并产出正确的数据。此方案对下游 flink 任务 B 来说，需要改动代码逻辑，存在修数 topic 和原 topic 切换逻辑，修复逻辑较为复杂 方案 3 - 实时方式修复（本小节 version 字段方案）：为避免下游产生数据源切换操作带来的高成本操作，可在原有 kafka topic 中产出修复数据，通过 version 字段区分正常产出数据以及修复数据，相对方案 1 和 2 的优点在于，不存在数据源切换逻辑，下游通过控制 version 字段值就可消费到对应的修复数据，明显降低人工操作成本，且修复逻辑相对简单 Note: 方案 3 需要对 Kafka X 预留一定的 buffer，否则在产出修复数据时，由于写入或读出 Kafka X 的 QPS 过高，会影响正常产出数据的任务。 sink schema 中添加时间戳字段实践案例及使用方式有窗口场景中，sink schema 中可添加以下字段： flink_process_start_time(long)：代表 flink 窗口开始逻辑处理的时间戳 flink_process_end_time(long)：代表 flink 窗口结束逻辑处理的时间戳 window_start(long)：代表 flink 窗口开始时间戳 window_end(long)：代表 flink 窗口结束时间戳 生产实践案例 flink_process_start_time，flink_process_end_time 在开发、测试、验数阶段可帮助用户定位数据偏差原因 window_start，window_end 可以帮助用户定位每个窗口处理是否有丢数，及每个窗口处理的具体数据 总结本文主要介绍了在 sink schema 中添加 version（版本），时间戳扩展字段的小技巧，以帮助用户在生产环境中提升实时数据故障修复效率以及可用性。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Tips | flink watermark 一定只能用时间戳衡量？？？","date":"2020-09-12T06:21:53.000Z","path":"2020/09/12/wechat-blog/apache-flink:realtime-tips-4-watermark/","text":"本系列每篇文章都比较短小，不定期更新，从一些实际的 case 出发抛砖引玉，提高小伙伴的姿♂势水平。本文从另一种角度介绍 flink 的 watermark，阅读时长大概 2 分钟，话不多说，直接进入正文！ 关于 watermarkNicki是某一线互联网大厂的数据开发， 最近由于公司业务的发展，以及业务对数据实时性要求变高，Nicki 开始使用 flink 进行实时数据开发， 今天Nicki 在使用 flink datastream api 进行开发，当她写万 watermark 分配器之后，突然有了一个疑问，watermark 的分配只能使用时间戳吗？ 带着这个疑问Nicki 找到了 lsp 数据羊。 结论时间戳作为 watermark 的原因时间戳是我们最常用的标识以及分析方式 但是可以作为 watermark 的不止时间戳","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"踩坑记 | Flink 事件时间语义下数据乱序丢数踩坑","date":"2020-09-11T06:21:53.000Z","path":"2020/09/11/wechat-blog/apache-flink:realtime-out-of-order/","text":"踩坑记 | Flink 事件时间语义下数据乱序丢数踩坑 本文详细介绍了在上游使用处理时间语义的 flink 任务出现故障后，重启消费大量积压在上游的数据并产出至下游数据乱序特别严重时，下游 flink 任务使用事件时间语义时遇到的大量丢数问题以及相关的解决方案。 本文分为以下几个部分： 1.本次踩坑的应用场景 2.应用场景中发生的丢数故障分析 3.待修复的故障点 4.丢数故障解决方案及原理 5.总结 应用场景应用场景如下： flink 任务 A 以处理时间语义做过滤产出新增 xx 明细数据至 Kafka Y flink 任务 B 以事件时间语义消费 Kafka Y 做窗口聚合操作产出分钟级别聚合指标至 Kafka Z Kafka Z 实时导入至 Druid 以做即时 OLAP 分析，并且展示在 BI 应用看板 丢数故障分析简要介绍下这次生产中故障场景。整条故障追踪链路如下： 故障一： 收到报警反馈 flink 任务 A 入口流量为 0 定位 flink 任务 A 中某个算子的故障导致整个 job 卡住 导致此 flink 任务 A 上游 kafka X 积压了大量数据 重启 flink 任务 A后，消费大量积压在上游 kafka X 数据完成，任务恢复正常 故障一从而引发下游的故障二： 由于 flink 任务 A 使用了处理时间语义处理数据，并且有过滤和 keyBy 分桶窗口逻辑，在重启后消费大量积压在上游的数据时，导致 sink rebalance 后产出到下游 kafka Y 各个分区数据中的 server_timestamp 是乱序的 下游 flink 任务 B 在消费 Kafka Y 时使用了事件时间语义处理数据，并且使用了数据中的 server_timestamp 作为事件时间时间戳 flink 任务 B 消费了乱序很严重的数据之后，导致在窗口聚合计算时丢失了大量数据 最终展示在 BI 应用中的报表有丢失数据的情况 待修复的故障点 1.flink 任务 A 的稳定性故障，这部分解决方案暂不在本文中介绍 2.flink 任务 B 消费上游乱序丢数故障，解决方案在下文介绍 解决方案以及原理丢数故障解决方案解决方案是以下游 flink 任务 B 作为切入点，直接给出 flink 任务 B 的 sql 代码解决方案，java code 也可以按照这个方案实现，其本质原理相同。下文进行原理解释。 123456789SELECT to_unix_timestamp(server_timestamp / bucket) AS timestamp, -- format 成原有的事件时间戳 count(id) as id_cnt, sum(duration) as duration_sumFROM source_tableGROUP BY TUMBLE(proctime, INTERVAL &#x27;1&#x27; MINUTE), server_timestamp / bucket -- 根据事件时间分桶计算，将相同范围（比如 1 分钟）事件时间的数据分到一个桶内 解决方案原理首先明确一个无法避免的问题，在不考虑 watermark 允许延迟设置特别大的情况下，只要上游使用到了处理时间语义，下游使用事件时间语义，一旦上游发生故障重启并在短时间内消费大量数据，就不可避免的会出现上述错误以及故障。 在下游消费方仍然需要将对应事件时间戳的数据展示在 BI 平台报表中、并且全链路时间语义都为处理时间保障不丢数的前提下。解决方案就是在聚合并最终产出对应事件时间戳的数据。 最后的方案如下：整条链路全部为处理时间语义，窗口计算也使用处理时间，但是产出数据中的时间戳全部为事件时间戳。在出现故障的场景下，一分钟的窗口内的数据的事件时间戳可能相差几个小时，但在最终窗口聚合时可以根据事件时间戳划分到对应的事件时间窗口内，下游 BI 应用展示时使用此事件时间戳即可。 注意：sql 中的 bucket 需要根据具体使用场景进行设置，如果设置过于小，比如非故障场景下按照处理时间开 1 分钟的窗口，bucket设为 60000（1 分钟），那么极有可能，这个时间窗口中所有数据的 server_timestamp 都集中在某两分钟内，那么这些数据就会被分到两个桶（bucket）内，则会导致严重的数据倾斜。 输入数据样例模拟上述故障，flink B 的任务某一个窗口内的数据输入如下。 server_timestamp id duration 2020/9/01 21:14:38 1 300 2020/9/01 21:14:50 1 500 2020/9/01 21:25:38 2 600 2020/9/01 21:25:38 3 900 2020/9/01 21:25:38 2 800 输出数据样例按照上述解决方案中的 sql 处理过后，输出数据如下，则可以解决此类型丢数故障。 timestamp id_cnt duration_sum 2020/9/01 21:14:00 2 900 2020/9/01 21:25:00 3 2300 总结本文分析了在 flink 应用中： 上游使用处理时间语义的 flink 任务出现故障、重启消费大量积压数据并产出至下游数据乱序特别严重时，下游使用事件时间语义时遇到的大量丢数问题 以整条链路为处理时间语义的前提下，产出的数据时间戳为事件时间戳解决上述问题 以 sql 代码给出了丢数故障解决方案样例 学习资料flink https://github.com/flink-china/flink-training-course/blob/master/README.md https://ververica.cn/developers-resources/ https://space.bilibili.com/33807709","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"生产实践 | 基于 Flink 的短视频生产消费监控","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/apache-flink:realtime-monitor-video/","text":"生产实践 | 基于 Flink 的短视频生产消费监控 本文详细介绍了实时监控类指标的数据流转链路以及技术方案，大多数的实时监控类指标都可按照本文中的几种方案实现。 短视频生产消费监控短视频带来了全新的传播场域和节目形态，小屏幕、快节奏成为行业潮流的同时，也催生了新的用户消费习惯，为创作者和商户带来收益。而多元化的短视频也可以为品牌方提供营销机遇。 其中对于垂类生态短视频的生产消费热点的监控分析目前成为了实时数据处理很常见的一个应用场景，比如对某个圈定的垂类生态下的视频生产或者视频消费进行监控，对热点视频生成对应的优化推荐策略，促进热点视频的生产或者消费，构建整个生产消费数据链路的闭环，从而提高创作者收益以及消费者留存。 本文将完整分析垂类生态短视频生产消费数据的整条链路流转方式，并基于 Flink 提供几种对于垂类视频生产消费监控的方案设计。通过本文，你可以了解到： 垂类生态短视频生产消费数据链路闭环 实时监控短视频生产消费的方案设计 不同监控量级场景下的代码实现 flink 学习资料 项目简介垂类生态短视频生产消费数据链路流转架构图如下，此数据流转图也适用于其他场景： 在上述场景中，用户生产和消费短视频，从而客户端、服务端以及数据库会产生相应的行为操作日志，这些日志会通过日志抽取中间件抽取到消息队列中，我们目前的场景中是使用 Kafka 作为消息队列；然后使用 flink 对垂类生态中的视频进行生产或消费监控（内容生产通常是圈定垂类作者 id 池，内容消费通常是圈定垂类视频 id 池），最后将实时聚合数据产出到下游；下游可以以数据服务，实时看板的方式展现，运营同学或者自动化工具最终会帮助我们分析当前垂类下的生产或者消费热点，从而生成推荐策略。 方案设计 其中数据源如下： Kafka 为全量内容生产和内容消费的日志。 Rpc/Http/Mysql/配置中心/Redis/HBase 为需要监控的垂类生态内容 id 池（内容生产则为作者 id 池，内容消费则为视频 id 池），其主要是提供给运营同学动态配置需要监控的 id 范围，其可以在 flink 中进行实时查询，解析运营同学想要的监控指标范围，以及监控的指标和计算方式，然后加工数据产出，可以支持随时配置，实时数据随时计算产出。 其中数据汇为聚类好的内容生产或者消费热点话题或者事件指标： Redis/HBase 主要是以低延迟（Redis 5ms p99，HBase 100ms p99，不同公司的服务能力不同）并且高 QPS 提供数据服务，给 Server 端或者线上用户提供低延迟的数据查询。 Druid/Mysql 可以做为 OLAP 引擎为 BI 分析提供灵活的上卷下钻聚合分析能力，供运营同学配置可视化图表使用。 Kafka 可以以流式数据产出，从而提供给下游继续消费或者进行特征提取。 废话不多说，我们直接上方案和代码，下述几种方案按照监控 id 范围量级区分，不同的量级对应着不同的方案，其中的代码示例为 ProcessWindowFunction，也可以使用 AggregateFunction 代替，其中主要监控逻辑都相同。 方案 1适合监控 id 数据量小的场景（几千 id），其实现方式是在 flink 任务初始化时将需要监控的 id 池或动态配置中心的 id 池加载到内存当中，之后只需要在内存中判断内容生产或者消费数据是否在这个监控池当中。 12345678910111213141516171819ProcessWindowFunction p = new ProcessWindowFunction&lt;CommonModel, CommonModel, Long, TimeWindow&gt;() &#123; // 配置中心动态 id 池 private Config&lt;Set&lt;Long&gt;&gt; needMonitoredIdsConfig; @Override public void open(Configuration parameters) throws Exception &#123; this.needMonitoredIdsConfig = ConfigBuilder .buildSet(&quot;needMonitoredIds&quot;, Long.class); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;CommonModel&gt; iterable, Collector&lt;CommonModel&gt; collector) throws Exception &#123; Set&lt;Long&gt; needMonitoredIds = needMonitoredIdsConfig.get(); /** * 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 */ &#125;&#125; 监控的 id 池可以按照固定或者可配置从而分出两种获取方式：第一种是在 flink 任务开始时就全部加载进内存中，这种方式适合监控 id 池不变的情况；第二种是使用动态配置中心，每次都从配置中心访问到最新的监控 id 池，其可以满足动态配置或者更改 id 池的需求，并且这种实现方式通常可以实时感知到配置更改，几乎无延迟。 方案 2适合监控 id 数据量适中（几十万 id），监控数据范围会不定时发生变动的场景。其实现方式是在 flink 算子中定时访问接口获取最新的监控 id 池，以获取最新监控数据范围。 1234567891011121314151617181920212223242526272829ProcessWindowFunction p = new ProcessWindowFunction&lt;CommonModel, CommonModel, Long, TimeWindow&gt;() &#123; private long lastRefreshTimestamp; private Set&lt;Long&gt; needMonitoredIds; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.refreshNeedMonitoredIds(System.currentTimeMillis()); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;CommonModel&gt; iterable, Collector&lt;CommonModel&gt; collector) throws Exception &#123; long windowStart = context.window().getStart(); this.refreshNeedMonitoredIds(windowStart); /** * 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 */ &#125; public void refreshNeedMonitoredIds(long windowStart) &#123; // 每隔 10 秒访问一次 if (windowStart - this.lastRefreshTimestamp &gt;= 10000L) &#123; this.lastRefreshTimestamp = windowStart; this.needMonitoredIds = Rpc.get(...) &#125; &#125;&#125; 根据上述代码实现方式，按照时间间隔的方式刷新 id 池，其缺点在于不能实时感知监控 id 池的变化，所以刷新时间可能会和需求场景强耦合（如果 id 池会频繁更新，那么就需要缩小刷新时间间隔）。也可根据需求场景在每个窗口开始前刷新 id 池，这样可保证每个窗口中的 id 池中的数据一直保持更新。 方案 3方案 3 对方案 2 的一个优化（几十万 id，我们生产环境中最常用的）。其实现方式是在 flink 中使用 broadcast 算子定时访问监控 id 池，并将 id 池以广播的形式下发给下游参与计算的各个算子。其优化点在于：比如任务的并行度为 500，每 1s 访问一次，采用方案 2 则访问监控 id 池接口的 QPS 为 500，在使用 broadcast 算子之后，其访问 QPS 可以减少到 1，可以大大减少对接口的访问量，减轻接口压力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Example &#123; @Slf4j static class NeedMonitorIdsSource implements SourceFunction&lt;Map&lt;Long, Set&lt;Long&gt;&gt;&gt; &#123; private volatile boolean isCancel; @Override public void run(SourceContext&lt;Map&lt;Long, Set&lt;Long&gt;&gt;&gt; sourceContext) throws Exception &#123; while (!this.isCancel) &#123; try &#123; TimeUnit.SECONDS.sleep(1); Set&lt;Long&gt; needMonitorIds = Rpc.get(...); // 可以和上一次访问的数据做比较查看是否有变化，如果有变化，才发送出去 if (CollectionUtils.isNotEmpty(needMonitorIds)) &#123; sourceContext.collect(new HashMap&lt;Long, Set&lt;Long&gt;&gt;() &#123;&#123; put(0L, needMonitorIds); &#125;&#125;); &#125; &#125; catch (Throwable e) &#123; // 防止接口访问失败导致的错误导致 flink job 挂掉 log.error(&quot;need monitor ids error&quot;, e); &#125; &#125; &#125; @Override public void cancel() &#123; this.isCancel = true; &#125; &#125; public static void main(String[] args) &#123; ParameterTool parameterTool = ParameterTool.fromArgs(args); InputParams inputParams = new InputParams(parameterTool); StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(); final MapStateDescriptor&lt;Long, Set&lt;Long&gt;&gt; broadcastMapStateDescriptor = new MapStateDescriptor&lt;&gt;( &quot;config-keywords&quot;, BasicTypeInfo.LONG_TYPE_INFO, TypeInformation.of(new TypeHint&lt;Set&lt;Long&gt;&gt;() &#123; &#125;)); /********************* kafka source *********************/ BroadcastStream&lt;Map&lt;Long, Set&lt;Long&gt;&gt;&gt; broadcastStream = env .addSource(new NeedMonitorIdsSource()) // redis photoId 数据广播 .setParallelism(1) .broadcast(broadcastMapStateDescriptor); DataStream&lt;CommonModel&gt; logSourceDataStream = SourceFactory.getSourceDataStream(...); /********************* dag *********************/ DataStream&lt;CommonModel&gt; resultDataStream = logSourceDataStream .keyBy(KeySelectorFactory.getStringKeySelector(CommonModel::getKeyField)) .connect(broadcastStream) .process(new KeyedBroadcastProcessFunction&lt;String, CommonModel, Map&lt;Long, Set&lt;Long&gt;&gt;, CommonModel&gt;() &#123; private Set&lt;Long&gt; needMonitoredIds; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); this.needMonitoredIds = Rpc.get(...) &#125; @Override public void processElement(CommonModel commonModel, ReadOnlyContext readOnlyContext, Collector&lt;CommonModel&gt; collector) throws Exception &#123; // 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 &#125; @Override public void processBroadcastElement(Map&lt;Long, Set&lt;Long&gt;&gt; longSetMap, Context context, Collector&lt;CommonModel&gt; collector) throws Exception &#123; // 需要监控的字段 Set&lt;Long&gt; needMonitorIds = longSetMap.get(0L); if (CollectionUtils.isNotEmpty(needMonitorIds)) &#123; this.needMonitoredIds = needMonitorIds; &#125; &#125; &#125;); /********************* kafka sink *********************/ SinkFactory.setSinkDataStream(...); env.execute(inputParams.jobName); &#125;&#125; 方案 4适合于超大监控范围的数据（几百万，我们自己的生产实践中使用扩量到 500 万）。其原理是将监控范围接口按照 id 按照一定规则分桶。flink 消费到日志数据后将 id 按照 监控范围接口 id 相同的分桶方法进行分桶 keyBy，这样在下游算子中每个算子中就可以按照桶名称，从接口中拿到对应桶的监控 id 数据，这样 flink 中并行的每个算子只需要获取到自己对应的桶的数据，可以大大减少请求的压力。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Example &#123; public static void main(String[] args) &#123; ParameterTool parameterTool = ParameterTool.fromArgs(args); InputParams inputParams = new InputParams(parameterTool); StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(); final MapStateDescriptor&lt;Long, Set&lt;Long&gt;&gt; broadcastMapStateDescriptor = new MapStateDescriptor&lt;&gt;( &quot;config-keywords&quot;, BasicTypeInfo.LONG_TYPE_INFO, TypeInformation.of(new TypeHint&lt;Set&lt;Long&gt;&gt;() &#123; &#125;)); /********************* kafka source *********************/ DataStream&lt;CommonModel&gt; logSourceDataStream = SourceFactory.getSourceDataStream(...); /********************* dag *********************/ DataStream&lt;CommonModel&gt; resultDataStream = logSourceDataStream .keyBy(KeySelectorFactory.getLongKeySelector(CommonModel::getKeyField)) .timeWindow(Time.seconds(inputParams.accTimeWindowSeconds)) .process(new ProcessWindowFunction&lt;CommonModel, CommonModel, Long, TimeWindow&gt;() &#123; private long lastRefreshTimestamp; private Set&lt;Long&gt; oneBucketNeedMonitoredIds; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); &#125; @Override public void process(Long bucket, Context context, Iterable&lt;CommonModel&gt; iterable, Collector&lt;CommonModel&gt; collector) throws Exception &#123; long windowStart = context.window().getStart(); this.refreshNeedMonitoredIds(windowStart, bucket); /** * 判断 commonModel 中的 id 是否在 needMonitoredIds 池中 */ &#125; public void refreshNeedMonitoredIds(long windowStart, long bucket) &#123; // 每隔 10 秒访问一次 if (windowStart - this.lastRefreshTimestamp &gt;= 10000L) &#123; this.lastRefreshTimestamp = windowStart; this.oneBucketNeedMonitoredIds = Rpc.get(bucket, ...) &#125; &#125; &#125;); /********************* kafka sink *********************/ SinkFactory.setSinkDataStream(...); env.execute(inputParams.jobName); &#125;&#125; 总结本文首先介绍了，在短视频领域中，短视频生产消费数据链路的整个闭环，并且其数据链路闭环一般情况下也适用于其他场景；以及对应的实时监控方案的设计和不同场景下的代码实现，包括： 垂类生态短视频生产消费数据链路闭环：用户操作行为日志的流转，日志上传，实时计算，以及流转到 BI，数据服务，最后数据赋能的整个流程 实时监控方案设计：监控类实时计算流程中各类数据源，数据汇的选型 监控 id 池在不同量级场景下具体代码实现 学习资料flink https://github.com/flink-china/flink-training-course/blob/master/README.md https://ververica.cn/developers-resources/ https://space.bilibili.com/33807709","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时新增类指标标准化处理方案","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/apache-flink:realtime-new-id/","text":"实时新增类指标标准化处理方案 实时指标整个链路开发过程中的一些经验。 实时新增类指标大体上可以将实时新增类指标以以下两种维度进行分类。 identity id 类型维度 identity id 类型 备注 number(long) 类型 identity id 数值类型 identity id 的好处在于可以使用 Bitmap 类组件做到精确去重。 字符类型 identity id 字符类型 identity id 去重相对复杂，有两种方式，在误差允许范围之内使用 BloomFilter 进行去重，或者使用 key-value 组件进行精确去重。 产出数据类型维度 产出数据类型 备注 明细类数据 此类数据一般是要求将新增的数据明细产出，uv 的含义是做过滤，产出的明细数据中的 identity id 不会有重复。输出明细数据的好处在于，我们可以在下游使用 OLAP 引擎对明细数据进行各种维度的聚合计算，从而很方便的产出不同维度下的 uv 数据。 聚合类数据 将一个时间窗口内的 uv 进行聚合，并且可以计算出分维度的 uv，其产出数据一般都是[维度 + uv_count]，但是这里的维度一般情况下是都是固定维度。如果需要拓展则需要改动源码。 计算链路因此新增产出的链路多数就是以上两种维度因子的相互组合。 number(long) 类型 identity id 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public interface RoaringBitmapDuplicateable&lt;Model&gt; &#123; long DEFAULT_DUPLICATE_MILLS = 24 * 3600 * 1000L; BiPredicate&lt;Long, Long&gt; ROARING_BIT_MAP_CLEAR_BI_PREDICATE = (start, end) -&gt; end - start &gt;= DEFAULT_DUPLICATE_MILLS; // 初始化 default ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; getBitMapValueState(String name) &#123; return this.getRuntimeContext().getState( new ValueStateDescriptor&lt;&gt;(name, TypeInformation.of( new TypeHint&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt;() &#123; &#125;)) ); &#125; RuntimeContext getRuntimeContext(); long getLongId(Model model); Optional&lt;Logger&gt; getLogger(); default BiPredicate&lt;Long, Long&gt; roaringBitMapClearBiPredicate() &#123; return ROARING_BIT_MAP_CLEAR_BI_PREDICATE; &#125; default List&lt;Model&gt; duplicateAndGet(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Date, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Date, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Map&lt;Long, Model&gt; idModelsMap = models .stream() .collect(Collectors.toMap(this::getLongId, Function.identity(), (oldOne, newOne) -&gt; oldOne)); Set&lt;Long&gt; ids = idModelsMap.keySet(); List&lt;Model&gt; newModels = Lists.newArrayList(); for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; if (idModelsMap.containsKey(id)) &#123; newModels.add(idModelsMap.get(id)); &#125; &#125; &#125; newModels.stream() .map(this::getLongId) .forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return newModels; &#125; default long duplicateAndCount(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Set&lt;Long&gt; ids = models .stream() .map(this::getLongId) .collect(Collectors.toSet()); List&lt;Long&gt; newIds = Lists.newArrayList(); int count = 0; for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; newIds.add(id); count++; &#125; &#125; newIds.forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return count; &#125; default Tuple2&lt;Long, Roaring64NavigableMap&gt; checkAndGetState(long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitmap = bitMapValueState.value(); if (null == bitmap) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;New RoaringBitMapValueState Timestamp=&#123;&#125;&quot;, windowStartTimestamp)); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else if (this.roaringBitMapClearBiPredicate().test(bitmap.f0, windowStartTimestamp)) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;Clear RoaringBitMapValueState, from start=&#123;&#125; to end=&#123;&#125;&quot;, bitmap.f0, windowStartTimestamp)); bitMapValueState.clear(); bitmap.f1.clear(); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else &#123; return bitmap; &#125; &#125;&#125; 字符类型 identity id使用 Flink state 使用 key-value 外存 如果选用的是 Redis 作为 key-value 过滤，那么这里会有一个巧用 Redis bit 特性的优化。举一个一般场景下的方案与使用 Redis bit 特性的方案做对比： 场景：假如需要同一天有几十场活动，并且都希望计算出这几十场活动的 uv，那么我们就可以按照下图设计 Redis bit 结构。 通常方案： 这种场景下，如果有 1 亿用户，需要同时计算 50 个活动或者 50 个不同维度下的 uv。那么理论上最大 key 数量为 1 亿 * 50 = 50 亿个 key。 Redis bit 方案： 这样做的一个优点，就是这几十场活动的 uv 计算都使用了相同的 Redis key 来计算，可以大幅度减少 Redis 的容量占用。使用此方案的话，以上述相同的用户和活动场数，理论上最大key 数量仅仅为 1 亿，只是 value 数量会多占几十个 bit。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时开发标准化处理方案","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/realtime/","text":"实时开发标准化处理方案 实时指标整个链路开发过程中的一些经验。 指标类型 指标类型 备注 pv 简单 pv 类型指标，来一条日志信息加一，计算 count uv uv 类型指标，需要在一段时间范围内（一小时、一天、一场活动）正对 user_id 等 identity_id 去重计数。 监控圈定集合内的 identity_id 数据表现 有一组鉴定的 identity_id 集合，实时的监控或者计算这组 identity_id 相关的数据 排名 实时监控某些数据并根据某些指标进行排序","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"项目经验 | 一定要多思考，过脑子","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/work:life-cycle/","text":"项目经验 | 一定要多思考，过脑子 前言老妹是一个数据开发同学，最近在参与一个中台项目的实时数据建设，这也是她第一次完全的投入到一个项目体系当中（之前都是在某一个项目中负责一小块）。就在做这个项目的过程中，遇到了一些问题。 比如可行性调研和技术方案的细节也七七八八的写了不少，但是实际上需求整体的推进进度很慢，迟迟没有进入到开发阶段。依赖的上游接口不确定，整个项目的推进就暂停了。和上游沟通了半天，但是聊完之后发现好像没有什么可行的结论。 总的来说就是，需求推进慢，推进方向不正确，导致浪费了很多时间。 于是老妹抱着这些问题找到了羊老狗。 需求提出需求评审阶段之前好像还有一个阶段，提出需求阶段？？？开会时候说的【这个可以提成需求】？？？不太理解，这里是否有一个阶段？？？ 需求评审阶段需求评审阶段非常重要，需要根据目前的能力合理评估需求 A：哪部分需求，以目前的能力经验能评估可行性或者收益很低的，可以直接同步出去； B：哪部分需求能做，但是从长远来看，目前做完的结果只是一种过渡方案，可能 1-2 个月之后就会有代替方案的项目，这部分可以支持，但是没必要为了做成而去支持复杂模块，不必要投入全部人力做这类临时的方案； C：哪部分可以做，并且从长远来看，收益很高的，这部分我们可以深度调研方案。 分别举例如下 A 目前从技术上是不可行的，或者从资源层面是不可行的，比如我们目前的能力是能抗住 100w qps 的压力，但是需求可能是 1000w qps； 分析场景上不合理，我是数据人，有的数据需求可能从分析场景上不合理，比如这个场景其实是算 pv 就可以得出结论的，但是需求是 uv，这类就没有必要，而且 uv 相对 pv 肯定更加耗时耗力。 B 我目前是做实时数据的，用数据举例。目前的项目有两种方案：第一种方案是实时数据产出 A 维度数据到 OLAP 中，后端在查询 OLAP 时填充 B、C 维度，最后在看板展示数据；但是目前由于人力问题，后端没法支持完成。因此就有了第二中方案，第二种方案是实时数据产出 A、B、C 维度数据到 OLAP 中，但是数据源没有 B、C 维度，B、C 维度的数据只有后端才存储，所以实时这边需要去存储了 B、C 维度的维表当中做关联操作，并且关联存在一定的难度。这类情况下，实时关联 B、C 只是一个过渡方案，从长期来看，其实这部分没必要因为一个临时方案，而过度投入人力在收益很小的这个方案里面，可以做一些舍弃。 C 从长远来看可以做，之后会有越来越多的业务需要使用我们产出的数据，那么我们就可以针对这些业务做通用化模型建设，收益高。即使多加一些人力在这类需求上也可以。 以上这些情况在需求评审阶段，都需要对产品有一定的观点输出，可以表达我们的观点，技术可以做什么和技术应该做什么。 需求评审完成之后，就可以进入需求技术方案调研阶段。 需求技术方案调研阶段技术方案调研 + 设计（5W 1H）我们和上游能够沟通的内容是哪些？比如数据就是加字段，能不能同步一些表？？还能做什么沟通？？排期能不能沟通，应不应该沟通，应不应该自己去沟通，或者最好什么时候去沟通？比如等整体的技术方案确定下来，确定了工作量，然后去定排期 和产品能够沟通的东西是哪些？需求合理性？需求目前遇到的问题？需求的技术方案可行性？得等技术方案完全确认才能够评估工作量？ 和上下游能够沟通的东西是哪些？能否做支持？ 整体就是 5W 1H 的方式去调研整个技术方案。 首先第一点，最最最重要的就是一定要有目的的盘东西。我最终要产出什么（WHAT），我的上游依赖是什么（WHAT）。举例：需要产出的东西 - 目前手上有的东西 = 上游依赖。只要明确了目的，其实这部分东西很快就能够盘清楚。 第二点，我们盘清楚上游依赖之后，就是需要去想一下这些上游依赖可能存在的提供方式。举例：这些上游依赖是必须都要其他上游提供吗？能不能通过一些其他的方式自己进行实现？ 第三点，如果目前的技术方案满足不了需求，那么还有没有其他的方式进行实现，一定要多想可行性方案，可以多提供方案，但是方案的优劣可以让产品进行取舍抉择。举例：比如数据上面需要一些维度数据，我之前可能就评估各类方法去关联维表去填充这些维度信息。其实还可以推动上游数据去添加这些维度数据。让可行性方案变多，我们只需要去评估可行性方案的优劣。推动上游去做改动时，一定要通过业务角度解释这些数据的通用性，不可能每来一次需求添加一次，那样会被喷，上下游压力都很大。 第四点，数据人遇到问题时能使用数据说话就使用数据说话，包括方案的可行性等。举例：调研后发现，这个实现成本很高，反馈的时候一定要用数据说话，比如成本达到 xxx，使用 xxx 台机器，这个成本是不是可控的。尽量避免技术方案评审时只能反馈实现成本很高。 第五点，遇到问题时一定需要尽早的抛出问题，推动各方解决问题，而不能 block 在自己这里。举例：比如在技术方案上，自己可以先和 tech leader 详细讨论，一定注意详细讨论的前提是自己对整个项目目前的需求理解一定要到位，理解有问题的地方及时和产品沟通，明确理解需求。我就犯过比较明显的错误，经常会被 tech leader 问你调研的这个东西合不合理，有什么价值，这个东西能不能用其他的东西进行替代，或者你的方案为什么是这样的，这只是一个过渡的方案，我们有没有必要去完全按照需求要求的产出。 第六点，技术调研过程中，如果遇到上下游依赖的话，可以先和上下游方进行沟通，与上下游沟通一定要把握一个度，这部分可以慢慢学习理解。需要站在自己做的事情的全局上和未来的通用性上去思考问题，不但要思考自己的东西，还要站在上下游的角度上思考问题。 举例：沟通时可以和上游确认这部分上游能不能做支持，哪部分能帮忙支持，哪部分不能支持。站在对方的角度上想问题，比如自己需要的某些字段或者数据，其实站在上下游的角度上是不需要的，这个就需要多考量。上下游支持如果还存在难度的话，那就需要和产品同步目前的整体问题，让产品去推动各方或者是做一些取舍。 第七点，方案的每个细节都需要确认。做数据，那么数据每个字段都得清清楚楚的列出计算逻辑才算需求调研完成！！！不然很容易出现口径不一致和可行性问题。 通过上述几个步骤之后，都要最终和产品确认我们产出最终交付物。 这里结束之后，其实我们自己大致的工作量也就大致可以评估出来了，工作量是一个很迷的东西，如果工作经验不长的话，很难估计一个准确的工作量。 不一定就是利用现在手上有的东西去做需求，还可以去推动其他上下游去支持需求。 做项目时，没必要一口吃一个胖子，也没有必要钻一些牛角尖，有些东西比较难做，我们可以先实现简单的，后续再优化方案，进行迭代，没有什么项目是一次性能做完美的。 需求排期Question1.什么时候可以进入排期阶段？ 技术方案敲定后排人力，按照项目上下游情况排期？ 2.排期的时候如果依赖上游，上游的排期应该怎么沟通？或者我们和上游能够沟通的内容是哪些？ 上游的排期不应该自己去沟通。但是产品又会问，你拍的这个期有和上游沟通吗？ 3.有哪些方式去做排期？ 倒排：比如产品希望这个需求或者功能在某个时间点上线，那么我们就需要按照这个时间点，往前排。如果有上游依赖，还需要定下来上游依赖最晚给到的时间点。举例：比如产品希望 11.30 号整体上线，如果开发、自测需要 5 人天，联调预估需要 2 人天的话，我们就就可以排 11.22 开始开发，并且还需要根据上游依赖的强弱指定上游依赖给到的时间，比如 11.23 号给到。最后还需要留一定的 buffer 给自己，避免中途出现问题。 正排：这种情况下，一般都没有给定的截止日期。 3.为什么要这样划分排期？ 排期一般划分为一下几个： 开发 自测 联调 回测 上线 很多情况下，尤其是多个项目组合作的项目，一般都只能排到联调 4.排期过程中容易忽略的关键点？ 上下游依赖：上下游依赖很重要，上下游如果一旦发生 delay，咱的排期可能就会受到很大的影响。资源、上下游接口等等等等。 风险控制：一定要说明风险点。比如资源，上游依赖，上线前的前置依赖等。最好可以有一个 checklist，根据经验列举自己在开发过程中可能会遇到的各类问题。 5.所有的东西不能都以 mock 的形式进行，比如为了赶排期，复杂项目的联调全部使用 mock 数据就会存在问题 开发1.开发过程中最需要注意的就是单测的编写，一定要记得编写单测，保证每个单元的代码都是正确的 2.数据开发完成后需要验数，验数过程是很重要的","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"项目经验 | 一定要多思考，过脑子","date":"2020-09-01T06:21:53.000Z","path":"2020/09/01/wechat-blog/work:thinker/","text":"本系列每篇文章都比较短小，不定期更新，从一些实际的经历出发抛砖引玉，希望给小伙伴一些启发。本文介绍了博主从做数据到玩数据的整个思考过程的转变，阅读时长大概 2 分钟，话不多说，直接进入正文！ 项目经验 | 怎么从做数据转变到玩数据？ 前言是不是还一直是在执行工作而不是真正的去思考工作？","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高","date":"2020-01-06T12:39:35.000Z","path":"2020/01/06/java:study-hashmap/","text":"为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高 123static int indexFor(int hashcode, int length) &#123; return hashcode &amp; (length-1); &#125; 怎样提高get(key)效率？怎样提高get(key)效率 = 怎样提高确定key的所在hashmap中数组index的效率 hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 1.假设key的hashcode为h，数组长度为length，为了将数据打散，使hashmap中的数组下标对应的Entry链表都有数据，首先想到的就是对length取模，计算方法如下： 123static int indexFor(int h, int length) &#123; return h % length;&#125; 因此确定了hashmap的indexFor函数的计算方式。 怎样确定hashmap数组的length“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式？我们发现做位运算的消耗是很小的，所以尝试将取模运算转换成位预算，由此发现length为2的n次方时会有 123static int indexFor(int h, int length) &#123; return h % length; // 等价于 h &amp; (length - 1);&#125; 由于 &amp; 运算符计算效率大大高于 % 运算符，所以上述计算转换为： 123static int indexFor(int h, int length) &#123; return h &amp; (length - 1);&#125; 也规定了 length 必须是2的n次方（n&gt;0）除此之外，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://yangyichao-mango.github.io/tags/JAVA/"}]},{"title":"apache-flink:study-flink","date":"2019-11-22T03:30:41.000Z","path":"2019/11/22/apache-flink:study-flink/","text":"所有operator中的初始化如果写在构造函数当中就会出错，问题是序列化时的问题flink从jobmanager序列化到各个 taskmanager时可能会出问题 split组件功能可以减少多个flatmap的性能损失多个flatmap数据每个都是使用全部的流进行filtersplit一个就可以满足","tags":[]},{"title":"Apache Flink 学习：Jobs 和 Scheduling","date":"2019-11-20T03:27:03.000Z","path":"2019/11/20/apache-flink:study-flink-jobs-and-scheduling/","text":"Apache Flink 学习：Jobs 和 Scheduling SchedulingFlink中的执行资源是通过 Task Slots 定义的。每个 TaskManager 都有一个或多个 Task Slots，每个 Slot 可以运行一个并行任务流。并行任务流由多个连续的任务组成，例如 MapFunction 的第n个并行实例和 ReduceFunction 的第n个并行实例。请注意，Flink 经常并发地执行连续的任务：对于流式程序，基本上都会使用并行任务，对于批处理程序，也会经常使用并行任务。 下图说明了这一点。一个具有数据源、MapFunction 和 ReduceFunction 的程序。源函数和 MapFunction 的并行度为4，而 ReduceFunction 的并行度为3。流由 Source - Map - Reduce 组成。在这个集群中，有两个 TaskManager，每个 TaskManager 有三个 slot，则程序将按如下所述执行。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 State 和容错——State 的使用","date":"2019-11-19T07:48:16.000Z","path":"2019/11/19/apache-flink:study-flink-datastream-state-and-fault-tolerance-working-with-state/","text":"flink有两种基本的state，分别是Keyed State以及Operator State(non-keyed state)；其中Keyed State只能在KeyedStream上的functions及operators上使用；每个operator state会跟parallel operator中的一个实例绑定；Operator State支持parallelism变更时进行redistributingKeyed State及Operator State都分别有managed及raw两种形式，managed由flink runtime来管理，由runtime负责encode及写入checkpoint；raw形式的state由operators自己管理，flink runtime无法了解该state的数据结构，将其视为raw bytes；所有的datastream function都可以使用managed state，而raw state一般仅限于自己实现operators来使用stateful function可以通过CheckpointedFunction接口或者ListCheckpointed接口来使用managed operator state；CheckpointedFunction定义了snapshotState、initializeState两个方法；每当checkpoint执行的时候，snapshotState会被调用；而initializeState方法在每次用户定义的function初始化的时候(第一次初始化或者从前一次checkpoint recover的时候)被调用，该方法不仅可以用来初始化state，还可以用于处理state recovery的逻辑对于manageed operator state，目前仅仅支持list-style的形式，即要求state是serializable objects的List结构，方便在rescale的时候进行redistributed；关于redistribution schemes的模式目前有两种，分别是Even-split redistribution(在restore/redistribution的时候每个operator仅仅得到整个state的sublist)及Union redistribution(在restore/redistribution的时候每个operator得到整个state的完整list)FunctionSnapshotContext继承了ManagedSnapshotContext接口，它定义了getCheckpointId、getCheckpointTimestamp方法；FunctionInitializationContext继承了ManagedInitializationContext接口，它定义了isRestored、getOperatorStateStore、getKeyedStateStore方法，可以用来判断是否是在前一次execution的snapshot中restored，以及获取OperatorStateStore、KeyedStateStore对象","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Hadoop 学习：hdfs架构","date":"2019-11-13T06:04:52.000Z","path":"2019/11/13/apache-hadoop:study-hadoop-hdfs-design/","text":"Apache Hadoop 学习：hdfs架构 文件系统 Namespace HDFS支持传统的分层文件组织。用户或应用程序可以在这些目录中创建目录并存储文件。文件系统命名空间层次结构与大多数其他现有文件系统相似；可以创建和删除文件，将文件从一个目录移动到另一个目录，或者重命名文件。HDFS支持用户配额和访问权限。HDFS不支持硬链接或软链接。然而，HDFS体系结构并不排除实现这些特性。 虽然HDFS遵循文件系统的命名约定，但某些路径和名称（例如/.reserved和.snapshot）是保留的。透明加密和快照等功能使用保留路径。 NameNode维护文件系统名称空间。对文件系统命名空间或其属性的任何更改都由NameNode记录。应用程序可以指定HDFS应该维护的文件副本的数量。文件的副本数称为该文件的复制因子。此信息由NameNode存储。","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"}]},{"title":"Apache Flink 学习：Table Api & SQL","date":"2019-11-12T01:51:01.000Z","path":"2019/11/12/apache-flink:study-flink-table-api-and-sql/","text":"Apache Flink 学习：Table Api &amp; SQL","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 Operators（算子）——Joining","date":"2019-11-11T10:30:13.000Z","path":"2019/11/11/apache-flink:study-flink-datastream-operators-joining/","text":"Apache Flink 学习：DataStream Api 中 Operators（算子）——Joining Window JoinWindow Join 可以将两个流中相同key并且在同一个窗口中的元素进行链接。窗口可以使用 Window Assigner 进行定义，并且对来自不同的流的元素进行计算。 12345stream.join(otherStream) .where(&lt;KeySelector&gt;) .equalTo(&lt;KeySelector&gt;) .window(&lt;WindowAssigner&gt;) .apply(&lt;JoinFunction&gt;) 关于一些语义的解释：1.两个流的成对组合的过程类似于 Inner Join，意味着如果一个流中的元素没有另一个流的元素要与之连接，则不会发出这些元素。 2.那些被连接的元素的时间戳是位于相应窗口中的最大时间戳。例如，以[5，10)为边界的窗口，则进行连接的元素的时间戳为9。 Tumbling Window Join执行 Tumbling Window Join，在相同 key，相同时间窗口内的元素会进行笛卡尔积组合，这种组合类似于 inner join，如果一个流的对应流的同一窗口中没有元素，则这个流的当前窗口数据不会发出去。 12345678910111213141516171819import org.apache.flink.api.java.functions.KeySelector;import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;import org.apache.flink.streaming.api.windowing.time.Time; ...DataStream&lt;Integer&gt; orangeStream = ...DataStream&lt;Integer&gt; greenStream = ...orangeStream.join(greenStream) .where(&lt;KeySelector&gt;) .equalTo(&lt;KeySelector&gt;) .window(TumblingEventTimeWindows.of(Time.milliseconds(2))) .apply (new JoinFunction&lt;Integer, Integer, String&gt; ()&#123; @Override public String join(Integer first, Integer second) &#123; return first + &quot;,&quot; + second; &#125; &#125;); Sliding Window Join执行 Sliding Window Join，具有公共 key 和公共滑动窗口的所有元素都作为成对组合进行连接，并传递给 JoinFunction 或 FlatJoinFunction。也是 inner join，当前流窗口匹配不到对应流窗口的元素则不会发送数据到下游！请注意，某些元素可能在一个滑动窗口中连接，在另一个滑动窗口中不会进行连接！ 12345678910111213141516171819import org.apache.flink.api.java.functions.KeySelector;import org.apache.flink.streaming.api.windowing.assigners.SlidingEventTimeWindows;import org.apache.flink.streaming.api.windowing.time.Time;...DataStream&lt;Integer&gt; orangeStream = ...DataStream&lt;Integer&gt; greenStream = ...orangeStream.join(greenStream) .where(&lt;KeySelector&gt;) .equalTo(&lt;KeySelector&gt;) .window(SlidingEventTimeWindows.of(Time.milliseconds(2) /* size */, Time.milliseconds(1) /* slide */)) .apply (new JoinFunction&lt;Integer, Integer, String&gt; ()&#123; @Override public String join(Integer first, Integer second) &#123; return first + &quot;,&quot; + second; &#125; &#125;); Session Window Join执行 Session Window Join，具有相同 key 的所有元素（当“组合”满足会话条件时）将以成对组合联接，并传递给JoinFunction或FlatJoinFunction。同样，也是 inner join，当前流窗口匹配不到对应流窗口的元素则不会发送数据到下游！ Interval Joininterval join 用一个公共 key 连接两个流的元素（流A和流B），其中流B的元素具有与流A中元素的时间戳相对时间间隔内的时间戳，那么这个时间间隔内两个流的元素就会 join。 即：b.timestamp ∈ [a.timestamp + lowerBound; a.timestamp + upperBound] or a.timestamp + lowerBound &lt;= b.timestamp &lt;= a.timestamp + upperBound 其中 lowerBound 和 upperBound 可正可负，只要 lowerBound &lt;= upperBound。 1234567891011121314151617181920import org.apache.flink.api.java.functions.KeySelector;import org.apache.flink.streaming.api.functions.co.ProcessJoinFunction;import org.apache.flink.streaming.api.windowing.time.Time;...DataStream&lt;Integer&gt; orangeStream = ...DataStream&lt;Integer&gt; greenStream = ...orangeStream .keyBy(&lt;KeySelector&gt;) .intervalJoin(greenStream.keyBy(&lt;KeySelector&gt;)) .between(Time.milliseconds(-2), Time.milliseconds(1)) .process (new ProcessJoinFunction&lt;Integer, Integer, String()&#123; @Override public void processElement(Integer left, Integer right, Context ctx, Collector&lt;String&gt; out) &#123; out.collect(first + &quot;,&quot; + second); &#125; &#125;);","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"apache-flink:study-allowedLateness-and-maxOutOfOrderness","date":"2019-11-11T02:32:17.000Z","path":"2019/11/11/apache-flink:study-allowedLateness-and-maxOutOfOrderness/","text":"","tags":[]},{"title":"Apache Kafka 学习：kafka在数据处理中的应用","date":"2019-11-10T15:12:14.000Z","path":"2019/11/10/apache-kafka:study-kafka-in-data-process/","text":"Apache Kafka 学习：kafka在数据处理中的应用的一些个人理解。 离线数据处理场景在离线数据处理的过程中。如果不使用消息队列，在并发量很小的情况下，所有的客户端数据日志直接向hdfs写数据暂时不会产生什么问题。如果不使用消息队列，在并发量很大的情况下，向 hdfs 写数据就会出现问题，首先，向hdfs写数据会有锁竞争的情况，可能会导致大部分写请求很长时间得不到锁，导致大量请求延迟或者超时，这是不能接受的；并且 hdfs 作为文件系统不能承受太大的并发量，在并发很高的情况下，集群可能会崩溃。 问题原因总结总的来说，在这种情况下，问题的根本在于高并发情况下，hdfs 作为文件系统不能承受高并发请求的问题。 实施方案所以需要一种工具可以将客户端日志这种高并发请求转换为低并发的请求，这时候就可以使用kafka这样的消息队列，客户端的高并发请求直接写入 kafka，然后 hdfs 以低并发消费 kafka 中的数据。这样就解决了文件系统不能支持高并发的情况。并且由于 kafka 的HA特性，可以保证数据的正确性。 kafka作用将高并发请求以低并发方式处理。这种方式中解耦效果不明显，下面的实时数据处理使用到的解耦效果比较明显。 实时数据处理场景在实时数据处理的过程中。如果不使用消息队列，上游数据写入到类似 flink 这样的实时处理引擎当中，flink处理完成后向下游 olap 引擎（druid，clickhouse等）或者hdfs，hive，es等的文件系统写数据时，就需要为每一种 olap 引擎开发一种 connector，这样的情况下，每出现一种 olap 引擎或者每当下游的 olap 引擎升级版本引入新特性时，就需要 flink 开发工程师开发一种新的 connector 或者跟随 olap 引擎的升级而升级自己的 connector，这样 flink 开发工程师的维护成本之后就会特别高。这里有同学可能会说可以在数据处理的过程中使用下游 olap 等的引擎提供的 sdk，这种方法是可以的，但是实时处理打不风情况下并发量很高，olap 引擎提供的 sdk 应对这种高并发的场景可能会有很多问题。 问题原因总结问题的根本在于实时处理引擎和下游之间的耦合问题，这就需要一种HA的中间件来将各个模块进行解耦，kafka这样的消息队列可以很好的解决这中模块之间高度耦合的情况。 实施方案在 flink 和 druid中间使用 kafka 进行解耦，让 flink 向 kafka 生成数据，druid 消费 kafka 的数据。这样就使得 flink 可以只开发和维护一套针对于 kafka 的 connector，druid也只用开发和维护一套针对 kafka 的 connector，这样无论是实时处理引擎的升级或替换，或者是实时处理引擎下游的模块的升级或替换，都不会互相影响，并且这些模块的工程师只需要对消息队列的 connector 进行维护即可，并且可以根据其特性进行更好的优化。 kafka作用模块之间的解耦。让各个模块各司其职。拓展：1.Java 虚拟机在 Java 语言和各个系统之间的作用。2.Sql 进行三范式优化，不需要将所有数据都放在一张表当中，将n对n的表拆分出一张维表进行解耦。将维度拆分为维表可以减少数据量，更好划分和使用维度数据。3.经典网络五层模型，划分为五层，则在每一层中更新或者新建协议栈只需要对上下层进行兼容即可，不需要对整个网络架构模型做调整。4.Maven multiModule 划分。5.springMvc。等等。","tags":[{"name":"Apache Kafka","slug":"Apache-Kafka","permalink":"https://yangyichao-mango.github.io/tags/Apache-Kafka/"}]},{"title":"Apache Flink 学习：DataStream Api 中 Operators（算子）——窗口","date":"2019-11-09T14:48:53.000Z","path":"2019/11/09/apache-flink:study-flink-datastream-operators-windows/","text":"Apache Flink 学习：DataStream Api 中 Operators（算子）——窗口 Keyed Windows 123456789stream .keyBy(...) &lt;- keyed versus non-keyed windows .window(...) &lt;- required: &quot;assigner&quot; [.trigger(...)] &lt;- optional: &quot;trigger&quot; (else default trigger) [.evictor(...)] &lt;- optional: &quot;evictor&quot; (else no evictor) [.allowedLateness(...)] &lt;- optional: &quot;lateness&quot; (else zero) [.sideOutputLateData(...)] &lt;- optional: &quot;output tag&quot; (else no side output for late data) .reduce/aggregate/fold/apply() &lt;- required: &quot;function&quot; [.getSideOutput(...)] &lt;- optional: &quot;output tag&quot; Non-Keyed Windows 12345678stream .windowAll(...) &lt;- required: &quot;assigner&quot; [.trigger(...)] &lt;- optional: &quot;trigger&quot; (else default trigger) [.evictor(...)] &lt;- optional: &quot;evictor&quot; (else no evictor) [.allowedLateness(...)] &lt;- optional: &quot;lateness&quot; (else zero) [.sideOutputLateData(...)] &lt;- optional: &quot;output tag&quot; (else no side output for late data) .reduce/aggregate/fold/apply() &lt;- required: &quot;function&quot; [.getSideOutput(...)] &lt;- optional: &quot;output tag&quot; Window 生命周期简而言之，当属于该窗口的第一个元素到达时，将会创建一个窗口，并且当时间（Event Time 或者 Processing Time）超过其结束时间戳加上用户指定的允许延迟时间时，将完全删除该窗口，注意窗口都是左开右闭，比如：[0, 5)。Flink 保证只删除基于时间的窗口，而不删除其他类型的窗口，例如 Global Window。例如，使用基于事件时间的窗口，并且创建一个窗口大小为5分钟的滚动（Tumbing）窗口，并且允许延迟1分钟。当时间戳属于12:00到12:05之间的第一个元素到达时，Flink 将创建一个新窗口，当 Watermark 通过12:06时间戳时，就会把这个窗口删除。 此外，每个窗口都包含一个 Trigger 和一个函数（ProcessWindowFunction, ReduceFunction, AggregateFunction or FoldFunction）。函数包含了要应用于窗口内容的计算，而 Trigger 制定了什么情况下才触发执行这些函数。比如，触发策略可能类似于“当窗口中的元素数超过4时”或“当 WaterMark 通过窗口结束时”进行触发。Trigger 还可以决定什么时候删除窗口中的元素。 除上述内容外，您还可以指定一个 Evictor，该 Evictor 将能够在 Trigger 触发后、应用函数之前和/或之后从窗口中移除元素。 下面例子中的窗口都是按照 Event Time 或者 Processing Time进行指定。 Keyed vs Non-Keyed Windows首先要指定的是是否应该为流设置 key。使用keyBy（…）可以将无限流拆分为逻辑 keyed 流。 在 Keyed Stream 的情况下，传入 event 的任何属性都可以用作键。拥有一个 Keyed Stream 将允许您的窗口计算由多个任务并行执行，因为每个逻辑 Keyed Stream 都可以独立于其他任务进行处理。所有引用同一个键的 event 都将被发送到同一个并行任务（通过 partitioner 完成）。 如果不是 Keyed Stream，则不会将原始流拆分为多个逻辑流，所有窗口逻辑将由单个任务执行，即并行度为1。 Tumbling Windows 滚动窗口，如果你指定的滚动窗口大小为一天计算一次，并且你需要更具你本地的时间的 00:00:00 开始，则必须按照时区来指定窗口。可以看到上图中，无论是多少个 key，每个 key 的窗口的起始和截止时间都相同。 1234567891011121314151617181920212223242526272829303132333435363738/** * Creates a new &#123;@code TumblingEventTimeWindows&#125; &#123;@link WindowAssigner&#125; that assigns * elements to time windows based on the element timestamp and offset. * * 可以根据 时间戳 以及 偏移量 来指定 窗口的范围 * * &lt;p&gt;For example, if you want window a stream by hour,but window begins at the 15th minutes * of each hour, you can use &#123;@code of(Time.hours(1),Time.minutes(15))&#125;,then you will get * time windows start at 0:15:00,1:15:00,2:15:00,etc. * * 比如，如果需要一个窗口大小为一个小时，从每个小时的第15分钟开始计数的窗口，则可以使用下面的代码实现 * of(Time.hours(1),Time.minutes(15)) * 这样获得的窗口就是 0:15:00，1:15:00，2:15:00 ... * * &lt;p&gt;Rather than that,if you are living in somewhere which is not using UTC±00:00 time, * such as China which is using UTC+08:00,and you want a time window with size of one day, * and window begins at every 00:00:00 of local time,you may use &#123;@code of(Time.days(1),Time.hours(-8))&#125;. * The parameter of offset is &#123;@code Time.hours(-8))&#125; since UTC+08:00 is 8 hours earlier than UTC time. * * 除此之外，如果您的时区不是 UTC±00:00 时间，比如在 中国（时区是 UTC+08:00），并且你需要一个一天大小的窗口， * 并且窗口时间是本地 00:00:00开始，则可以使用下面的代码实现 * of(Time.days(1), Time.hours(-8)) * * @param size The size of the generated windows. * @param offset The offset which window start would be shifted by. * @return The time policy. */public static TumblingEventTimeWindows of(Time size, Time offset) &#123; return new TumblingEventTimeWindows(size.toMilliseconds(), offset.toMilliseconds());&#125;public static void main(String[] args) &#123; // daily tumbling event-time windows offset by -8 hours. input .keyBy(&lt;key selector&gt;) .window(TumblingEventTimeWindows.of(Time.days(1), Time.hours(-8))) .&lt;windowed transformation&gt;(&lt;window function&gt;);&#125; Sliding Windows 滑动窗口，如果你指定窗口大小和滑动步长一样，那么和滚动窗口的作用一样，滑动窗口的一个明显的特征就是：窗口可能会重叠，即同一个元素可能会属于不同的窗口。 和滚动窗口相同，如果你指定的滚动窗口大小为一天计算一次，你需要更具你本地的时间的 00:00:00 开始，则必须按照时区来指定窗口。 1234567public static void main(String[] args) &#123; // sliding processing-time windows offset by -8 hours input .keyBy(&lt;key selector&gt;) .window(SlidingProcessingTimeWindows.of(Time.hours(12), Time.hours(1), Time.hours(-8))) .&lt;windowed transformation&gt;(&lt;window function&gt;);&#125; Session Windows 会话窗口，根据会话来指定窗口，与滚动和滑动窗口相比，会话窗口不重叠，并且没有固定的开始和结束时间。会话窗口可以指定静态指定会话间隔，或者可以让用户动态指定会话间隔。 123456789101112131415DataStream&lt;T&gt; input = ...;// event-time session windows with static gapinput .keyBy(&lt;key selector&gt;) .window(EventTimeSessionWindows.withGap(Time.minutes(10))) .&lt;windowed transformation&gt;(&lt;window function&gt;); // event-time session windows with dynamic gapinput .keyBy(&lt;key selector&gt;) .window(EventTimeSessionWindows.withDynamicGap((element) -&gt; &#123; // determine and return session gap &#125;)) .&lt;windowed transformation&gt;(&lt;window function&gt;); Global Windows 全局窗口（即无窗口），代表所有元素斗数以一个全局窗口，如果你不指定 Trigger，那么永远也不会生产出数据，因为全局窗口没有窗口开始和窗口结束的概念。 123456DataStream&lt;T&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(GlobalWindows.create()) .&lt;windowed transformation&gt;(&lt;window function&gt;); 窗口函数在定义 window assigner 之后，我们需要指定要在每个窗口上执行的计算。当系统确定窗口准备好处理时（Trigger决定），这些窗口函数就可以用于处理每个（Keyed / Non-Keyed）窗口的元素。 窗口函数可以是ReduceFunction、AggregateFunction、FoldFunction或ProcessWindowFunction之一。前两个函数执行起来会更高效，因为 Flink 可以在每个窗口中的元素到达时递增地聚合元素。ProcessWindowFunction获取包含在窗口中的所有元素的Iterable，以及有关元素所属窗口的其他元信息。 使用ProcessWindowFunction的窗口函数不能像其他函数那样高效地执行，因为Flink在调用函数之前必须在内部缓冲窗口的所有元素。这可以通过将ProcessWindowFunction与ReduceFunction、AggregateFunction或FoldFunction组合使用来提高效率，从而使得其他窗口元数据或者窗口元素的进行增量聚合。 ReduceFunction变量：两个输入生成一个输出，三个变量的类型必须相同。触发时间：在每个窗口的元素到来的时候进行增量聚合。 12345678910DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .reduce(new ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt; &#123; public Tuple2&lt;String, Long&gt; reduce(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2) &#123; return new Tuple2&lt;&gt;(v1.f0, v1.f1 + v2.f1); &#125; &#125;); AggregateFunctionAggregateFunction 是 ReduceFunction 的一个扩展版本。 变量：三个变量，一个是输入，一个是 accumulator 累加器，还有一个是输出，三个变量的类型可以不同。触发时间：在每个窗口的元素到来的时候进行增量聚合。 123456789101112131415161718192021222324252627282930313233/** * The accumulator is used to keep a running sum and a count. The &#123;@code getResult&#125; method * computes the average. */private static class AverageAggregate implements AggregateFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123; @Override public Tuple2&lt;Long, Long&gt; createAccumulator() &#123; return new Tuple2&lt;&gt;(0L, 0L); &#125; @Override public Tuple2&lt;Long, Long&gt; add(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator) &#123; return new Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + 1L); &#125; @Override public Double getResult(Tuple2&lt;Long, Long&gt; accumulator) &#123; return ((double) accumulator.f0) / accumulator.f1; &#125; @Override public Tuple2&lt;Long, Long&gt; merge(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b) &#123; return new Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1); &#125;&#125;DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .aggregate(new AverageAggregate()); FoldFunctionFoldFunction 是 AggregateFunction 的一个简易版本。 变量：三个个变量，一个是输出值的初始化值，一个是输入，还有一个是输出，三个变量中输入和输出的类型可以不同，但是输出和输出初始化值必须相同。触发时间：在每个窗口的元素到来的时候进行增量聚合。 FoldFunction 指定如何将窗口的输入元素与输出类型的元素组合。对添加到窗口的每个元素和当前输出值增量调用 FoldFunction。 12345678910DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .fold(&quot;&quot;, new FoldFunction&lt;Tuple2&lt;String, Long&gt;, String&gt;&gt; &#123; public String fold(String acc, Tuple2&lt;String, Long&gt; value) &#123; return acc + value.f1; &#125; &#125;); ProcessWindowFunctionProcessWindowFunction 可以得到一个包含窗口的所有元素的迭代器，以及一个访问时间和状态信息的上下文对象，使得它能够提供比其他窗口函数更好的灵活性。但是这是以性能和资源消耗为代价的，因为元素不能增量聚合，而是需要在内部缓冲，直到窗口可以处理为止。 变量：四个变量，一个是窗口的key，一个是包含了窗口信息的上下文，一个是窗口内所有元素的迭代器，一个是输出数据的收集器。触发时间：窗口内有数据并且 Watermark 到达了窗口结束时间时触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt; implements Function &#123; /** * Evaluates the window and outputs none or several elements. * * @param key The key for which this window is evaluated. * @param context The context in which the window is being evaluated. * @param elements The elements in the window being evaluated. * @param out A collector for emitting elements. * * @throws Exception The function may throw exceptions to fail the program and trigger recovery. */ public abstract void process( KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out) throws Exception; /** * The context holding window metadata. */ public abstract class Context implements java.io.Serializable &#123; /** * Returns the window that is being evaluated. */ public abstract W window(); /** Returns the current processing time. */ public abstract long currentProcessingTime(); /** Returns the current event-time watermark. */ public abstract long currentWatermark(); /** * State accessor for per-key and per-window state. * * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt;If you use per-window state you have to ensure that you clean it up * by implementing &#123;@link ProcessWindowFunction#clear(Context)&#125;. */ public abstract KeyedStateStore windowState(); /** * State accessor for per-key global state. */ public abstract KeyedStateStore globalState(); &#125;&#125; 123456789101112131415161718192021DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(t -&gt; t.f0) .timeWindow(Time.minutes(5)) .process(new MyProcessWindowFunction());/* ... */public class MyProcessWindowFunction extends ProcessWindowFunction&lt;Tuple2&lt;String, Long&gt;, String, String, TimeWindow&gt; &#123; @Override public void process(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out) &#123; long count = 0; for (Tuple2&lt;String, Long&gt; in: input) &#123; count++; &#125; out.collect(&quot;Window: &quot; + context.window() + &quot;count: &quot; + count); &#125;&#125; 使用 ProcessWindowFunction 进行元素 count 是非常低效的，下面会讲到怎样将 ReduceFunction 或者 AggregateFunction 与 ProcessWindowFunction 结合使用将增量的数据的与 ProcessWindowFunction 配合进行使用。 为什么需要用到 ProcessWindowFunction：如果必要的话，一般的业务逻辑是没必要使用到 ProcessWindowFunction 的，但是有的需求需要获取到当前元素时间戳，窗口开始结束等等的信息，这时就需要使用 ProcessWindowFunction 来获取这些信息了。 ProcessWindowFunction 与 ReduceFunction123456789101112131415161718192021222324252627DataStream&lt;SensorReading&gt; input = ...;input .keyBy(&lt;key selector&gt;) .timeWindow(&lt;duration&gt;) .reduce(new MyReduceFunction(), new MyProcessWindowFunction());// Function definitionsprivate static class MyReduceFunction implements ReduceFunction&lt;SensorReading&gt; &#123; public SensorReading reduce(SensorReading r1, SensorReading r2) &#123; return r1.value() &gt; r2.value() ? r2 : r1; &#125;&#125;private static class MyProcessWindowFunction extends ProcessWindowFunction&lt;SensorReading, Tuple2&lt;Long, SensorReading&gt;, String, TimeWindow&gt; &#123; public void process(String key, Context context, Iterable&lt;SensorReading&gt; minReadings, Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out) &#123; SensorReading min = minReadings.iterator().next(); out.collect(new Tuple2&lt;Long, SensorReading&gt;(context.window().getStart(), min)); &#125;&#125; ProcessWindowFunction 与 AggregateFunction1234567891011121314151617181920212223242526272829303132333435363738394041424344454647DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .timeWindow(&lt;duration&gt;) .aggregate(new AverageAggregate(), new MyProcessWindowFunction());// Function definitions/** * The accumulator is used to keep a running sum and a count. The &#123;@code getResult&#125; method * computes the average. */private static class AverageAggregate implements AggregateFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123; @Override public Tuple2&lt;Long, Long&gt; createAccumulator() &#123; return new Tuple2&lt;&gt;(0L, 0L); &#125; @Override public Tuple2&lt;Long, Long&gt; add(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator) &#123; return new Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + 1L); &#125; @Override public Double getResult(Tuple2&lt;Long, Long&gt; accumulator) &#123; return ((double) accumulator.f0) / accumulator.f1; &#125; @Override public Tuple2&lt;Long, Long&gt; merge(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b) &#123; return new Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1); &#125;&#125;private static class MyProcessWindowFunction extends ProcessWindowFunction&lt;Double, Tuple2&lt;String, Double&gt;, String, TimeWindow&gt; &#123; public void process(String key, Context context, Iterable&lt;Double&gt; averages, Collector&lt;Tuple2&lt;String, Double&gt;&gt; out) &#123; Double average = averages.iterator().next(); out.collect(new Tuple2&lt;&gt;(key, average)); &#125;&#125; ProcessWindowFunction 与 FoldFunction123456789101112131415161718192021222324252627282930DataStream&lt;SensorReading&gt; input = ...;input .keyBy(&lt;key selector&gt;) .timeWindow(&lt;duration&gt;) .fold(new Tuple3&lt;String, Long, Integer&gt;(&quot;&quot;,0L, 0), new MyFoldFunction(), new MyProcessWindowFunction())// Function definitionsprivate static class MyFoldFunction implements FoldFunction&lt;SensorReading, Tuple3&lt;String, Long, Integer&gt; &gt; &#123; public Tuple3&lt;String, Long, Integer&gt; fold(Tuple3&lt;String, Long, Integer&gt; acc, SensorReading s) &#123; Integer cur = acc.getField(2); acc.setField(cur + 1, 2); return acc; &#125;&#125;private static class MyProcessWindowFunction extends ProcessWindowFunction&lt;Tuple3&lt;String, Long, Integer&gt;, Tuple3&lt;String, Long, Integer&gt;, String, TimeWindow&gt; &#123; public void process(String key, Context context, Iterable&lt;Tuple3&lt;String, Long, Integer&gt;&gt; counts, Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out) &#123; Integer count = counts.iterator().next().getField(2); out.collect(new Tuple3&lt;String, Long, Integer&gt;(key, context.window().getEnd(),count)); &#125;&#125; ProcessWindowFunction 中使用 stateWindowFunction（遗留）在一些可以使用 ProcessWindowFunction 的地方，你也可以使用 WindowFunction，这是较旧版本的 ProcessWindowFunction，它提供的上下文信息较少，并且没有一些高级功能，例如 per-window keyed state。 1234567891011121314public interface WindowFunction&lt;IN, OUT, KEY, W extends Window&gt; extends Function, Serializable &#123; /** * Evaluates the window and outputs none or several elements. * * @param key The key for which this window is evaluated. * @param window The window that is being evaluated. * @param input The elements in the window being evaluated. * @param out A collector for emitting elements. * * @throws Exception The function may throw exceptions to fail the program and trigger recovery. */ void apply(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out) throws Exception;&#125; 123456DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .apply(new MyWindowFunction()); Triggers触发器决定了窗口函数什么时候处理窗口中的数据。每一个 WindowAssigner 都会带有一个默认的 Trigger，如果默认的 Trigger 不符合需求，你可以使用 trigger(…) 指定你需要的触发器。 一个 Trigger 接口有五个方法，可以通过编写函数指定如何对不同的 event 做出相应。 Function 作用 TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx) 每向窗口添加一个元素时触发一次。 TriggerResult onEventTime(long time, W window, TriggerContext ctx) Event Time timer 触发时调用。 TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) Processing Time timer 调用时触发。 void onMerge(W window, OnMergeContext ctx) 方法与有状态 Trigger 相关，并在两个触发器的相应窗口合并时合并它们的状态，例如在使用会话窗口时（会话窗口每添加一个元素就会产生一个窗口）。 void clear(W window, TriggerContext ctx) 将当前窗口的 state 清除。 前三个函数通过 TriggerResult 决定如何处理它们的调用事件。 TriggerResult 作用 TriggerResult.CONTINUE 什么都不做。 TriggerResult.FIRE 触发计算。 TriggerResult.PURGE 清除窗口内的元素。 TriggerResult.FIRE_AND_PURGE 触发计算，并且在此之后清除窗口内的元素。 触发运算并且清除元素WindowAssigners 的默认 Triggers很多 WindowAssigners 的默认 Triggers是适用于很多场景的。例如，所有的 event-time window assigners 都将 EventTimeTrigger 作为默认的 Trigger。这个 Trigger 的作用就是当 Watermark 到达了窗口结束时间时就触发。提示1：GlobalWindow 的默认 Trigger 是永远不会触发的 NeverTrigger。提示2：通过使用 trigger() 指定触发器，您将覆盖 WindowAssigner 的默认触发器。例如，如果为 TumblingEventTimeWindows 指定 CountTrigger，则不会再根据时间进度而仅按 count 触发窗口。 通用的 Triggers Trigger 作用 EventTimeTrigger 根据由 Watermark 计算的 Event Time 进度触发。 ProcessingTimeTrigger 根据 Processing Time 触发。 CountTrigger 在窗口中的元素数超过给定限额时触发。 PurgingTrigger 将另一个 Trigger 作为参数，并将其转换为清除触发器。 EvictorsFlink 的窗口模型中允许指定除 WindowAssigner 和 Trigger 之外的可选逐出器（Evictor）。可以使用exictor(…)方法指定。Exictor 能够在触发器触发之后，并在使用窗口函数之前或者之后移除元素。为此，逐出器接口有两个方法： 123456789101112131415161718192021/** * Optionally evicts elements. Called before windowing function. * 在执行窗口函数之前执行。 * * @param elements The elements currently in the pane. * @param size The current number of elements in the pane. * @param window The &#123;@link Window&#125; * @param evictorContext The context for the Evictor */void evictBefore(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext);/** * Optionally evicts elements. Called after windowing function. * 在执行窗口函数之后执行。 * * @param elements The elements currently in the pane. * @param size The current number of elements in the pane. * @param window The &#123;@link Window&#125; * @param evictorContext The context for the Evictor */void evictAfter(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext); Evictor 作用 CountEvictor 保持窗口内元素数量符合用户指定数量，如果多于用户指定的数量，从窗口缓冲区的开头丢弃剩余的元素。 DeltaEvictor 使用 DeltaFunction 和一个阈值，计算窗口缓冲区中的最后一个元素与其余每个元素之间的 delta 值，并删除 delta 值大于或等于阈值的元素。 TimeEvictor 以毫秒为单位的时间间隔作为参数，对于给定的窗口，找到元素中的最大的时间戳max_ts，并删除时间戳小于max_ts - interval的所有元素。 默认情况下，都只会在执行 WindowFunction 之前执行 Evictor。 提示：Flink 不能保证窗口中元素的顺序。这意味着尽管逐出器可能会从窗口的开头移除元素，但这些元素不一定是最先到达或最后到达的元素。 Allowed Lateness概念使用 Event Time 窗口时，可能会发生元素到达晚的情况，即 Flink 用于跟踪 Event Time 进度的 Watermark 已超过元素所属窗口的结束时间戳。 默认情况下，当发现 Watermark 已经超过到达的元素所属的窗口结束时间时，将删除这个延迟元素。但是 Flink 可以给窗口算子指定一个最大允许延迟时间。Allowed lateness 指定元素在被删除之前可以延迟多少时间，其默认值为0。 在迟到元素到达时，如果 Watermark 大于其所属窗口的结束时间时，并且 Watermark 小于窗口结束时间加上 allowed lateness，这个迟到的元素仍然可以被加到这个窗口内进行运算。有的触发器会出现在延迟但是没有丢弃的元素到达时，使得窗口再次计算，比如 EventTimeTrigger。 提示1：在 assignTimestampsAndWatermarks 时有一个 maxOutOfOrderness 的概念，maxOutOfOrderness 是生成 Watermark 所需要的，是指元素最大无序时间。而 Allowed Lateness 是指在 Watermark 到达窗口结束时间之后允许延迟多长时间，两个概念不一样。提示2：a.通过 watermark 机制来处理 out-of-order 的问题，属于第一层防护，属于全局性的防护，通常说的乱序问题的解决办法，就是指这类；b.通过窗口上的 allowedLateness 机制来处理 out-of-order 的问题，属于第二层防护，属于特定 window operator 的防护，late element 的问题就是指这类 1234567DataStream&lt;T&gt; input = ...;input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .allowedLateness(&lt;time&gt;) .&lt;windowed transformation&gt;(&lt;window function&gt;); 提示：当使用 GlobalWindows 时，没有元素会被认为是迟到的，因为这个窗口哦的结束时间时 Long.MAX_VALUE。 迟到的数据做旁路输出（side output）123456789101112final OutputTag&lt;T&gt; lateOutputTag = new OutputTag&lt;T&gt;(&quot;late-data&quot;)&#123;&#125;;DataStream&lt;T&gt; input = ...;SingleOutputStreamOperator&lt;T&gt; result = input .keyBy(&lt;key selector&gt;) .window(&lt;window assigner&gt;) .allowedLateness(&lt;time&gt;) .sideOutputLateData(lateOutputTag) .&lt;windowed transformation&gt;(&lt;window function&gt;);DataStream&lt;T&gt; lateStream = result.getSideOutput(lateOutputTag); 拓展思考当指定 Allowed Lateness &gt; 0 时，在 Watermark 通过窗口结束时间后，将保留窗口及其内容。在这种情况下，当一个延迟但未被丢弃的元素到达时，它可能会再次触发窗口运算。这些被触发运算的被称为 late firing。在使用会话窗口时，它们可能会将两个预先存在的未合并窗口进行合并，下面是一个例子。 比如：有一个会话窗口且 Gap 为3分钟，现在有两个窗口，第一个窗口起始和结束时间为（01:00:00，01:00:05），第二个窗口起始和结束时间为（01:00:09，01:00:15），如果我们在此时不设置 Allowed Lateness 时，那么如果不保存第一个窗口的数据，运算第二个窗口的数据时，不会有什么问题，但是如果我们设置了 Allowed Lateness = 5 min，那么这时就会有问题了，比如有迟到元素01:00:15才到达，元素自己的时间戳为01:00:07，这样这个元素就可以将两个窗口的数据结合为一个窗口。 提示：延迟数据触发的运算应该将之前的计算结果更新，所以如果下游 sink 使用了 kafka，则这种情况不是很适用（除非消费 kafka 的是一些 updateable dfs），否则，你将会得到很多的对相同组数据计算的结果。 窗口结果的使用窗口计算的结果也会转化为一个数据流，这份结果中不会包含窗口操作的任何信息，所以如果后续计算中需要这些信息，你必须使用 ProcessWindowFunction 将这些信息通过编码传输进去。 窗口和 Watermark 的联系当 Watermark 到达窗口算子处时，会触发两个事件：1.Watermark 会触发所有的窗口中的最大时间戳（窗口结束时间戳 - 1）&lt; 到达的最新 Watermark的窗口运算。2.将 Watermark 发送到下游算子。Intuitively, a watermark “flushes” out any windows that would be considered late in downstream operations once they receive that watermark. 连续的窗口算子设置窗口时产生的状态大小的注意事项窗口大小可以定义的很大（如天、周或月），因此可能会累积非常大的状态（state）。所以在估计窗口计算的存储需求时，需要记住以下几个规则： 1.Flink 会为每个元素所属的窗口创建一个副本。因此，滚动的窗口保留每个元素的一个副本（一个元素只属于一个窗口）。相反，滑动窗口可能会创建每个元素中的几个副本。因此，1天大小的窗口，1秒滑动步长的滑动窗口可能不是一个好主意。 2.ReduceFunction、AggregateFunction 和 FoldFunction 可以显著减少存储需求，因为它们在元素到达时就聚合元素，并且每个窗口只存储一个值。相反，仅仅使用 ProcessWindowFunction 就需要累积所有元素。 3.使用 Evictor 可防止任何预聚合，因为在应用计算之前，窗口的所有元素都必须通过 Evictor 传递。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 Operators（算子）——概览","date":"2019-11-09T08:22:30.000Z","path":"2019/11/09/apache-flink:study-flink-datastream-operators-overview/","text":"描述了基本 Operators 的 Transformations，应用这些转换后如何进行 physical partitioning（物理分区），以及对Flink算子链的深入了解。 DataStream TransformationsPhysical partitioning Transformation Description Custom partitioning DataStream → DataStream CustomPartitionerWrapper 使用自定义的 partitioner 为每一条 record 选择下一个 task dataStream.partitionCustom(partitioner, \"someKey\"); dataStream.partitionCustom(partitioner, 0); Random partitioning DataStream → DataStream ShufflePartitioner 按随机均匀划分元素 dataStream.shuffle(); Rebalancing (Round-robin partitioning) DataStream → DataStream RebalancePartitioner 分区循环划分元素，为每个下游创建相等的负载。对于存在数据倾斜的性能优化非常有用。 dataStream.rebalance(); Rescaling DataStream → DataStream RescalePartitioner 将元素循环（round robin）分配到下游 operator 的子集。如果你的 pipeline 是一下的情况，那么这种方式会非常有用。 例如，将并行数据源的每个实例的数据传输到的下游多个算子（operators）一个子集以分配负载。但不希望 full rebalance，则这非常有用。 如果合理配置 TaskManager 的 slot数量，则数据传输只需要本地传输，而不需要通过网络传输数据。 上游 operators 向的下游 operators 发送 record 取决于上游 operators 和下游 operators 的并行度。 例如，如果上游 operator 的并行度为2，而下游 operator 的并行度为6，则一个上游 operator 将 record 分配给三个下游 operator，而另一个上游 operator 将 record 分配给其他三个下游 operator。相反，如果下游 operator 的并行度为2，而上游 operator 的并行度为6，则三个上游 operator 将分配给一个下游 operator，而其他三个上游 operator 将分配给另一个下游 operator。 如果上下游算子的并行度不是彼此的倍数，则一个或多个下游 operator 将具有来自上游 operator 的不同数量的输入。 如下图： dataStream.rescale(); Broadcasting DataStream → DataStream BroadcastPartitioner 广播数据到下游的每个partition。 dataStream.broadcast(); Local Forward DataStream → DataStream ForwardPartitioner 数据传输到本地的下游算子。 dataStream.forward(); GlobalPartitioner DataStream → DataStream GlobalPartitioner 数据传输到下游子任务id为0的task中。 dataStream.forward(); Key Groups DataStream → DataStream KeyGroupStreamPartitioner 相同key的值会传输到同一个下游。类似于Rescaling，但是不用再api中指定，再使用keyBy时会自动指定此方法。 dataStream.keyBy(); Task chaining 和 资源组链接两个 Transformations 意味着可以将它们共同放在在同一个线程中执行以获得更好的性能。默认情况下，Flink会尽可能链接两个算子（例如，两个 Map Transformations）。如果需要，可以使用API对 Task chaining 进行细粒度控制： 在 Flink 中，一个 slot 就是一个资源组。如果需要的话，你可以通过使用api把上下游算子隔离在不同的 slot 中运行。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：DataStream Api 中 EventTime","date":"2019-11-09T04:09:56.000Z","path":"2019/11/09/apache-flink:study-flink-datastream-eventtime/","text":"Apache Flink 学习：DataStream Api 中 EventTime Processing time处理时间是指执行相应操作的机器的系统时间 Event time事件时间是每个事件在其生产设备（生产event的设备，手机等的源头设备）上发生的时间 Event Time 和 WatermarkFlink中测量事件时间进度的机制是Watermark。Watermark作为数据流的一部分流动，并带有时间戳t。Watermark（t）声明该流中的 Event Time 已达到时间t，这意味着流中不应再有时间戳t’&lt;=t的元素（即 Event Time 早于或等于 Watermark 的事件） 下图显示了具有时间戳的事件流，以及内联流动的水印。在这个例子中，事件是有序的，这意味着 Watermark 只是流中的周期性标记。 Watermark对于无序流是至关重要的，如下所示，其中事件到达顺序不是按时间戳顺序。Watermark代表通过流中的该点，这个时间戳之前的事件都应该到达了。一旦Watermark到达算子，算子就可以将其内部事件时钟更新到Watermark的值。 并行流的 WatermarksWatermark 在源数据 Function 处生成，或直接在源数据 Function 之后生成。源数据 Function 的每个并行子任务通常独立生成其 Watermark。这些 Watermark 定义并行源数据的 Event Time。 当 Watermark 流过程序时，会更新到达算子的 Event Time，当一个 Watermark 更新了算子的 Event Time 时，它会为其下游的后续算子生成一个新的 Watermark。 某些算子消费多个输入流，例如：union 算子或者跟在 keyBy，partition 算子的之后的算子。这样的算子的 Event Time 是所有输入 stream 中最小的 Watermark，即：Operator Event Time = min(Input Stream 1 Watermark, Input Stream 2 Watermark…)算子会跟着输入流 Watermark 的更新来更新算子自己的 Event Time。 下图显示了流经并行流的事件和 Watermark 以及算子获取 Event Time 的示例。 注意，Kafka支持分区 Watermark Ingestion time注入时间是事件进入Flink Job的时间。在源Operator处，每条Operator获取源数据的时间作为Ingestion time时间戳 生成 Timestamps 和 Watermarks分配 Timestamps数据流源生成 Timestamps 和 Watermarks数据源可以直接为它们产生的数据分配 Timestamp，并且他们也能发送 Watermark。这样做的话，在后面的处理中就没必要再去定义 Timestamp 分配器了，需要注意的是：如果在后面的处理中使用了一个 timestamp 分配器，由数据源提供的任何 timestamp 和 watermark 都会被重写。 Timestamp 分配器 / Watermark生成器Timestamp 分配器获取一个流并生成一个新的带有 Timestamp 元素和 Watermark 的流。如果上游的原始数据流已经有 Timestamp 或 Watermark，则 Timestamp 分配器将覆盖上游的 Timestamp 或 Watermark Timestamp 分配器通常在数据源之后立即指定，但这并不是严格要求的。通常是在 Timestamp 分配器之前先解析（MapFunction）和过滤（FilterFunction）数据源。在任何情况下，都需要在基于 Event Time 算子（例如 window 操作）运行之前指定 Timestamp 分配程序。有一个特殊情况，当使用 Kafka 作为流作业的数据源时，Flink 允许在数据源内部指定 Timestamp 分配器和 Watermark 生成器。更多关于如何进行的信息请参考Kafka Connector的文档。 直接在FlinkKafkaConsumer010上面使用assignTimestampsAndWatermarks可以根据kafka source的partitions的特性进行设置Timestamps和Watermarks，让用户做一些特殊的处理 Running timestamp extractors / watermark generators directly inside the Kafka source, per Kafkapartition, allows users to let them exploit the per-partition characteristics. Kafka 分区的 Timestamp当使用 Apache Kafka 作为数据源时，每个 Kafka 分区可能有一个简单的 Event Time 模式（递增的时间戳或有界无序）。然而，当 Flink Job 使用来自Kafka的流时，多个分区常常并行消费，每一个 operator 算子并行消费时就会破坏各个分区的时间模式（这是 Kafka 客户端消费 Kafka 数据必然发生的）。 在这种情况下，可以使用 Flink’s Kafka-partition-aware watermark generation，使用该功能，每个 Kafka 分区在 Kafka consumer 内部生成 Watermark，每个分区合并 Watermark 的方式与流 shuffles 时合并 Watermark 的方式相同。 例如，如果事件时间戳严格按照 Kafka 分区递增，则使用递增时间戳 Watermark 生成器生成每个分区的 Watermark 将是完美的全局 Watermark。 下图显示了如何使用 Flink’s Kafka-partition-aware watermark generation，以及在这种情况下 Watermark 如何通过流数据流传播。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：slot和parallelism设置的关系","date":"2019-11-08T07:31:08.000Z","path":"2019/11/08/apache-flink:study-flink-slot-parallelism/","text":"Apache Flink 学习：slot和parallelism设置的关系 如何设置 parallelismflink-conf.yaml1234cat flink-conf.yaml | grep parallelism# The parallelism used for programs that did not specify and other parallelism.parallelism.default: 1 命令行启动如果你是用命令行启动你的 Flink job，那么你也可以这样设置并行度(使用 -p 并行度)： 1./bin/flink run -p 10 ../word-count.jar 代码设置整个程序的并行度12StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();env.setParallelism(10); 注意：这样设置的并行度是你整个程序的并行度，那么后面如果你的每个算子不单独设置并行度覆盖的话，那么后面每个算子的并行度就都是这里设置的并行度的值了。 每个算子单独设置并行度1234data.keyBy(new xxxKey()) .flatMap(new XxxFlatMapFunction()).setParallelism(5) .map(new XxxMapFunction).setParallelism(5) .addSink(new XxxSink()).setParallelism(1) 如上，就是在每个算子后面单独的设置并行度，这样的话，就算你前面设置了 env.setParallelism(10) 也是会被覆盖的。 这也说明优先级是：算子设置并行度 &gt; env 设置并行度 &gt; 配置文件默认并行度 slot 图中 Task Manager 是从 Job Manager 处接收需要部署的 Task，任务的并行性由每个 Task Manager 上可用的 slot 决定。每个任务代表分配给任务槽的一组资源，slot 在 Flink 里面可以认为是资源组，Flink 将每个任务分成子任务并且将这些子任务分配到 slot 来并行执行程序。 例如，如果 Task Manager 有四个 slot，那么它将为每个 slot 分配 25％ 的内存。 可以在一个 slot 中运行一个或多个线程。 同一 slot 中的线程共享相同的 JVM。 同一 JVM 中的任务共享 TCP 连接和心跳消息。Task Manager 的一个 Slot 代表一个可用线程，该线程具有固定的内存，注意 Slot 只对内存隔离，没有对 CPU 隔离。默认情况下，Flink 允许子任务共享 Slot，即使它们是不同 task 的 subtask，只要它们来自相同的 job。这种共享可以有更好的资源利用率。 默认情况下，Flink 允许 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，只要它们来自同一个 job。因此，一个 slot 可能会负责这个 job 的整个管道（pipeline）。允许 slot sharing 有两个好处： 1.Flink 集群需要与 job 中使用的最高并行度一样多的 slots。这样不需要计算作业总共包含多少个 tasks（具有不同并行度）。 2.更好的资源利用率。在没有 slot sharing 的情况下，简单的 subtasks（source/map()）将会占用和复杂的 subtasks （window）一样多的资源。通过 slot sharing，将示例中的并行度从 2 增加到 6 可以充分利用 slot 的资源，同时确保繁重的 subtask 在 TaskManagers 之间公平地获取资源。 下图即为Flink subtasks 共享 slots的模式： 上面图片中有两个 Task Manager，每个 Task Manager 有三个 slot，这样我们的算子最大并行度那么就可以达到 6 个，在同一个 slot 里面可以执行 1 至多个子任务。 那么再看上面的图片，source/map/keyby/window/apply 最大可以有 6 个并行度，sink 只用了 1 个并行。 每个 Flink TaskManager 在集群中提供 slot。 slot 的数量通常与每个 TaskManager 的可用 CPU 内核数成比例。一般情况下你的 slot 数是你每个 TaskManager 的 cpu 的核数","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：Flink Job ExecutionGraph生成过程","date":"2019-11-08T01:49:18.000Z","path":"2019/11/08/apache-flink:study-flink-job-ExecutionGraph/","text":"Apache Flink 学习：Flink Job 执行计划生成过程 Transformations 并不是每一个 Transformation 都会转换成runtime层中的物理操作。有一些只是逻辑概念，比如union、split/select、partition等。如下图所示的转换树，在运行时会优化成下方的操作图。 执行计划转换过程 1.转换过程 StreamExecutionEnvironment 存放的 transformation -&gt; StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图2.StreamExecutionEnvironment 存放的 transformation -&gt; StreamGraph -&gt; JobGraph 在客户端完成，然后提交 JobGraph 到 JobManager3.JobManager 的主节点 JobMaster，将 JobGraph 转化为 ExecutionGraph，然后发送到不同的 taskManager，得到实际的物理执行图 LocalStreamEnvironment 中 parallelism其中 LocalStreamEnvironment Task 中的 parallelism 数量是根据以下代码生成的 12345678910111213141516171819202122232425262728293031323334@Publicpublic abstract class StreamExecutionEnvironment &#123; ... private static int defaultLocalParallelism = Runtime.getRuntime().availableProcessors(); /** * Creates a &#123;@link LocalStreamEnvironment&#125;. The local execution environment * will run the program in a multi-threaded fashion in the same JVM as the * environment was created in. The default parallelism of the local * environment is the number of hardware contexts (CPU cores / threads), * unless it was specified differently by &#123;@link #setParallelism(int)&#125;. * * @return A local execution environment. */ public static LocalStreamEnvironment createLocalEnvironment() &#123; return createLocalEnvironment(defaultLocalParallelism); &#125; /** * Creates a &#123;@link LocalStreamEnvironment&#125;. The local execution environment * will run the program in a multi-threaded fashion in the same JVM as the * environment was created in. It will use the parallelism specified in the * parameter. * * @param parallelism * The parallelism for the local environment. * @return A local execution environment with the specified parallelism. */ public static LocalStreamEnvironment createLocalEnvironment(int parallelism) &#123; return createLocalEnvironment(parallelism, new Configuration()); &#125; ...&#125;","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：异步IO之RichAsyncFunction","date":"2019-11-06T10:45:59.000Z","path":"2019/11/06/apache-flink:study-async-io-RichAsyncFunction/","text":"Apache Flink 学习：异步IO之RichAsyncFunction 问题设置kafka consumer并行度的语义1.如果设置kafka consumer的并发度为100，并且申请到集群中资源的Task Manager的slot个数也为100个，则每个slot中运行的任务都生成这么多数量的kafka consumer，还是每个slot一个kafka consumer? 2.场景：一个keyBy过后设置了一分钟的窗口dataStream中，如果保证每次触发这个窗口时，窗口的数据永远只有一条的话，并且在保证窗口为1分钟大小的情况下，接口返回速度保证在10秒，使用Async IO是否就没有意义了，因为当前请求队列里面只有一条数据 3.flink 默认执行一个Job的slot中线程数为什么是8，在哪里设置的 使用AsyncIO需要考虑的指标1.每个slot中Flink Job的线程数2.如果需要使用时间窗口：时间窗口的大小，几分钟的窗口2.如果需要keyBy：每个slot中Flink Job的大概key的个数（什么情况使用，什么情况不使用） 简介我们知道flink对于外部数据源的操作可以通过自带的连接器，或者自定义sink和source实现数据的交互，那么为啥还需要异步IO呢？那时因为对于实时处理，当我们需要使用外部存储数据参与计算时，与外部系统之间的交互延迟对流处理的整个工作进度起决定性的影响。如果我们是使用传统方式mapfunction等算子里访问外部存储，实际上该交互过程是同步的，比如下图中：请求a发送到数据库，那么function会一直等待响应。在很多案例中，这个等待过程是非常浪费函数时间的。 图中棕色的长条表示等待时间，可以发现网络等待时间极大地阻碍了吞吐和延迟。为了解决同步访问的问题，异步模式可以并发地处理多个请求和回复。也就是说，你可以连续地向数据库发送用户a、b、c等的请求，与此同时，哪个请求的回复先返回了就处理哪个回复，从而连续的请求之间不需要阻塞等待，如上图右边所示。这也正是 Async I/O 的实现原理。 目的将MapFunction或者FlatMapFunction中的同步访问外部存储设备的方法通过AsyncFunction替换以实现异步访问在执行过程中，如果使用了keyBy，则相同的key整个执行周期都使用同一个线程，但是不同的key也可以使用同一个线程 如何使用Async I/O我们需要自定义一个类实现RichAsyncFunction这个抽象类，实现其中的抽象方法，这点和自定义source很像。主要是的抽象方法如下，然后在asyncInvoke()使用CompletableFuture执行异步操作（CompletableFuture会提供一个ForkJoinPool作为请求线程池） 123456789public void open(Configuration parameters) throws Exception;public void close() throws Exception;void asyncInvoke(IN var1, ResultFuture&lt;OUT&gt; var2) throws Exception;default void timeout(IN input, ResultFuture&lt;OUT&gt; resultFuture) throws Exception &#123; resultFuture.completeExceptionally(new TimeoutException(&quot;Async function call has timed out.&quot;));&#125; 然后在AsyncDataStream中使用我们定义好的类，去实现主流异步的访问外部数据源 原理实现AsyncDataStream.(un)orderedWait 的主要工作就是创建了一个 AsyncWaitOperator。AsyncWaitOperator 是支持异步 IO 访问的算子实现，该算子会运行 AsyncFunction 并处理异步返回的结果，其内部原理如下图所示 如图所示，AsyncWaitOperator 主要由两部分组成：StreamElementQueue 和 Emitter。StreamElementQueue 是一个 Promise 队列，所谓 Promise 是一种异步抽象表示将来会有一个值（参考 Scala Promise 了解更多），这个队列是未完成的 Promise 队列，也就是进行中的请求队列。Emitter 是一个单独的线程，负责发送消息（收到的异步回复）给下游。 图中E5表示进入该算子的第五个元素（”Element-5”），在执行过程中首先会将其包装成一个 “Promise” P5，然后将P5放入队列。最后调用 AsyncFunction 的 ayncInvoke 方法，该方法会向外部服务发起一个异步的请求，并注册回调。该回调会在异步请求成功返回时调用 AsyncCollector.collect 方法将返回的结果交给框架处理。实际上 AsyncCollector 也一个 Promise，也就是 P5，在调用 collect 的时候会标记 Promise 为完成状态，并通知 Emitter 线程有完成的消息可以发送了。Emitter 就会从队列中拉取完成的 Promise ，并从 Promise 中取出消息发送给下游。 消息的顺序性上文提到 Async I/O 提供了两种输出模式。其实细分有三种模式: 有序，ProcessingTime 无序，EventTime 无序。Flink 使用队列来实现不同的输出模式，并抽象出一个队列的接口（StreamElementQueue），这种分层设计使得AsyncWaitOperator和Emitter不用关心消息的顺序问题。StreamElementQueue有两种具体实现，分别是 OrderedStreamElementQueue 和 UnorderedStreamElementQueue。UnorderedStreamElementQueue 比较有意思，它使用了一套逻辑巧妙地实现完全无序和 EventTime 无序 有序有序比较简单，使用一个队列就能实现。所有新进入该算子的元素（包括 watermark），都会包装成 Promise 并按到达顺序放入该队列。如下图所示，尽管P4的结果先返回，但并不会发送，只有 P1 （队首）的结果返回了才会触发 Emitter 拉取队首元素进行发送 ProcessingTime 无序ProcessingTime 无序也比较简单，因为没有 watermark，不需要协调 watermark 与消息的顺序性，所以使用两个队列就能实现，一个 uncompletedQueue 一个 completedQueue。所有新进入该算子的元素，同样的包装成 Promise 并放入 uncompletedQueue 队列，当uncompletedQueue队列中任意的Promise返回了数据，则将该 Promise 移到 completedQueue 队列中，并通知 Emitter 消费。如下图所示： EventTime 无序EventTime 无序类似于有序与 ProcessingTime 无序的结合体。因为有 watermark，需要协调 watermark 与消息之间的顺序性，所以uncompletedQueue中存放的元素从原先的 Promise 变成了 Promise 集合。如果进入算子的是消息元素，则会包装成 Promise 放入队尾的集合中。如果进入算子的是 watermark，也会包装成 Promise 并放到一个独立的集合中，再将该集合加入到 uncompletedQueue 队尾，最后再创建一个空集合加到 uncompletedQueue 队尾。这样，watermark 就成了消息顺序的边界。只有处在队首的集合中的 Promise 返回了数据，才能将该 Promise 移到 completedQueue 队列中，由 Emitter 消费发往下游。只有队首集合空了，才能处理第二个集合。这样就保证了当且仅当某个 watermark 之前所有的消息都已经被发送了，该 watermark 才能被发送。过程如下图所示： 说明1、AsyncDataStream有2个方法，unorderedWait表示数据不需要关注顺序，处理完立即发送，orderedWait表示数据需要关注顺序，为了实现该目标，操作算子会在该结果记录之前的记录为发送之前缓存该记录。这往往会引入额外的延迟和一些Checkpoint负载，因为相比于无序模式结果记录会保存在Checkpoint状态内部较长的时间。2、Timeout配置，主要是为了处理死掉或者失败的任务，防止资源被长期阻塞占用。3、最后一个参数Capacity表示同时最多有多少个异步请求在处理，异步IO的方式会导致更高的吞吐量，但是对于实时应用来说该操作也是一个瓶颈。限制并发请求数，算子不会积压过多的未处理请求，但是一旦超过容量的显示会触发背压。该参数可以不配置，但是默认是100","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Common 包学习：常用集合类Collections4学习","date":"2019-11-06T08:04:06.000Z","path":"2019/11/06/apache-common:study-apache-common-collections4/","text":"Apache Common 包学习：常用集合类Collections4学习 Maven依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CollectionUtils&lt;O&gt; Collection&lt;O&gt; subtract(final Iterable&lt;? extends O&gt; a, final Iterable&lt;? extends O&gt; b)a是做差集运算的左集，b是做差集运算的右集，下面是一个例子 1234567891011121314151617181920public class Demo &#123; private static final Logger LOGGER = LoggerFactory.getLogger(Demo.class); public static void main(String[] args) &#123; Set&lt;Pair&lt;String, String&gt;&gt; allProductDevices = Sets.newHashSet(Pair.of(&quot;a&quot;, &quot;b&quot;), Pair.of(&quot;c&quot;, &quot;d&quot;)); Set&lt;Pair&lt;String, String&gt;&gt; oldProductDevices = Sets.newHashSet(Pair.of(&quot;a&quot;, &quot;b&quot;), Pair.of(&quot;e&quot;, &quot;f&quot;)); List&lt;Pair&lt;String, String&gt;&gt; newProductDevices = (ArrayList&lt;Pair&lt;String, String&gt;&gt;) CollectionUtils.subtract(allProductDevices, oldProductDevices); List&lt;String&gt; list1 = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;); List&lt;String&gt; list2 = Lists.newArrayList(&quot;c&quot;, &quot;b&quot;); List&lt;String&gt; list3 = (ArrayList&lt;String&gt;) CollectionUtils.subtract(list1, list2); &#125;&#125;","tags":[{"name":"Apache Common包","slug":"Apache-Common包","permalink":"https://yangyichao-mango.github.io/tags/Apache-Common%E5%8C%85/"}]},{"title":"Google Guava 学习：guava cache缓存学习","date":"2019-11-06T08:03:38.000Z","path":"2019/11/06/google-guava:study-guava-cache/","text":"Google Guava 学习：guava cache缓存学习 背景缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。在日长开发有很多场合，有一些数据量不是很大，不会经常改动，并且访问非常频繁。但是由于受限于硬盘IO的性能或者远程网络等原因获取可能非常的费时。会导致我们的程序非常缓慢，这在某些业务上是不能忍的！而缓存正是解决这类问题的神器！ 正文Guava Cache与ConcurrentMap很相似，但也不完全一样。最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存 Guava Cache是在内存中缓存数据，相比较于数据库或redis存储，访问内存中的数据会更加高效。Guava官网介绍，下面的这几种情况可以考虑使用Guava Cache： 1.愿意消耗一些内存空间来提升速度。 2.预料到某些键会被多次查询。 3.缓存中存放的数据总量不会超出内存容量。 所以，可以将程序频繁用到的少量数据存储到Guava Cache中，以改善程序性能。下面对Guava Cache的用法进行详细的介绍。 Maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt; 构建缓存对象接口Cache代表缓存，它有如下方法： 1234567891011121314151617181920212223public interface Cache&lt;K, V&gt; &#123; V get(K key, Callable&lt;? extends V&gt; valueLoader) throws ExecutionException; ImmutableMap&lt;K, V&gt; getAllPresent(Iterable&lt;?&gt; keys); void put(K key, V value); void putAll(Map&lt;? extends K, ? extends V&gt; m); void invalidate(Object key); void invalidateAll(Iterable&lt;?&gt; keys); void invalidateAll(); long size(); CacheStats stats(); ConcurrentMap&lt;K, V&gt; asMap(); void cleanUp();&#125; 可以通过CacheBuilder类构建一个缓存对象，构建一个缓存对象代码如下 1234567public class StudyGuavaCache &#123; public static void main(String[] args) &#123; Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder().build(); cache.put(&quot;word&quot;,&quot;Hello Guava Cache&quot;); System.out.println(cache.getIfPresent(&quot;word&quot;)); &#125;&#125; 可以看到Cache非常类似于JDK中的Map，但是相比于Map，Guava Cache提供了很多更强大的功能 设置最大存储Guava Cache可以在构建缓存对象时指定缓存所能够存储的最大记录数量。当Cache中的记录数量达到最大值后再调用put方法向其中添加对象，Guava会先从当前缓存的对象记录中选择一条删除掉，腾出空间后再将新的对象存储到Cache中 12345678910111213public class StudyGuavaCache &#123; public static void main(String[] args) &#123; Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); System.out.println(&quot;第一个值：&quot; + cache.getIfPresent(&quot;key1&quot;)); System.out.println(&quot;第二个值：&quot; + cache.getIfPresent(&quot;key2&quot;)); System.out.println(&quot;第三个值：&quot; + cache.getIfPresent(&quot;key3&quot;)); &#125;&#125; 上面代码在构造缓存对象时，通过CacheBuilder类的maximumSize方法指定Cache最多可以存储两个对象，然后调用Cache的put方法向其中添加了三个对象。程序执行结果如下图所示，可以看到第三条对象记录的插入，导致了第一条对象记录被删除 123第一个值：null第二个值：value2第三个值：value3 设置过期时间在构建Cache对象时，可以通过CacheBuilder类的expireAfterAccess和expireAfterWrite两个方法为缓存中的对象指定过期时间，过期的对象将会被缓存自动删除。其中，expireAfterWrite方法指定对象被写入到缓存后多久过期，expireAfterAccess指定对象多久没有被访问后过期 expireAfterWrite1234567891011121314public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .expireAfterWrite(3, TimeUnit.SECONDS) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); int time = 1; while (true) &#123; System.out.println(&quot;第&quot; + time++ + &quot;次取到key1的值为：&quot; + cache.getIfPresent(&quot;key1&quot;)); Thread.sleep(1000); &#125; &#125;&#125; 上面的代码在构造Cache对象时，通过CacheBuilder的expireAfterWrite方法指定put到Cache中的对象在3秒后会过期。在Cache对象中存储一条对象记录后，每隔1秒读取一次这条记录。程序运行结果如下图所示，可以看到，前三秒可以从Cache中获取到对象，超过三秒后，对象从Cache中被自动删除 12345678第1次取到key1的值为：value1第2次取到key1的值为：value1第3次取到key1的值为：value1第4次取到key1的值为：null第5次取到key1的值为：null第6次取到key1的值为：null第7次取到key1的值为：null第8次取到key1的值为：null expireAfterAccess1234567891011121314public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .expireAfterAccess(3, TimeUnit.SECONDS) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); double time = 1.5; while (true) &#123; Thread.sleep((long) time * 1000L); System.out.println(&quot;睡眠&quot; + time++ + &quot;秒后取到key1的值为：&quot; + cache.getIfPresent(&quot;key1&quot;)); &#125; &#125;&#125; 通过CacheBuilder的expireAfterAccess方法指定Cache中存储的对象如果超过3秒没有被访问就会过期。while中的代码每sleep一段时间就会访问一次Cache中存储的对象key1，每次访问key1之后下次sleep的时间会加长一秒。程序运行结果如下图所示，从结果中可以看出，当超过3秒没有读取key1对象之后，该对象会自动被Cache删除。 123睡眠1.5秒后取到key1的值为：value1睡眠2.5秒后取到key1的值为：value1睡眠3.5秒后取到key1的值为：null 也可以同时用expireAfterAccess和expireAfterWrite方法指定过期时间，这时只要对象满足两者中的一个条件就会被自动过期删除。 弱引用可以通过weakKeys和weakValues方法指定Cache只保存对缓存记录key和value的弱引用。这样当没有其他强引用指向key和value时，key和value对象就会被垃圾回收器回收 1234567891011121314public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, Object&gt; cache = CacheBuilder.newBuilder() .maximumSize(2) .weakValues() .build(); Object value = new Object(); cache.put(&quot;key1&quot;, value); value = new Object(); // 原对象不再有强引用 System.gc(); System.out.println(cache.getIfPresent(&quot;key1&quot;)); &#125;&#125; 上面代码的打印结果是null。构建Cache时通过weakValues方法指定Cache只保存记录值的一个弱引用。当给value引用赋值一个新的对象之后，就不再有任何一个强引用指向原对象。System.gc()触发垃圾回收后，原对象就被清除了 1null 显示清除可以调用Cache的invalidateAll或invalidate方法显示删除Cache中的记录。invalidate方法一次只能删除Cache中一个记录，接收的参数是要删除记录的key。invalidateAll方法可以批量删除Cache中的记录，当没有传任何参数时，invalidateAll方法将清除Cache中的全部记录。invalidateAll也可以接收一个Iterable类型的参数，参数中包含要删除记录的所有key值。下面代码对此做了示例 123456789101112131415161718public class StudyGuavaCache &#123; public static void main(String[] args) &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(); Object value = new Object(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;key1&quot;); list.add(&quot;key2&quot;); cache.invalidateAll(list); // 批量清除list中全部key对应的记录 System.out.println(cache.getIfPresent(&quot;key1&quot;)); System.out.println(cache.getIfPresent(&quot;key2&quot;)); System.out.println(cache.getIfPresent(&quot;key3&quot;)); &#125;&#125; 代码中构造了一个集合list用于保存要删除记录的key值，然后调用invalidateAll方法批量删除key1和key2对应的记录，只剩下key3对应的记录没有被删除 123nullnullvalue3 移除监听器可以为Cache对象添加一个移除监听器，这样当有记录被删除时可以感知到这个事件 123456789101112131415161718public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; RemovalListener&lt;String, String&gt; listener = notification -&gt; System.out.println(&quot;[&quot; + notification.getKey() + &quot;:&quot; + notification.getValue() + &quot;] is removed!&quot;); Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(3) .removalListener(listener) .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); cache.put(&quot;key4&quot;, &quot;value3&quot;); cache.put(&quot;key5&quot;, &quot;value3&quot;); cache.put(&quot;key6&quot;, &quot;value3&quot;); cache.put(&quot;key7&quot;, &quot;value3&quot;); cache.put(&quot;key8&quot;, &quot;value3&quot;); &#125;&#125; removalListener方法为Cache指定了一个移除监听器，这样当有记录从Cache中被删除时，监听器listener就会感知到这个事件。程序运行结果如下图所示 12345[key1:value1] is removed![key2:value2] is removed![key3:value3] is removed![key4:value3] is removed![key5:value3] is removed! 自动加载Cache的get方法有两个参数，第一个参数是要从Cache中获取记录的key，第二个记录是一个Callable对象。当缓存中已经存在key对应的记录时，get方法直接返回key对应的记录。如果缓存中不包含key对应的记录，Guava会使用当前线程执行Callable对象中的call方法，call方法的返回值会作为key对应的值被存储到缓存中，并且被get方法返回。下面是一个多线程的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StudyGuavaCache &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StudyGuavaCache.class); private static Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(1) .build(); public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; public void run() &#123; LOGGER.info(&quot;1&quot; + Thread.currentThread().getName()); try &#123; String value = cache.get(&quot;key&quot;, new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; LOGGER.info(&quot;load1&quot; + Thread.currentThread().getName()); // 加载数据线程执行标志 Thread.sleep(1000); // 模拟加载时间 return &quot;auto load by Callable1&quot;; &#125; &#125;); LOGGER.info(&quot;thread1 &quot; + value); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; LOGGER.info(&quot;thread2&quot;); try &#123; LOGGER.info(&quot;2&quot; + Thread.currentThread().getName()); String value = cache.get(&quot;key1&quot;, new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; LOGGER.info(&quot;load2&quot; + Thread.currentThread().getName()); // 加载数据线程执行标志 Thread.sleep(1000); // 模拟加载时间 return &quot;auto load by Callable2&quot;; &#125; &#125;); LOGGER.info(&quot;thread2 &quot; + value); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 这段代码中有两个线程共享同一个Cache对象，两个线程同时调用get方法获取同一个key对应的记录。由于key对应的记录不存在，所以两个线程都在get方法处阻塞。此处在call方法中调用Thread.sleep(1000)模拟程序从外存加载数据的时间消耗 1234517:49:23.965 [Thread-2] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - thread217:49:23.965 [Thread-1] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - 1Thread-117:49:23.969 [Thread-2] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - 2Thread-217:49:23.983 [Thread-1] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - load1Thread-117:49:23.983 [Thread-2] INFO com.github.xxx.other.demo.guava.StudyGuavaCache - load2Thread-2 从结果中可以看出，虽然是两个线程同时调用get方法，但只有一个get方法中的Callable会被执行(没有打印出load2)。Guava可以保证当有多个线程同时访问Cache中的一个key时，如果key对应的记录不存在，Guava只会启动一个线程执行get方法中Callable参数对应的任务加载数据存到缓存。当加载完数据后，任何线程中的get方法都会获取到key对应的值 统计信息可以对Cache的命中率、加载数据时间等信息进行统计。在构建Cache对象时，可以通过CacheBuilder的recordStats方法开启统计信息的开关。开关开启后Cache会自动对缓存的各种操作进行统计，调用Cache的stats方法可以查看统计后的信息 123456789101112131415161718192021public class StudyGuavaCache &#123; public static void main(String[] args) throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .maximumSize(3) .recordStats() // 开启统计信息开关 .build(); cache.put(&quot;key1&quot;, &quot;value1&quot;); cache.put(&quot;key2&quot;, &quot;value2&quot;); cache.put(&quot;key3&quot;, &quot;value3&quot;); cache.put(&quot;key4&quot;, &quot;value4&quot;); cache.getIfPresent(&quot;key1&quot;); cache.getIfPresent(&quot;key2&quot;); cache.getIfPresent(&quot;key3&quot;); cache.getIfPresent(&quot;key4&quot;); cache.getIfPresent(&quot;key5&quot;); cache.getIfPresent(&quot;key6&quot;); System.out.println(cache.stats()); // 获取统计信息 &#125;&#125; 程序执行结果如下所示 1CacheStats&#123;hitCount=3, missCount=3, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=1&#125; 这些统计信息对于调整缓存设置是至关重要的，在性能要求高的应用中应该密切关注这些数据 LoadingCacheLoadingCache是Cache的子接口，相比较于Cache，当从LoadingCache中读取一个指定key的记录时，如果该记录不存在，则LoadingCache可以自动执行加载数据到缓存的操作。LoadingCache接口的定义如下： 123456789101112131415public interface LoadingCache&lt;K, V&gt; extends Cache&lt;K, V&gt;, Function&lt;K, V&gt; &#123; V get(K key) throws ExecutionException; V getUnchecked(K key); ImmutableMap&lt;K, V&gt; getAll(Iterable&lt;? extends K&gt; keys) throws ExecutionException; V apply(K key); void refresh(K key); @Override ConcurrentMap&lt;K, V&gt; asMap();&#125; 与构建Cache类型的对象类似，LoadingCache类型的对象也是通过CacheBuilder进行构建，不同的是，在调用CacheBuilder的build方法时，必须传递一个CacheLoader类型的参数，CacheLoader的load方法需要我们提供实现。当调用LoadingCache的get方法时，如果缓存不存在对应key的记录，则CacheLoader中的load方法会被自动调用从外存加载数据，load方法的返回值会作为key对应的value存储到LoadingCache中，并从get方法返回 12345678910111213141516171819public class StudyGuavaCache &#123; public static void main(String[] args) throws ExecutionException &#123; CacheLoader&lt;String, String&gt; loader = new CacheLoader&lt;String, String&gt;() &#123; public String load(String key) throws Exception &#123; Thread.sleep(1000); // 休眠1s，模拟加载数据 System.out.println(key + &quot; is loaded from a cacheLoader!&quot;); return key + &quot;&#x27;s value&quot;; &#125; &#125;; LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder() .maximumSize(3) .build(loader); // 在构建时指定自动加载器 loadingCache.get(&quot;key1&quot;); loadingCache.get(&quot;key2&quot;); loadingCache.get(&quot;key3&quot;); &#125;&#125; 程序执行结果如下所示： 123key1 is loaded from a cacheLoader!key2 is loaded from a cacheLoader!key3 is loaded from a cacheLoader! 从LoadingCache查询的正规方式是使用get(K)方法。这个方法要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值（通过load(String key) 方法加载）。由于CacheLoader可能抛出异常，LoadingCache.get(K)也声明抛出ExecutionException异常。如果你定义的CacheLoader没有声明任何检查型异常，则可以通过getUnchecked(K)查找缓存；但必须注意，一旦CacheLoader声明了检查型异常，就不可以调用getUnchecked(K)。","tags":[{"name":"guava","slug":"guava","permalink":"https://yangyichao-mango.github.io/tags/guava/"}]},{"title":"apache-kafka:study-features","date":"2019-11-06T01:57:17.000Z","path":"2019/11/06/apache-kafka:study-features/","text":"如何为Kafka集群选择合适的Partitions数量越多的分区可以提供更高的吞吐量首先我们需要明白以下事实：在kafka中，单个patition是kafka并行操作的最小单元。在producer和broker端，向每一个分区写入数据是可以完全并行化的，此时，可以通过加大硬件资源的利用率来提升系统的吞吐量，例如对数据进行压缩。在consumer段，kafka只允许单个partition的数据被一个consumer线程消费。因此，在consumer端，每一个Consumer Group内部的consumer并行度完全依赖于被消费的分区数量。综上所述，通常情况下，在一个Kafka集群中，partition的数量越多，意味着可以到达的吞吐量越大。 我们可以粗略地通过吞吐量来计算kafka集群的分区数量。假设对于单个partition，producer端的可达吞吐量为p，Consumer端的可达吞吐量为c，期望的目标吞吐量为t，那么集群所需要的partition数量至少为max(t/p,t/c)。在producer端，单个分区的吞吐量大小会受到批量大小、数据压缩方法、 确认类型（同步/异步）、复制因子等配置参数的影响。经过测试，在producer端，单个partition的吞吐量通常是在10MB/s左右。在consumer端，单个partition的吞吐量依赖于consumer端每个消息的应用逻辑处理速度。因此，我们需要对consumer端的吞吐量进行测量。 虽然随着时间的推移，我们能够对分区的数量进行添加，但是对于基于Key来生成的这一类消息需要我们重点关注。当producer向kafka写入基于key的消息时，kafka通过key的hash值来确定消息需要写入哪个具体的分区。通过这样的方案，kafka能够确保相同key值的数据可以写入同一个partition。kafka的这一能力对于一部分应用是极为重要的，例如对于同一个key的所有消息，consumer需要按消息的顺序进行有序消费。如果partition的数量发生改变，那么上面的有序性保证将不复存在。为了避免上述情况发生，通常的解决办法是多分配一些分区，以满足未来的需求。通常情况下，我们需要根据未来1到2年的目标吞吐量来设计kafka的分区数量。 一开始，我们可以基于当前的业务吞吐量为kafka集群分配较小的broker数量，随着时间的推移，我们可以向集群中增加更多的broker，然后在线方式将适当比例的partition转移到新增加的broker中去。通过这样的方法，我们可以在满足各种应用场景（包括基于key消息的场景）的情况下，保持业务吞吐量的扩展性。 在设计分区数时，除了吞吐量，还有一些其他因素值得考虑。正如我们后面即将看到的，对于一些应用场景，集群拥有过的分区将会带来负面的影响。","tags":[{"name":"Apache Kafka","slug":"Apache-Kafka","permalink":"https://yangyichao-mango.github.io/tags/Apache-Kafka/"}]},{"title":"Apache Flink 学习：系统特性学习","date":"2019-11-03T08:20:21.000Z","path":"2019/11/03/apache-flink:study-features/","text":"Apache Flink 学习：系统特性学习 教程 window窗口窗口大小窗口大小是用户自己设定的，但是窗口的起始和结束时间点是系统根据窗口大小和自然数进行设定的，不会出现设置了一分钟的窗口，统计的数据是2:30到3:30的数据 [window_start_time, window_end_time)根据窗口大小和自然数进行设定 如果window大小是3秒，那么1分钟内会把window划分为如下的形式: 1234[00:00:00,00:00:03)[00:00:03,00:00:06)...[00:00:57,00:01:00) 如果window大小是10秒，则window会被分为如下的形式： 1234[00:00:00,00:00:10)[00:00:10,00:00:20)...[00:00:50,00:01:00) watermark123456789@Overridepublic final Watermark getCurrentWatermark() &#123; // this guarantees that the watermark never goes backwards. long potentialWM = currentMaxTimestamp - maxOutOfOrderness; if (potentialWM &gt;= lastEmittedWatermark) &#123; lastEmittedWatermark = potentialWM; &#125; return new Watermark(lastEmittedWatermark);&#125; watermark = max( [当前已到达的时间戳最新的数据(currentMaxTimestamp)] - [最大乱序等待时间(maxOutOfOrderness)], watermark ) 触发窗口运算条件1.当前最新数据到达进行判断：当前到达event的time(timestamp) ＜ watermark则触发，表示数据是超过了最大等待时间，已经延迟到达的，则会触发 2.当前最新数据到达进行判断：最新的watermark &gt;= window_end_time（对于out-of-order以及正常的数据而言），在[window_start_time, window_end_time)中有数据存在 3.而且，这里要强调一点，watermark和currentMaxTimestamp是一个全局的值，不是某一个key下的值，所以即使不是同一个key的数据，其warmark也会增加 语义是：currentMaxTimestamp是当前到达的最大时间戳数据，代表时间戳为currentMaxTimestamp的数据已经到达了，所以所能等待的数据的时间戳（max_out_of_orderness）只能为watermark = currentMaxTimestamp - maxOutOfOrderness 窗口计算Window reduce，Window aggregate 和 Window Fold 是增量聚合，每来一条数据就计算一次，高效 Window apply（Window process 的老版本） 和 Window process 是全量聚合，触发窗口计算时全量计算 被Keys化与非被Keys化Windows要指定的第一件事是您的流是否应该使用keyedWindow，一般都与业务逻辑有关，比如说使用一分钟的窗口进行去重。使用keyBy(…)将您的无限流分成逻辑Key化的数据流。如果keyBy(…)未调用，则表示您的流不是被Keys化的。 对于被Key化的数据流，可以将传入数据（Object）的的任何属性用作键）。拥有被Key化的数据流将允许您的窗口计算由多个任务并行执行，因为每个Key化的数据流可以独立于其余任务进行处理。引用相同Keys的所有数据将被发送到同一个并行任务进行计算。 在非被Key化的数据流的情况下，您的原始流将不会被拆分为多个逻辑流，并且所有窗口逻辑将由单个任务执行，即并行度为1。 sql1.在flinkSql中，如果使用groupBy，尽量使用窗口，否则会认为被groupBy的数据会默认人为整个窗口内的数据还没有到达，所以会一直等待，不会产出数据 update-mode: append / update 分为 update stream 模式和 append stream 模式 window聚合为append mode stream，groupby聚合为update mode stream Flink生成 Timestamps 和 Watermarks为了让event time工作，Flink需要知道事件的时间戳，这意味着流中的每个元素都需要分配其事件时间戳。这个通常是通过抽取或者访问事件中某些字段的时间戳来获取的。 时间戳的分配伴随着水印的生成，告诉系统事件时间中的进度。 这里有两种方式来分配时间戳和生成水印: 直接在数据流源中进行。 通过timestamp assigner和watermark generator生成:在Flink中，timestamp分配器也定义了用来发射的水印。 数据流源生成Timestamps和Watermarks数据流源可以直接为它们产生的数据元素分配timestamp，并且他们也能发送水印。这样做的话，就没必要再去定义timestamp分配器了，需要注意的是:如果一个timestamp分配器被使用的话，由源提供的任何timestamp和watermark都会被重写。 时间戳分配器/水印生成器（Timestamp Assigners / Watermark Generators）Timestamp分配器获取一个流并生成一个新的带有Timestamp元素和水印的流。如果原始流已经有时间戳和/或水印，则Timestamp分配程序将覆盖它们 Timestamp分配器通常在数据源之后立即指定，但这并不是严格要求的。通常是在timestamp分配器之前先解析(MapFunction)和过滤(FilterFunction)。在任何情况下，都需要在事件时间上的第一个操作(例如第一个窗口操作)之前指定timestamp分配程序。有一个特殊情况，当使用Kafka作为流作业的数据源时，Flink允许在源内部指定timestamp分配器和watermark生成器。更多关于如何进行的信息请参考Kafka Connector的文档。 直接在FlinkKafkaConsumer010上面使用assignTimestampsAndWatermarks可以根据kafka source的partitions的特性进行设置Timestamps和Watermarks，让用户做一些特殊的处理 Running timestamp extractors / watermark generators directly inside the Kafka source, per Kafkapartition, allows users to let them exploit the per-partition characteristics. logWeb UI查找logJobManger log： 展示整个作业的状态变化（例如，从create 到deploy到running再到failed），通过jobManger log可以查看作业历史失败的记录和直接原因。 TaskManager log： 调度到该TaskManager上的task 的打印的相关log。 shuffle被keyBy的数据流中，相同的key的数据会被发送到同一个slot中运行（partitiner决定），也就是TaskManager中slot进行shuffle的过程如果有多个producer并且producer的数量和partition数量相同，则每个producer写一个partition Savepoints和Checkpoints用 Data Stream API 编写的程序可以从 savepoint 继续执行。Savepoints 允许在不丢失任何状态的情况下升级程序和 Flink 集群。 Savepoints 是手动触发的 Checkpoints，它依靠常规的 Checkpoint 机制获取程序的快照并将其写入 state backend。在执行期间，程序会定期在 worker 节点上创建快照并生成 Checkpoints。对于恢复，Flink 仅需要最后完成的 Checkpoint，而一旦完成了新的 Checkpoint，旧的就可以被丢弃。 Savepoints 类似于这些定期的 Checkpoints，除了它们是由用户触发并且在新的 Checkpoints 完成时不会自动过期。你可以通过命令行 或在取消一个 job 时通过 REST API 来创建 Savepoints。","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Flink 学习：实时场景下的应用","date":"2019-11-03T05:30:05.000Z","path":"2019/11/03/apache-flink:study-realtime-scenario/","text":"Apache Flink 学习：实时场景下的应用 用户需求场景用户想要查看 版本，机型，国家，城市 等等维度下按照分钟的时间粒度的设备活跃，新增设备数，首次活跃设备数 用户需求-&gt;架构方案设计 数据所处阶段 功能描述 数据source 各种各样的打到kafka的用户行为数据的日志 数据process 实时引擎消费kafka，根据数据服务化提供的接口判断当前用户是否是新增，活跃，首次活跃，将用户的相关数据打到下游kafka 数据sink 结果kafka olap引擎 消费sink kafka 数据产品 通过BI等的产品呈现给用户 架构设计-&gt;选择实时计算引擎为什么使用flink： A.保证消费一次：checkpoint和savepoint 容错 B.时间属性：事件，注入，处理时间 优点：事件时间的属性可以被广泛应用，比如一般的分析场景都是分析用户某个时间段的用户相关指标，而不是事件处理某个时间段的用户相关指标 flink实现方案第一种方案方案新增场景下，每消费一条source kafka用户数据就判断一次是否为新增，判断方式可以选择自己维护历史全量数据，或者使用数据服务化提供的接口，最后将结果写入sink kafka 存在的问题 数据处理阶段 问题 结果（仅仅指当前问题会产生的结果） 是否可解决 数据source 同一个用户的行为数据到达时间间隔很小，几秒内就可能会产生几十条行为日志，判断是否为新增，活跃用户时可能会被重复判断 最终数据结果＞真实结果 可部分解决 数据process 自己维护全量数据1.每判断一条就更新历史全量数据就不存在问题2.如果历史全量数据更新有问题就会产生和数据服务化一样的下面两种问题 可部分解决 数据process 数据服务化维护全量数据且更新不及时在新增的场景下，一个新增用户使用app可能会在短时间内上报成百上千条行为日志，如果第一条数据判断出来这个用户是新增，下一条数据判断时，数据服务化提供的全量用户里还没有及时将这条新增用户数据添加进去，则这条数据也会被判断为新增，就会导致最终结果重复 最终数据结果＞真实结果 可部分解决 数据process 数据服务化维护全量数据且更新过快数据服务化更新速度快于flink消费source kafka的速度：就会导致本来是新增的设备被判断不是新增，导致最终结果漏判 最终数据结果＜真实结果 暂时无法解决 解决方案后续解决方法只讨论上述可部分解决的问题 数据处理阶段 问题 解决方案 数据source 同一个用户的行为数据到达时间间隔很小，可能会被重复判断 使用flink窗口解决部分问题使用滚动窗口解决，将一段时间内的用户行为收集，然后到达窗口结束时间处理后再进行上报。假设设置一小时的窗口，则将这一小时的用户行为数据只取一条进行判断是否为新增，则可以极大的保证当前用户判断为新增时，下一小时窗口中这个用户不太可能被判断为新增了，因为数据服务化没有那么慢 数据process 数据服务化维护全量数据且更新不及时，最终结果重复 第一种方案-&gt;第二种方案方案使用窗口可以部分解决在新增活跃等场景下用户行为数据重复的问题 但是使用了窗口也会引入问题，就是虽然大窗口可以保证尽可能去重，但是数据的实时性大大降低，所以窗口设置不能大也不能小，窗口大保证不了数据产出及时性，窗口小去重效果差，所以最大窗口就为一分钟，和用户期望看板中结果一致 存在的问题 数据处理阶段 问题 结果（仅仅指当前问题会产生的结果） 是否可解决 数据source 由于用户行为数据到达source，或者从source到达process阶段，由于网络延迟等的问题，会导致处理用户数据时有乱序情况比如计算实时活跃设备，上一分钟的数据如果下一分钟才到达，则该条数据就会被上一分钟漏算 最终数据结果＜真实结果 可部分解决 数据process 解决方案 数据处理阶段 问题 解决方案 数据source 数据乱序延迟漏算 在flink窗口计算中，通过timestamp和watermark特性来尽可能解决 数据process 第二种方案-&gt;第三种方案方案设置一分钟的窗口，然后设置一分钟的最大延迟等待时间，其语义是保证数据最多延迟一分钟到达，只要可以保证这个语义可以保证最后数据的正确性","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"},{"name":"实时计算","slug":"实时计算","permalink":"https://yangyichao-mango.github.io/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"}]},{"title":"Apache Flink 学习：BoundedOutOfOrdernessTimestampExtractor","date":"2019-11-02T08:48:43.000Z","path":"2019/11/02/apache-flink:study-BoundedOutOfOrdernessTimestampExtractor/","text":"Apache Flink 学习：BoundedOutOfOrdernessTimestampExtractor 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * &quot;License&quot;); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.flink.streaming.api.functions.timestamps;import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;import org.apache.flink.streaming.api.watermark.Watermark;import org.apache.flink.streaming.api.windowing.time.Time;/** * This is a &#123;@link AssignerWithPeriodicWatermarks&#125; used to emit Watermarks that lag behind the element with * the maximum timestamp (in event time) seen so far by a fixed amount of time, &lt;code&gt;t_late&lt;/code&gt;. This can * help reduce the number of elements that are ignored due to lateness when computing the final result for a * given window, in the case where we know that elements arrive no later than &lt;code&gt;t_late&lt;/code&gt; units of time * after the watermark that signals that the system event-time has advanced past their (event-time) timestamp. * */public abstract class BoundedOutOfOrdernessTimestampExtractor&lt;T&gt; implements AssignerWithPeriodicWatermarks&lt;T&gt; &#123; private static final long serialVersionUID = 1L; /** The current maximum timestamp seen so far. */ /** 数据流的最大时间戳 */ private long currentMaxTimestamp; /** The timestamp of the last emitted watermark. */ /** 最后一次已提交的最新 [水印]（当前批次水印） */ private long lastEmittedWatermark = Long.MIN_VALUE; /** * The (fixed) interval between the maximum seen timestamp seen in the records * and that of the watermark to be emitted. * 最大乱序时间间隔 * 将要被提交的 [水印] 和 [数据流的最大时间戳] 的固定时间间隔 * 如果 [数据流的最大时间戳] - [当前批次水印] &gt; [最大乱序时间间隔] * 则就会打上一个新的 [水印] */ private final long maxOutOfOrderness; public BoundedOutOfOrdernessTimestampExtractor(Time maxOutOfOrderness) &#123; if (maxOutOfOrderness.toMilliseconds() &lt; 0) &#123; throw new RuntimeException(&quot;Tried to set the maximum allowed &quot; + &quot;lateness to &quot; + maxOutOfOrderness + &quot;. This parameter cannot be negative.&quot;); &#125; this.maxOutOfOrderness = maxOutOfOrderness.toMilliseconds(); this.currentMaxTimestamp = Long.MIN_VALUE + this.maxOutOfOrderness; &#125; public long getMaxOutOfOrdernessInMillis() &#123; return maxOutOfOrderness; &#125; /** * Extracts the timestamp from the given element. * 从当前数据流元素中获取 [时间戳] 字段，需要用户根据业务自定义 * * @param element The element that the timestamp is extracted from. * @return The new timestamp. */ public abstract long extractTimestamp(T element); /** * 如果 [当前数据流最大时间戳] - [最大乱序时间间隔] &gt;= [最后一次已提交的时间戳] * 则更新 [最后一次已提交的时间戳] */ @Override public final Watermark getCurrentWatermark() &#123; // this guarantees that the watermark never goes backwards. long potentialWM = currentMaxTimestamp - maxOutOfOrderness; if (potentialWM &gt;= lastEmittedWatermark) &#123; lastEmittedWatermark = potentialWM; &#125; return new Watermark(lastEmittedWatermark); &#125; /** * 获取数据流中当前最大时间戳 */ @Override public final long extractTimestamp(T element, long previousElementTimestamp) &#123; long timestamp = extractTimestamp(element); if (timestamp &gt; currentMaxTimestamp) &#123; currentMaxTimestamp = timestamp; &#125; return timestamp; &#125;&#125; ****12345678910111213141516171819/** * Sets the time characteristic for all streams create from this environment, e.g., processing * time, event time, or ingestion time. * * &lt;p&gt;If you set the characteristic to IngestionTime of EventTime this will set a default * watermark update interval of 200 ms. If this is not applicable for your application * you should change it using &#123;@link ExecutionConfig#setAutoWatermarkInterval(long)&#125;. * * @param characteristic The time characteristic. */@PublicEvolvingpublic void setStreamTimeCharacteristic(TimeCharacteristic characteristic) &#123; this.timeCharacteristic = Preconditions.checkNotNull(characteristic); if (characteristic == TimeCharacteristic.ProcessingTime) &#123; getConfig().setAutoWatermarkInterval(0); &#125; else &#123; getConfig().setAutoWatermarkInterval(200); &#125;&#125; window触发机制window的触发机制，是先按照自然时间将window划分，如果window大小是3秒，那么1分钟内会把window划分为如下的形式: 1234[00:00:00,00:00:03)[00:00:03,00:00:06)...[00:00:57,00:01:00) 如果window大小是10秒，则window会被分为如下的形式： 1234[00:00:00,00:00:10)[00:00:10,00:00:20)...[00:00:50,00:01:00)","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Apache Hadoop 学习：hdfs shell 命令","date":"2019-10-30T08:27:45.000Z","path":"2019/10/30/apache-hadoop:study-hdfs-shell/","text":"Apache Hadoop 学习：hdfs shell 命令 ls1hdfs dfs -ls / put1hadoop fs -put localfile /user/hadoop/hadoopfile get1hadoop fs -get /user/hadoop/hadoopfile localfile","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"},{"name":"Hdfs","slug":"Hdfs","permalink":"https://yangyichao-mango.github.io/tags/Hdfs/"}]},{"title":"Mac安装Nginx-1.17.3以及相关配置文件","date":"2019-10-28T13:19:10.000Z","path":"2019/10/28/nginx:1-17-3-mac-install-and-confs-set/","text":"Mac安装Nginx-1.17.3以及相关配置文件 安装1brew install nginx 配置nginx是一个功能非常强大的web服务器加反向代理服务器，同时又是邮件服务器等等 在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器 这三个不同的功能的使用，都跟nginx的配置密切相关，nginx服务器的配置信息主要集中在nginx.conf这个配置文件中，并且所有的可配置选项大致分为以下几个部分 123456789101112131415161718192021222324252627282930313233343536main # 全局配置events &#123; # nginx工作模式配置&#125;http &#123; # http设置 .... server &#123; # 服务器主机配置 .... location &#123; # 路由配置 .... &#125; location path &#123; .... &#125; location otherpath &#123; .... &#125; &#125; server &#123; .... location &#123; .... &#125; &#125; upstream name &#123; # 负载均衡配置 .... &#125;&#125; 如上述配置文件所示，主要由6个部分组成： 1.main：用于进行nginx全局信息的配置2.events：用于nginx工作模式的配置3.http：用于进行http协议信息的一些配置4.server：用于进行服务器访问信息的配置5.location：用于进行访问路由的配置6.upstream：用于进行负载均衡的配置 main模块1234567# user nobody nobody;worker_processes 2;# error_log logs/error.log# error_log logs/error.log notice# error_log logs/error.log info# pid logs/nginx.pidworker_rlimit_nofile 1024; 上述配置都是存放在main全局配置模块中的配置项 1.user：用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行2.worker_processes：指定nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍3.error_log：定义错误日志文件的位置及输出级别【debug / info / notice / warn / error / crit】4.pid：用来指定进程id的存储文件的位置5.worker_rlimit_nofile：用于指定一个进程可以打开最多文件数量的描述 events模块12345events &#123; worker_connections 1024; multi_accept on; use epoll;&#125; 上述配置是针对nginx服务器的工作模式的一些操作配置 1.worker_connections：指定最大可以同时接收的连接数量，这里一定要注意，最大连接数量是和worker processes共同决定的2.multi_accept：配置指定nginx在收到一个新连接通知后尽可能多的接受更多的连接3.use epoll：配置指定了线程轮询的方法，如果是linux2.6+，使用epoll，如果是BSD如Mac请使用Kqueue http模块作为web服务器，http模块是nginx最核心的一个模块，配置项也是比较多的，项目中会设置到很多的实际业务场景，需要根据硬件信息进行适当的配置，常规情况下，使用默认配置即可！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354http &#123; ## # 基础配置 ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL证书配置 ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # 日志配置 ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip 压缩配置 ## gzip on; gzip_disable &quot;msie6&quot;; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # 虚拟主机配置 ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125; 基础配置1.sendfile on：配置on让sendfile发挥作用，将文件的回写过程交给数据缓冲去去完成，而不是放在应用中完成，这样的话在性能提升有有好处2.tc_nopush on：让nginx在一个数据包中发送所有的头文件，而不是一个一个单独发3.tcp_nodelay on：让nginx不要缓存数据，而是一段一段发送，如果数据的传输有实时性的要求的话可以配置它，发送完一小段数据就立刻能得到返回值，但是不要滥用哦 4.keepalive_timeout 10：给客户端分配连接超时时间，服务器会在这个时间过后关闭连接。一般设置时间较短，可以让nginx工作持续性更好5.client_header_timeout 10：设置请求头的超时时间6.client_body_timeout 10：设置请求体的超时时间7.send_timeout 10：指定客户端响应超时时间，如果客户端两次操作间隔超过这个时间，服务器就会关闭这个链接 8.limit_conn_zone $binary_remote_addr zone=addr:5m ：设置用于保存各种key的共享内存的参数，9.limit_conn addr 100: 给定的key设置最大连接数 10.server_tokens：虽然不会让nginx执行速度更快，但是可以在错误页面关闭nginx版本提示，对于网站安全性的提升有好处哦11.include /etc/nginx/mime.types：指定在当前文件中包含另一个文件的指令12.default_type application/octet-stream：指定默认处理的文件类型可以是二进制13.type_hash_max_size 2048：混淆数据，影响三列冲突率，值越大消耗内存越多，散列key冲突率会降低，检索速度更快；值越小key，占用内存较少，冲突率越高，检索速度变慢 日志1.access_log logs/access.log：设置存储访问记录的日志2.error_log logs/error.log：设置存储记录错误发生的日志 压缩配置1.gzip：是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量。2.gzip_disable：为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。3.gzip_static：告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。4.gzip_proxied：允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。5.gzip_min_length：设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。6.gzip_comp_level：设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。7.gzip_type：设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。 文件缓存配置1.open_file_cache：打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。2.open_file_cache_valid：在open_file_cache中指定检测正确信息的间隔时间。3.open_file_cache_min_uses：定义了open_file_cache中指令参数不活动时间期间里最小的文件数。4.open_file_cache_errors：指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。 server模块server模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息 12345678910server &#123; listen 80; server_name localhost 192.168.1.100; root /nginx/www; index index.php index.html index.html; charset utf-8; access_log logs/access.log; error_log logs/error.log; ......&#125; 核心配置信息如下： 1.server：一个虚拟主机的配置，一个http中可以配置多个server 2.server_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔 3.root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录 4.index：用户访问web网站时的全局首页 5.charset：用于设置www/路径中配置的网页的默认编码格式 6.access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径 7.error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径 location模块location模块是nginx配置中出现最多的一个配置，主要用于配置路由访问信息 在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location模块也是一个非常重要的配置模块 基本配置1234location / &#123; root /nginx/www; index index.php index.html index.htm;&#125; location /：表示匹配访问根目录 root：用于指定访问根目录时，访问虚拟主机的web目录 index：在不指定访问具体资源时，默认展示的资源文件列表 反向代理配置方式通过反向代理代理服务器访问模式，通过proxy_set配置让客户端访问透明化 12345location / &#123; proxy_pass http://localhost:8888; proxy_set_header X-real-ip $remote_addr; proxy_set_header Host $http_host;&#125; uwsgi配置wsgi模式下的服务器配置访问方式 1234location / &#123; include uwsgi_params; uwsgi_pass localhost:8888&#125; upstream模块upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器 简单的配置方式如下 12345678upstream name &#123; ip_hash; server 192.168.1.100:8000; server 192.168.1.100:8001 down; server 192.168.1.100:8002 max_fails=3; server 192.168.1.100:8003 fail_timeout=20s; server 192.168.1.100:8004 max_fails=3 fail_timeout=20s;&#125; 核心配置信息如下 1.ip_hash：指定请求调度算法，默认是weight权重轮询调度，可以指定 2.server host:port：分发服务器的列表配置 – down：表示该主机暂停服务 – max_fails：表示失败最大次数，超过失败最大次数暂停服务 – fail_timeout：表示如果请求受理失败，暂停指定的时间之后重新发起请求","tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://yangyichao-mango.github.io/tags/Nginx/"}]},{"title":"Elastic-Job学习：分布式任务调度框架","date":"2019-10-26T14:08:15.000Z","path":"2019/10/26/elastic-job:study-distributed-scheduled-job-framework/","text":"分布式任务调度框架学习 官方文档 elastic-job github","tags":[{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"},{"name":"分布式调度框架","slug":"分布式调度框架","permalink":"https://yangyichao-mango.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yangyichao-mango.github.io/tags/SpringBoot/"}]},{"title":"Vue学习：Vue前端项目部署到SpringBoot工程下","date":"2019-10-26T07:29:37.000Z","path":"2019/10/26/vue:study-vue-project-deploy-in-springboot-project/","text":"Vue项目部署到SpringBoot工程下 Vue前端项目1npm run build 运行上述命令，将前端Vue项目打包，命令运行完成之后会在项目根目录下生成一个生成一个dist文件夹, 编译好的静态文件就在这里面 部署在SpringBoot项目下将前端项目中dist文件夹下的所有文件拷贝到SpringBoot工程的src/main/resources/static文件夹下 运行后端项目，可以看到控制台会有这样的输出，证明将静态页面加入了容器中，现在就可以访问到前端页面了 12019-10-26 15:47:09.607 INFO 1967 --- [ main] o.s.b.a.w.s.WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yangyichao-mango.github.io/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"https://yangyichao-mango.github.io/tags/Vue/"}]},{"title":"Maven学习：使用maven-shade-plugin解决依赖包冲突","date":"2019-10-25T06:23:20.000Z","path":"2019/10/25/apache-maven:study-maven-shade-resolve-jar-conflicts/","text":"java 依赖包冲突，使用maven-shade-plugin解决 错误场景详情1java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor; 错误原因出现这样的错误详情一般是由于有下面这样的包依赖情况 12A - B - C(guava version 18) \\ D - C(guava version 23.6-jre) A：代表我们所开发的当前项目B和D：代表当前项目所依赖的项目C：代表当前项目依赖的项目所依赖的项目 由于我们当前所开发的项目A依赖了B和D，B和D又依赖了项目C我们打包运行项目时，maven只会将一个版本C(guava)打进包内（maven打包遇到相同依赖，最短路径优先，在路径相同时先在pom中声明优先）比如此时打进包的版本是C(guava version 23.6-jre)，那么很有可能在运行B中的一个方法时，调用C的一个方法，这个方法是C(guava version 18)中的一个方法，在C(guava version 23.6-jre)中并不存在，这时候就会报出java.lang.NoSuchMethodError 解决方案使用maven-shade-plugin将所有B项目依赖的包全部打进B.jar中，并且给guava包的路径重命名为我们的自定义路径\\ maven-shade-plugin基本功能maven-shade-plugin提供了两大基本功能： 1、将依赖的jar包打包到当前jar包（常规打包是不会将所依赖jar包打进来的）2、对依赖的jar包进行重命名（用于类的隔离，解决包冲突就是使用了这个功能） 解决示例如下例，就可以在B项目中使用C(guava version 18)，只不过import路径变成了我们自定的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;RpcModule&lt;/groupId&gt; &lt;artifactId&gt;RpcModule&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;RpcModule&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;guava.version&gt;18&lt;/guava.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;$&#123;guava.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;configuration&gt; &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;!-- 给guava包的路径重命名为我们的自定义路径 --&gt; &lt;configuration&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;com.google.guava&lt;/pattern&gt; &lt;shadedPattern&gt;shade.com.google.guava&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;relocation&gt; &lt;pattern&gt;org.joda&lt;/pattern&gt; &lt;shadedPattern&gt;shade.com.google.joda&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;relocation&gt; &lt;pattern&gt;com.google.common&lt;/pattern&gt; &lt;shadedPattern&gt;shade.com.google.common&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;/relocations&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;/&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 使用maven-shade-plugin之前 12345678910import Entity.Request;import Entity.Response;import java.io.*;import java.net.Socket;import com.google.common.collect.ImmutableMap;public class SocketClient &#123;&#125; 使用maven-shade-plugin之后编译后反编译结果 12345678910import Entity.Request;import Entity.Response;import java.io.*;import java.net.Socket;import shade.com.google.common.collect.ImmutableMap;public class SocketClient &#123;&#125; 最后将打好的包上传至我们的maven仓库，然后再在当前项目A中依赖，就没有依赖冲突了 12A - B - C(guava version 18, shade.com.google.common.collect.ImmutableMap) \\ D - C(guava version 23.6-jre, com.google.common.collect.ImmutableMap) 这样就可以做到将两个不同版本的包都引入使用，由于引入包路径不同，因此也没有冲突","tags":[{"name":"Apache Maven","slug":"Apache-Maven","permalink":"https://yangyichao-mango.github.io/tags/Apache-Maven/"}]},{"title":"Apache Zookeeper 学习：Zookeeper实现统一配置管理中心","date":"2019-10-24T10:40:24.000Z","path":"2019/10/24/apache-zookeeper:study-zookeeper-implement-unified-configuration-management-center/","text":"Apache Zookeeper 学习：模拟三台节点组成的Zookeeper集群实现的统一配置管理中心 模拟Zookeeper集群架构图 创建zookeeper集群节点模拟三台节点组成的zookeeper集群，需要在本机zookeeper目录下创建三个zookeeper集群节点配置文件 1234$ cd conf/$ cp zoo_sample.cfg zoo1.cfg$ cp zoo_sample.cfg zoo2.cfg$ cp zoo_sample.cfg zoo3.cfg 创建所配置的各个文件夹123456789$ mkdir /tmp/zookeeper1$ mkdir /tmp/zookeeper1/data$ mkdir /tmp/zookeeper1/dataLog$ mkdir /tmp/zookeeper2$ mkdir /tmp/zookeeper2/data$ mkdir /tmp/zookeeper2/dataLog$ mkdir /tmp/zookeeper3$ mkdir /tmp/zookeeper3/data$ mkdir /tmp/zookeeper3/dataLog /tmp/zookeeperX/data文件夹下创建myid文件123$ echo 1 &gt; /tmp/zookeeper1/data/myid$ echo 2 &gt; /tmp/zookeeper2/data/myid$ echo 3 &gt; /tmp/zookeeper3/data/myid 配置zookeeper节点信息zoo1.cfg 1234567891011121314151617181920212223242526272829303132333435# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper1/datadataLogDir=/tmp/zookeeper1/dataLog# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1# 格式:server.num=xxxx:port1:port2# num对应myid中的内容，port1是zookeeper集群中各服务间的通信端口，port2是zookeeper集群选举leader的端口server.1=localhost:2888:3888server.2=localhost:2899:3899server.3=localhost:2877:3877 zoo2.cfg 1234567891011# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper2/datadataLogDir=/tmp/zookeeper2/dataLog# the port at which the clients will connectclientPort=2182...server.1=localhost:2888:3888server.2=localhost:2899:3899server.3=localhost:2877:3877 zoo3.cfg 1234567891011# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/tmp/zookeeper3/datadataLogDir=/tmp/zookeeper3/dataLog# the port at which the clients will connectclientPort=2183...server.1=localhost:2888:3888server.2=localhost:2899:3899server.3=localhost:2877:3877 配置文件中dataDir，dataLogDir，clientPort，三个zookeeper节点配置信息都不同搭建zookeeper集群，需要在每个zookeeper安装目录下的data文件中创建名为myid的文件，修改zooX.cfg内容如下： 123server.1=xxx:2888:3888server.2=xxx:2899:3899server.3=xxx:2877:3877 格式:server.num=xxxx:port1:port2num对应myid中的内容，port1是zookeeper集群中各服务间的通信端口，port2是zookeeper集群选举leader的端口 启动模拟集群节点123456789101112$ ./zkServer.sh start ../conf/zoo1.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo1.cfgStarting zookeeper ... STARTED$ ./zkServer.sh start ../conf/zoo2.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo2.cfgStarting zookeeper ... STARTED$ ./zkServer.sh start ../conf/zoo3.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo3.cfgStarting zookeeper ... STARTED 查看集群状态 123456789101112$ ./zkServer.sh status ../conf/zoo1.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo1.cfgMode: follower$ ./zkServer.sh status ../conf/zoo2.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo2.cfgMode: leader$ ./zkServer.sh status ../conf/zoo3.cfgZooKeeper JMX enabled by defaultUsing config: ../conf/zoo3.cfgMode: follower 创建zookeeper集群client创建监听节点变化的server（zookeeper集群client）模拟监听节点变化server，启动两个BaseWatcher程序作为监听server（对zookeeper集群来说是client） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class BaseWatcher implements Watcher &#123; private static ZooKeeper zookeeper; /** * 超时时间 */ private static final int SESSION_TIME_OUT = 2000; private static CountDownLatch defaultCountDownLatch = new CountDownLatch(1); private static CountDownLatch childrenCountDownLatch = new CountDownLatch(1); private static CountDownLatch dataCountDownLatch = new CountDownLatch(1); @Override public void process(WatchedEvent event) &#123; if (event.getState() == KeeperState.SyncConnected) &#123; LOGGER.info(&quot;Watch received event&quot;); defaultCountDownLatch.countDown(); &#125; if (event.getType() == EventType.NodeCreated) &#123; LOGGER.info(&quot;创建节点&quot;); &#125; if (event.getType() == EventType.NodeDataChanged) &#123; LOGGER.info(&quot;节点改变&quot;); &#125; if (event.getType() == EventType.NodeChildrenChanged) &#123; LOGGER.info(&quot;子节点节点改变&quot;); &#125; if (event.getType() == EventType.NodeDeleted) &#123; LOGGER.info(&quot;节点删除&quot;); &#125; &#125; /** * 连接zookeeper * @param host * @throws Exception */ public static void connectZookeeper(String host, Watcher defaultWatcher) throws Exception &#123; zookeeper = new ZooKeeper(host, SESSION_TIME_OUT, defaultWatcher); defaultCountDownLatch.await(); LOGGER.info(&quot;zookeeper connection success&quot;); &#125; /** * 获取路径下所有子节点 * @param path * @return * @throws KeeperException * @throws InterruptedException */ public static List&lt;String&gt; getChildren(String path, Watcher childrenWatcher) throws KeeperException, InterruptedException &#123; return zookeeper.getChildren(path, childrenWatcher); &#125; /** * 获取节点上面的数据 * @param path 路径 * @return * @throws KeeperException * @throws InterruptedException */ public static String getData(String path, Watcher dataWatcher) throws KeeperException, InterruptedException &#123; byte[] data = zookeeper.getData(path, dataWatcher, null); if (data == null) &#123; return &quot;&quot;; &#125; return new String(data); &#125; /** * 关闭连接 * @throws InterruptedException */ public static void closeConnection() throws InterruptedException &#123; if (zookeeper != null) &#123; zookeeper.close(); &#125; &#125; private static final String HOST = &quot;localhost:2181,localhost:2182,localhost:2183&quot;; private static final Logger LOGGER = LoggerFactory.getLogger(BaseWatcher.class); public static void main(String[] args) throws Exception &#123; /** * 运行程序之前需要启动zookeeper服务端，&#123;@link BaseWatcher.HOST&#125; 根据zookeeper服务端具体配置去修改 * * 除了默认watcher外其他watcher一旦触发就会失效，需要充新注册，本示例中因为 * 还未想到比较好的重新注册watcher方式(考虑到如果在Watcher中持有一个zk客户端的 * 实例可能存在循环引用的问题)，因此暂不实现watcher失效后重新注册watcher的问题， * 后续可以查阅curator重新注册watcher的实现方法。 */ BaseWatcher defaultWatcher = new BaseWatcher(); // 连接zookeeper并设置一个默认的watcher监听zookeeper文件节点的变化 connectZookeeper(HOST, defaultWatcher); TimeUnit.SECONDS.sleep(1000000); &#125;&#125; 创建改变节点数据的server（zookeeper集群client）如果一个节点向被监听节点中写数据，其他节点就会接受到zookeeper的 NodeDataChanged event 模拟改变数据server，启动一个BaseWatcher程序作为改变数据server（对zookeeper集群来说是client） 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; /** * 运行程序之前需要启动zookeeper服务端，&#123;@link BaseWatcher.HOST&#125; 根据zookeeper服务端具体配置去修改 * * 除了默认watcher外其他watcher一旦触发就会失效，需要充新注册，本示例中因为 * 还未想到比较好的重新注册watcher方式(考虑到如果在Watcher中持有一个zk客户端的 * 实例可能存在循环引用的问题)，因此暂不实现watcher失效后重新注册watcher的问题， * 后续可以查阅curator重新注册watcher的实现方法。 */ BaseWatcher defaultWatcher = new BaseWatcher(); // 连接zookeeper并设置一个默认的watcher监听zookeeper文件节点的变化 connectZookeeper(HOST, defaultWatcher); // 向/GetChildren节点写数据之前需要先创建此文件夹 // 向/GetChildren节点写数据，则监听程序就会收到zookeeper的 [NodeDataChanged] event setData(&quot;/GetChildren&quot;, &quot;8&quot;); TimeUnit.SECONDS.sleep(1000000);&#125; 运行结果两个监听程序收到zookeeper的 NodeDataChanged event，log如下 123411:24:27.295 [main-SendThread(localhost:2183)] DEBUG org.apache.zookeeper.ClientCnxn - Got notification sessionid:0x300001251b5000311:24:27.297 [main-SendThread(localhost:2183)] DEBUG org.apache.zookeeper.ClientCnxn - Got WatchedEvent state:SyncConnected type:NodeDataChanged path:/GetChildren for sessionid 0x300001251b5000311:24:27.297 [main-EventThread] INFO com.github.xxx.bigdata.demo.zookeeper.BaseWatcher - Watch received event11:24:27.297 [main-EventThread] INFO com.github.xxx.bigdata.demo.zookeeper.BaseWatcher - 节点改变","tags":[{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"Apache Druid 学习：组件以及查询类型","date":"2019-10-22T02:40:12.000Z","path":"2019/10/22/apache-druid:study-components-and-query-types/","text":"Apache Druid 学习：组件以及查询类型 OLAP基本概念维度(Dimension): 指的是观察数据的一个角度，是考虑问题的一类属性，这些属性的集合统称为一个维。维的级别(Level): 对数据的观察还存在细节程度的不同，在druid中一般表示为时间的粒度(granularity)，比如一秒，一分钟，一小时，一天…… 度量(Measure): 度量是用来聚合分析计算的数字信息，在druid中称为”metrics”，它可以是存储在数据库中，也可以是通过策略计算得出的。比如一篇文章的点击数、或者是根据评论数、点击数、转发数计算出的热点值 对于数据处理向下钻取(Drill-down)/上卷(Roll-up): 改变维的层次和级别，变换分析的粒度。Roll-up在于提升维的级别（或者称粒度）或者减少维度来聚合数据，展现总览，Drill-down反之，降低维的级别(或者称粒度)或增加维度来查看细节切片(slice)和切块(dice): 当维度为两个时，我们对获取数据(查询)的操作称之为切片，当维度的数量大于两个时，我们称之为切块旋转(Pivoting): 变换维的方向，例如表格中的行列互换 查询条件参数 字段名 描述 是否必须 queryType 查询类型，对应聚合查询下的类型值：timeseries、topN、groupBy等 是 dataSource 数据源，类似关系数据库中表的概念，对应数据导入时Json配置属性dataSource值 是 descending 返回结果是否逆序，默认值为否（正序） 否 intervals 查询时间区间 是 filter 对Dimension进行过滤，可以根据情况对几个维度组合不同的filter类型(and、or、not、bound)，还可以根据需要定义javascript function进行过滤 否 aggregations 指定度量在聚合时候的计算策略，例如相加、或者求平均值、又或者取最后一个值，在内置类型不满足的情况下可以使用javascript。比如某手游中我统计了我每一局击杀小怪数量，以及野怪的数量，通过聚合策略sum，我能知道我从开号以来击杀了多少小怪和野怪。 否 postAggregations 后聚合策略，提供了多个度量组合生成新度量的能力，主要有利于聚合计算的抽象，避免对一些指标的重复计算。举个例子，假如我需要一个度量，是我击杀小怪和野怪的总和，那么，我只需要在后聚合阶段计算，只需要拿小怪和野怪的数量相加一次，大大地提高了计算效率。 否 granularity 查询的时间粒度，最细粒度为秒，最大粒度为all，提供了时间维度级别的调整并对数据进行上卷和向下钻取的能力 是 dimensionSpec 提供了维度在聚合前输出展示值定制的能力，比如在Dimension age一列中，拿到的是字符串类型的数字，我希望转成数字类型，又或者定制一个javascript function，统一以 ${age} year old的形式展现 否 limit 返回结果数量限制 否 context 表示对当前查询本身的一些配置，比如设置查询超时的时间，又比如是否使用缓存，在通用的配置基础上，每种查询类型还有特定的配置，详见文档 否 基本组件filter过滤器，在查询语句中是一个json对象，用来对维度进行筛选，表示满足filter的是我们需要的数据。类似于SQL中的where。 类型 功能 SelectorFilter 功能类似于SQL中的where key=value AndFilter, OrFilter, NotFilter 功能类似于SQL中and、or、not三种过滤器。支持递归嵌套，可以构造出丰富的逻辑表达式 RegexFilter 正则表达式，支持任意维度值的java正则 SearchFilter 通过字符串匹配维度，支持多种表达式 InFilter 功能类似于SQL中where key in (value1, value2) IntervalFilter 针对于时间维度过滤 BoundFilter 功能类似于SQL中的大于、小于、等于三种算子 JavaScriptFilter 上述filter均不能满足可以自己写JavaScript来过滤维度 aggregator聚合可以在采集数据时规格部分的一种方式，汇总数据进入Druid之前提供。聚合也可以被指定为在查询时多查询的部分，聚合类型如下： 类型 功能 CountAggregator SQL count(key) SumAggregator SQL sum(key) MaxAggregator, MinAggregator SQL max(key), min(key) DistinctCountAggregator SQL count(distinct key) JavaScriptAggregator 上述aggregator均不能满足可以自己写JavaScript来定义计算 post-aggregator 类型 功能 ArithmeticPostAggregator 支持对聚合后指标进行”+ - * / quotient”计算 FieldAccessPostAggregator 直接获取聚合的字段（维度，指标） ConstantPostAggregator 返回常数 JavaScriptPostAggregator 上述postAggregator均不能满足可以自己写JavaScript来定义计算 查询类型聚合查询timeseries时序查询，实际上即是对数据基于时间点(timestamp)的一次上卷。适合用来看某几个度量在一个时间段内的趋势。排序可按时间降序或升序 字段名 描述 是否必须 queryType 查询类型，必须为 “timeseries” 是 dataSource 数据源，比如 “wikipedia” 是 descending 返回结果是否逆序，默认值为否（正序） 否 intervals 查询时间区间 是 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 aggregations 否 postAggregations 否 limit 否 context 否 context： 1.grandTotal 2.零填充如果时间范围内没有值，则会填充0时间序列查询通常用零填充空的内部时间段。例如，如果您对间隔2012-01-01 / 2012-01-04发出“天”粒度时间序列查询，而2012-01-02没有数据存在，您将收到： 1234567891011121314[ &#123; &quot;timestamp&quot;: &quot;2012-01-01T00:00:00.000Z&quot;, &quot;result&quot;: &#123; &quot;sample_name1&quot;: &lt;some_value&gt; &#125; &#125;, &#123; &quot;timestamp&quot;: &quot;2012-01-02T00:00:00.000Z&quot;, &quot;result&quot;: &#123; &quot;sample_name1&quot;: 0 &#125; &#125;, &#123; &quot;timestamp&quot;: &quot;2012-01-03T00:00:00.000Z&quot;, &quot;result&quot;: &#123; &quot;sample_name1&quot;: &lt;some_value&gt; &#125; &#125;] topN在时间点的基础上，又增加了一个维度(OLAP的概念算两个维度)，进而对源数据进行切片，切片之后分别上卷，最后返回一个聚合集，你可以指定某个指标作为排序的依据。官方文档称这对比单个druid dimension 的groupBy 更高效。适合看某个维度下的时间趋势，（比如美国和中国十年内GDP的增长趋势比对，在这里除了时间外国家就是另外一个维度） 字段名 描述 是否必须 queryType 查询类型，必须为 “topN” 是 dataSource 数据源，比如 “wikipedia” 是 intervals 查询时间区间 是 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 aggregations 否 postAggregations 否 dimension 除了时间之外聚合的维度，只能定义一个维度 是 threshold topN中的N，例如：希望查询到top2，则值为2 是 metric topN中用来排序的指标 是 context 否 groupBy适用于两个维度以上的查询，druid会根据维度切块，并且分别上卷，最后返回聚合集。相对于topN而言，这是一个向下钻取的操作，每多一个维度意味着保留更多的细节。(比如增加一个行业的维度，就可以知道美国和中国十年内，每一年不同行业贡献GDP的占比)注意：如果要使用时间作为唯一分组进行聚合，或者在单个维度上使用有序groupBy进行聚合，请优先考虑使用Timeseries和TopN查询。在某些情况下，它们的性能可能会更好。有关更多详细信息，请参见下面的替代方法。 字段名 描述 是否必须 queryType 查询类型，必须为 “groupBy” 是 dataSource 数据源，比如 “wikipedia” 是 dimensions 需要聚合的所有维度 是 limitSpec 同关系型数据库中的limit 否 having 同关系型数据库中的having 否 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 aggregations 否 postAggregations 否 intervals 查询时间区间 是 subtotalsSpec 类似于的grouping sets 否 context 否 普通查询select类似SQL中的select操作，select用来查看Druid中存储的数据，并支持按照指定过滤器和时间查看指定维度和指标。不支持aggregations和post aggregations 注意：建议您尽可能使用scan查询类型而不是select。在涉及大量segment的情况下，select查询可能具有很高的内存和性能开销，但是scan查询没有此问题。两者之间的主要区别是“扫描”查询不支持分页。但是，即使没有分页，scan查询类型也能够返回几乎无限数量的结果，使得分页在许多情况下是不必要的。 字段名 描述 是否必须 queryType 查询类型，必须为 “select” 是 dataSource 数据源，比如 “wikipedia” 是 intervals 查询时间区间 是 descending 返回结果是否逆序，默认值为否（正序） 否 filter 否 dimensions 需要查询的维度列表 否 metrics 需要查询的指标列表 否 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块，默认是Granularity.ALL 否 pagingSpec 分页 是 context 否 scan扫描查询以流模式返回行，Select查询和Scan查询之间的最大区别是，Scan查询子返回给客户端数据之前不会将所有行数据保留在内存中而select查询将把行保留在内存中，如果返回太多行，则会导致内存压力。扫描查询可以返回所有行，而无需发出另一个分页查询。 除了将scan查询发送给server的用法外，还可以直接向historical历史记录进程或streaming ingestion流式提取任务发出扫描查询。如果要并行检索大量数据，这将很有用。 字段名 描述 是否必须 queryType 查询类型，必须为 “scan” 是 dataSource 数据源，比如 “wikipedia” 是 intervals 查询时间区间 是 resultFormat 返回结果类型：list，compactedList或valueVector。目前仅list和compactedList受支持。默认是list 否 filter 否 columns 需要scan的维度和指标，默认为所有 否 batchSize 返回数据之前默认缓存最多多少行 否 limit 查询返回最大的数据条目，如果不指定，则返回所有的数据 否 order 返回数据的order，基于timestamp，并且只有__time被包含在columns中才生效 否 legacy 否 context 否 search类似SQL中的Like操作，但是支持更多的匹配操作 字段名 描述 是否必须 queryType 查询类型，必须为 “search” 是 dataSource 数据源，比如 “wikipedia” 是 granularity 聚合粒度，粒度决定如何在跨时间维度得到数据块 是 filter 否 limit 每个历史进程的最大查询返回数据条目（默认是1000） 否 intervals 查询时间区间 是 searchDimensions 需要search的维度（默认是所有维度），key like value中的key 否 query search维度需要匹配的value，key like value中的value 是 sort 指定应如何对搜索结果进行排序，包括字典编排（默认排序），字母数字，strlen和数字排序 否 context 否 元数据查询time boundingsegment metadatadataSource metadata","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"}]},{"title":"Apache Druid 学习：kafka to druid","date":"2019-10-21T07:08:45.000Z","path":"2019/10/21/apache-druid:study-kafka-to-druid/","text":"Apache Druid 学习：kafka to druid demo Druid Web操作官网教程 Java Demo","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"},{"name":"Apache Kafka","slug":"Apache-Kafka","permalink":"https://yangyichao-mango.github.io/tags/Apache-Kafka/"}]},{"title":"Mac安装Apache Druid-0.16.0-incubating","date":"2019-10-21T06:21:53.000Z","path":"2019/10/21/apache-druid:0.16.0-incubating-mac-install/","text":"Mac安装Apache Druid-0.16.0-incubating教程 安装参考官网教程 brew安装1brew install druid quer 下载安装123$ curl https://www-us.apache.org/dist/incubator/druid/0.16.0-incubating/apache-druid-0.16.0-incubating-bin.tar.gz$ tar -xzf apache-druid-0.16.0-incubating-bin.tar.gz$ cd apache-druid-0.16.0-incubating 配置启动启动druid服务之前需要先启动zookeeper，下面有两种方式启动和使用zookeeper 使用集成zookeeper1234$ cd $DRUID_HOME // 需要在~/.bash_profile中进行配置$ curl https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz -o zookeeper-3.4.14.tar.gz$ tar -xzf zookeeper-3.4.14.tar.gz$ mv zookeeper-3.4.14 zk 使用外部zookeeper修改 $DRUID_HOME/conf/supervise/single-server/micro-quickstart.conf 中的配置将 !p10 zk bin/run-zk conf 注释掉 123456789101112131415$ vi $DRUID_HOME/conf/supervise/single-server/micro-quickstart.conf:verify bin/verify-java:verify bin/verify-default-ports:kill-timeout 10# !p10 zk bin/run-zk conf // 这里是运行集成zookeeper的代码，所以要注释掉coordinator-overlord bin/run-druid coordinator-overlord conf/druid/single-server/micro-quickstartbroker bin/run-druid broker conf/druid/single-server/micro-quickstartrouter bin/run-druid router conf/druid/single-server/micro-quickstarthistorical bin/run-druid historical conf/druid/single-server/micro-quickstart!p90 middleManager bin/run-druid middleManager conf/druid/single-server/micro-quickstart# Uncomment to use Tranquility Server#!p95 tranquility-server tranquility/bin/tranquility server -configFile conf/tranquility/wikipedia-server.json -Ddruid.extensions.loadList=[] 修改 $DRUID_HOME/conf/druid/single-server/micro-quickstart/_common/common.runtime.properties 中的配置修改zookeeper的client配置 1234567$ vim $DRUID_HOME/conf/druid/single-server/micro-quickstart/_common/common.runtime.properties# 配置外部zookeeper的信息# zookeeper，大概在46~55行中间，对zk进行配置# zookeeper的server运行在2181端口上druid.zk.service.host=127.0.0.1:2181druid.zk.paths.base=/druid 修改 $DRUID_HOME/bin/verify-default-ports 中的配置因为使用了外部zookeeper，并且外部zookeeper的ip:port为127.0.0.1:2181所以需要将zookeeper的2181端口删除，否则会校验本机2181端口是否被占用，因为本机zookeeper已经将其占用，则会报错，服务不能启动如果使用的zookeeper的不在本机部署，则可以不注释2181 12345$ vi $DRUID_HOME/bin/verify-default-ports# my @ports = (1527, 2181, 8081, 8082, 8083, 8090, 8091, 8200, 9095);my @ports = (1527, 8081, 8082, 8083, 8090, 8091, 8200, 9095); 启动服务1$ ./bin/start-micro-quickstart 可以到http://localhost:8888查看是否启动成功","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"},{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"Apache Flink 学习：hbase作为sink","date":"2019-10-20T06:27:49.000Z","path":"2019/10/20/apache-flink:study-hbase-sink/","text":"Apache Flink 学习：hbase作为sink的demo 依赖项1234567891011&lt;properties&gt; &lt;hbase.version&gt;2.0.5&lt;/hbase.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;$&#123;hbase.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; demo代码使用了hbase作为source，hbase作为sink 运行之前需要运行hadoop集群（zookeeper集群），hbase集群flink根据部署的集群信息（比如zookeeper的ip:port为127.0.0.1:2181等的信息）去连接hbase hbase-site.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Autogenerated by Cloudera Manager--&gt;&lt;configuration&gt; &lt;!-- zk configuration --&gt; &lt;property&gt; &lt;name&gt;zookeeper.session.timeout&lt;/name&gt; &lt;value&gt;60000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;zookeeper.znode.parent&lt;/name&gt; &lt;value&gt;/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;127.0.0.1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt; &lt;value&gt;2181&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; HBaseReaderHBase作为source 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class HBaseReader extends RichSourceFunction&lt;String&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(HBaseReader.class); private transient HBaseClient hBaseClient; private static final String DEFAULT_HBASE_SOURCE_TABLE_NAME = &quot;student&quot;; private static final String DEFAULT_HBASE_SOURCE_START_ROW = &quot;row1&quot;; private static final String DEFAULT_HBASE_SOURCE_STOP_ROW = &quot;row1&quot;; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; hBaseClient = new HBaseClient(); hBaseClient.initialize(); &#125; &#125; &#125; &#125; @Override public void run(SourceContext&lt;String&gt; ctx) throws Exception &#123; List&lt;byte[]&gt; results = hBaseClient.scan( DEFAULT_HBASE_SOURCE_TABLE_NAME , DEFAULT_HBASE_SOURCE_START_ROW , DEFAULT_HBASE_SOURCE_STOP_ROW); results.forEach(result -&gt; ctx.collect(new String(result))); &#125; @Override public void cancel() &#123; if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; try &#123; hBaseClient.destroy(); &#125; catch (IOException e) &#123; LOGGER.error(&quot;&quot;, e); &#125; &#125; &#125; &#125; &#125;&#125; HBaseWriterHBase作为sink 12345678910111213141516171819202122232425262728293031323334353637383940414243public static class HBaseWriter extends RichSinkFunction&lt;Tuple2&lt;String, Integer&gt;&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(HBaseWriter.class); private transient HBaseClient hBaseClient; @Override public void open(Configuration parameters) throws Exception &#123; super.open(parameters); if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; hBaseClient = new HBaseClient(); hBaseClient.initialize(); &#125; &#125; &#125; &#125; @Override public void invoke(Tuple2&lt;String, Integer&gt; value, Context context) throws IOException &#123; String result = value.toString(); Put put = hBaseClient.createPut(&quot;row2&quot;); hBaseClient.addValueOnPut(put, &quot;description&quot;, &quot;age&quot;, &quot;19&quot;); hBaseClient.put(&quot;student&quot;, put); &#125; @Override public void close() throws Exception &#123; super.close(); if (Objects.isNull(hBaseClient)) &#123; synchronized (this) &#123; if (Objects.isNull(hBaseClient)) &#123; try &#123; hBaseClient.destroy(); &#125; catch (IOException e) &#123; LOGGER.error(&quot;&quot;, e); &#125; &#125; &#125; &#125; &#125;&#125; 定义dag12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; final SourceFunction&lt;String&gt; source; final ParameterTool params = ParameterTool.fromArgs(args); /******************************* hbase source *******************************/ source = new HBaseReader(); /******************************* define dag *******************************/ // create the environment to create streams and configure execution final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // make parameters available in the web interface env.getConfig().setGlobalJobParameters(params); DataStream&lt;String&gt; sentenceStream = env.addSource(source); DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCountStream = sentenceStream .flatMap(new LineSplitter()) .keyBy(0) .sum(1); /******************************* hbase sink *******************************/ wordCountStream.addSink(new HBaseWriter()); wordCountStream.print(); env.execute(&quot;Java hbase Word Count&quot;);&#125; 查看hbase文件12345678910hbase(main):001:0&gt; scan &#x27;student&#x27;ROW COLUMN+CELL row1 column=description:age, timestamp=1571460125600, value=18 row1 column=description:name, timestamp=1571460129987, value=li u # 记录以及被写入hbase row2 column=description:age, timestamp=1571576517072, value=192 row(s) in 0.2010 secondshbase(main):002:0&gt; 发现columnFamilyName为description，columnName为age，rowkey为row2，value为19的记录已经被写入hbase","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"},{"name":"Apache HBase","slug":"Apache-HBase","permalink":"https://yangyichao-mango.github.io/tags/Apache-HBase/"}]},{"title":"Mac安装Apache Zookeeper-3.4.12","date":"2019-10-20T03:23:17.000Z","path":"2019/10/20/apache-zookeeper:3.4.12-mac-install/","text":"Mac安装Apache Zookeeper-3.4.12教程 安装安装方式1-brew安装1$ brew install zookeeper 安装方式2-下载压缩包从此地址下载http://mirrors.hust.edu.cn/apache/zookeeper/stable/ 解压配置文件 1234$ tar -zxvf zookeeper-3.4.12.tar.gz // 解压$ cd zookeeper-3.4.12/conf // 切换到配置目录下$ mv zoo_sample.cfg zoo.cfg // 更改默认配置文件名称$ vi zoo.cfg // 编辑配置文件，自定义dataDir 启动启动sever端切换到bin目录 1234567891011$ pwd/user/local/Celler/zookeeper/3.4.12/bin$ lsREADME.txt zkCli.cmd zkEnv.cmd zkServer.cmd zookeeper.outzkCleanup.sh zkCli.sh zkEnv.sh zkServer.sh$ ./zkServer.sh startZooKeeper JMX enabled by defaultUsing config: /user/local/Celler/zookeeper/3.4.12/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 启动client端12345678910111213141516171819./zkCli.sh -server 127.0.0.1:2181Connecting to 127.0.0.1:21812019-10-20 12:17:25,861 [myid:] - INFO [main:Environment@100] - Client environment:zookeeper.version=3.4.12-e5259e437540f349646870ea94dc2658c4e44b3b, built on 03/27/2018 03:55 GMT2019-10-20 12:17:25,864 [myid:] - INFO [main:Environment@100] - Client environment:host.name=localhost2019-10-20 12:17:25,864 [myid:] - INFO [main:Environment@100] - Client environment:java.version=1.8.0_1912019-10-20 12:17:25,866 [myid:] - INFO [main:Environment@100] - Client environment:java.vendor=Oracle Corporation2019-10-20 12:17:25,866 [myid:] - INFO [main:Environment@100] - Client environment:java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre2019-10-20 12:17:25,868 [myid:] - INFO [main:ZooKeeper@441] - Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@799f7e29Welcome to ZooKeeper!2019-10-20 12:17:25,896 [myid:] - INFO [main-SendThread(127.0.0.1:2181):ClientCnxn$SendThread@1028] - Opening socket connection to server 127.0.0.1/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)JLine support is enabled2019-10-20 12:17:25,959 [myid:] - INFO [main-SendThread(127.0.0.1:2181):ClientCnxn$SendThread@878] - Socket connection established to 127.0.0.1/127.0.0.1:2181, initiating session2019-10-20 12:17:25,966 [myid:] - INFO [main-SendThread(127.0.0.1:2181):ClientCnxn$SendThread@1302] - Session establishment complete on server 127.0.0.1/127.0.0.1:2181, sessionid = 0x10000112e160008, negotiated timeout = 30000WATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: 127.0.0.1:2181(CONNECTED) 0] ls /[zookeeper, hbase] 停止server端1234&gt; ./zkServer.sh stop //停止后，如果CLi没有关闭，将报错ZooKeeper JMX enabled by defaultUsing config: zookeeper-3.4.12/bin/../conf/zoo.cfgStopping zookeeper ... STOPPED 配置文件123456789101112131415161718192021222324252627282930# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes. # 内存数据快照的保存目录；如果没有自定义Log也使用该目录dataDir=/tmp/zookeeper# the port at which the clients will connect# zookeeper服务端的端口，客户端启动时需要连接的端口clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1","tags":[{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]},{"title":"Apache Flink 学习：hdfs作为sink","date":"2019-10-19T11:33:38.000Z","path":"2019/10/19/apache-flink:study-hdfs-sink/","text":"Apache Flink 学习：hdfs作为source和sink的demo 依赖项1234567891011&lt;properties&gt; &lt;flink.version&gt;1.9.0&lt;/flink.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-filesystem_2.12&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt; demo代码使用了kafka作为source，hdfs作为sink运行之前需要运行kafka集群，hadoop集群（zookeeper集群） 123456789101112131415161718192021222324/******************************* define dag *******************************/// create the environment to create streams and configure executionfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();// make parameters available in the web interfaceenv.getConfig().setGlobalJobParameters(params);DataStream&lt;String&gt; sentenceStream = env.addSource(source);DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; wordCountStream = sentenceStream .flatMap(new LineSplitter()) .keyBy(0) .sum(1);wordCountStream.print();DataStream&lt;String&gt; kafkaSinkStream = wordCountStream .map(new WordBuilder());/******************************* hdfs sink *******************************/BucketingSink&lt;String&gt; bucketingSink = new BucketingSink&lt;&gt;(&quot;/user/xxx/flink/from-kafka&quot;); //hdfs上的路径bucketingSink.setWriter(new StringWriter&lt;&gt;()) .setBatchSize(1024 * 1024L) .setBatchRolloverInterval(2000) .setInactiveBucketThreshold(1000);kafkaSinkStream.addSink(bucketingSink); 上面例子将创建一个 Sink，写入遵循下面格式的分桶文件中： 1/base/path/&#123;date-time&#125;/_part-&#123;parallel-task&#125;-&#123;count&#125; date-time：是从setBucketer()自定义的日期/时间格式的字符串，如果不进行设置，默认Bucketer是DateTimeBucketer，默认值是yyyy-MM-dd–HH（DateTimeBucketer.DEFAULT_FORMAT_STRING） _part-{parallel-task}-{count}： 1234567891011121314151617private static final String DEFAULT_VALID_PREFIX = &quot;_&quot;;private static final String DEFAULT_PART_PREFIX = &quot;part&quot;;private static final String DEFAULT_PENDING_SUFFIX = &quot;.pending&quot;;private void openNewPartFile(Path bucketPath, BucketState&lt;T&gt; bucketState) throws Exception &#123; Path partPath = assemblePartPath(bucketPath, subtaskIndex, bucketState.partCounter); Path inProgressPath = getInProgressPathFor(partPath);&#125;private Path assemblePartPath(Path bucket, int subtaskIndex, int partIndex) &#123; String localPartSuffix = partSuffix != null ? partSuffix : &quot;&quot;; return new Path(bucket, String.format(&quot;%s-%s-%s%s&quot;, partPrefix, subtaskIndex, partIndex, localPartSuffix));&#125;private Path getInProgressPathFor(Path path) &#123; return new Path(path.getParent(), inProgressPrefix + path.getName()).suffix(inProgressSuffix);&#125; 查看hdfs文件1234567891011$ ./hdfs dfs -ls /user/xxx/flink/from-kafka/2019-10-19--192019-10-19 20:08:31,244 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 15 items-rw-r--r-- 1 xxx supergroup 4 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-0-0.pending-rw-r--r-- 1 xxx supergroup 2 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-1-0.pending-rw-r--r-- 1 xxx supergroup 5 2019-10-19 19:44 /user/xxx/flink/from-kafka/2019-10-19--19/_part-2-0.pending-rw-r--r-- 1 xxx supergroup 11 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-2-1.pending-rw-r--r-- 1 xxx supergroup 10 2019-10-19 19:44 /user/xxx/flink/from-kafka/2019-10-19--19/_part-3-0.pending-rw-r--r-- 1 xxx supergroup 13 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-3-1.pending-rw-r--r-- 1 xxx supergroup 9 2019-10-19 19:45 /user/xxx/flink/from-kafka/2019-10-19--19/_part-4-0.pending-rw-r--r-- 1 xxx supergroup 10 2019-10-19 19:44 /user/xxx/flink/from-kafka/2019-10-19--19/_part-5-0.pending","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"},{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"}]},{"title":"Mac安装Apache HBase-1.3.5","date":"2019-10-18T15:14:59.000Z","path":"2019/10/18/apache-hbase:1.3.5-mac-install/","text":"Mac安装Apache HBase-1.3.5教程 HBase安装1$ brew install hbase 安装在/usr/local/Cellar/hbase/1.3.5 HBase配置hbase-env.sh在conf/hbase-env.sh设置JAVA_HOME 1234$ cd /usr/local/Cellar/hbase/1.3.5/libexec/conf$ vim hbase-env.shexport JAVA_HOME=&quot;$(/usr/libexec/java_home --version 1.8)&quot; Apache HBase-1.3.5中JAVA_HOME已经默认被配置好了如果JAVA_HOME没有配置好，则需要设置JAVA_HOME，可以通过下面的命令查看JAVA_HOME 12$ /usr/libexec/java_home/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home hbase-site.xml在conf/hbase-site.xml设置HBase的核心配置 1234567891011121314$ vim hbase-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; // 这里设置让HBase存储文件的地方 &lt;value&gt;file:///usr/local/Cellar/hbase/tmp/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; // 这里设置让HBase存储内建zookeeper文件的地方 &lt;value&gt;/usr/local/Cellar/hbase/tmp/zookeeper&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动HBase/usr/local/Cellar/hbase/1.3.5/bin/start-hbase.sh提供HBase的启动 12$ ./start-hbase.shstarting master, logging to /usr/local/var/log/hbase/hbase-xxx-master-xxx.local.out 验证是否安装成功12345$ jps722 Launcher1142 HMaster726 Launcher1256 Jps 启动HBase Shell1234567$ ./hbase shell2019-10-19 11:58:34,879 WARN [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableHBase Shell; enter &#x27;help&lt;RETURN&gt;&#x27; for list of supported commands.Type &quot;exit&lt;RETURN&gt;&quot; to leave the HBase ShellVersion 1.3.5, rb59afe7b1dc650ff3a86034477b563734e8799a9, Wed Jun 5 15:57:14 PDT 2019hbase(main):001:0&gt; 停止HBase运行12$ ./stop-hbase.shstopping hbase............... 伪分布式模式必须先关闭HBase 修改hbase-env.sh1HBASE_MANAGE_ZK = true 修改hbase-site.xml设置HBase使用分布式模式运行 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; // Here you have to set the path where you want HBase to store its files. &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hbase.rootdir路径一定要跟hadoop中core-site.xml中fs.default.name相同 change the hbase.rootdir from the local filesystem to the address of your HDFS instance —offical quick start 如何两处设置不同会引起ERROR: Can’t get master address from ZooKeeper; znode data == null错误错误 在启动HBase之前, 请先启动Hadoop, 使之运行 123456789101112131415161718$ ./start-hbase.shlocalhost: starting zookeeper, logging to /usr/local/var/log/hbase/hbase-xxx-zookeeper-xxx.local.outstarting master, logging to /usr/local/var/log/hbase/hbase-xxx-master-xxx.local.outstarting regionserver, logging to /usr/local/var/log/hbase/hbase-xxx-1-regionserver-xxx.local.out$ jps #验证是否启动成功, 包含HMaster和HRegionServer说明启动成功5614 HRegionServer2222 NameNode722 Launcher2323 DataNode5461 HMaster726 Launcher2650 ResourceManager2747 NodeManager2459 SecondaryNameNode5405 HQuorumPeer2855726 Jps 查看hdfs中文件夹 123456$ ./hdfs dfs -ls /2019-10-19 12:39:03,895 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 3 itemsdrwxr-xr-x - xxx supergroup 0 2019-10-19 12:38 /hbasedrwxrwxr-x - xxx supergroup 0 2019-10-17 14:41 /tmpdrwxr-xr-x - xxx supergroup 0 2019-10-17 11:44 /user HBase Shell123456789101112131415161718192021222324252627$ hbase shell #启动HBase Shell# 创建表&gt; create &#x27;student&#x27;, &#x27;description&#x27;, &#x27;course&#x27; #创建表名为student的表, 指明两个列名, 分别为description和course# 信息明细&gt; list &#x27;student&#x27; #列出list表信息# 插入数据# 意思为在student表row1处插入description:age的数据为18# rowKey为row1，columnFamilyName为description，columnName为age&gt; put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;description:age&#x27;, &#x27;18&#x27;&gt; put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;description:name&#x27;, &#x27;liu&#x27;&gt; put &#x27;student&#x27;, &#x27;row1&#x27;, &#x27;course:chinese&#x27;, &#x27;100&#x27;# 一次扫描所有数据&gt; scan &#x27;student&#x27;# 使表失效 / 有效&gt; disable &#x27;student&#x27;&gt; enable &#x27;student&#x27;# 删除表(要先disable)&gt; drop &#x27;student&#x27;# 退出shell&gt; quit","tags":[{"name":"Apache HBase","slug":"Apache-HBase","permalink":"https://yangyichao-mango.github.io/tags/Apache-HBase/"},{"name":"Mac安装","slug":"Mac安装","permalink":"https://yangyichao-mango.github.io/tags/Mac%E5%AE%89%E8%A3%85/"}]},{"title":"IntelliJ IDEA 中如何查看一个类的所有继承关系","date":"2019-10-18T06:09:17.000Z","path":"2019/10/18/idea-mac:show-class-hierarchy/","text":"IntelliJ IDEA 中如何查看一个类的所有继承关系，包括父类与子类 查看方式IntelliJ IDEA 中最上端的Navigate，下拉选择Type Hierarchy，就会出现层级关系列表 关于该类的父类和子类继承关系 关于该类的父类继承关系 关于该类的子类继承关系","tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://yangyichao-mango.github.io/tags/IntelliJ-IDEA/"}]},{"title":"Apache Hive环境搭建错误：java.lang.IllegalArgumentException: java.net.URISyntaxException:...","date":"2019-10-17T07:44:01.000Z","path":"2019/10/17/apache-hive:error-URISyntaxException:Relative-path-in-absolute-URI:{system:java.io.tmpdir}{system-user-name}/","text":"出现错误：Exception in thread “main” java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D 错误场景详情1234567891011121314151617181920212223$ $HIVE_HOME/bin/hiveHive Session ID = 41e2ad09-81b3-4700-9b87-f42b25a29731Logging initialized using configuration in jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/hive-common-3.1.2.jar!/hive-log4j2.properties Async: trueException in thread &quot;main&quot; java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D at org.apache.hadoop.fs.Path.initialize(Path.java:263) at org.apache.hadoop.fs.Path.&lt;init&gt;(Path.java:221) at org.apache.hadoop.hive.ql.session.SessionState.createSessionDirs(SessionState.java:710) at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:627) at org.apache.hadoop.hive.ql.session.SessionState.beginStart(SessionState.java:591) at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:747) at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:683) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:323) at org.apache.hadoop.util.RunJar.main(RunJar.java:236)Caused by: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D at java.net.URI.checkPath(URI.java:1823) at java.net.URI.&lt;init&gt;(URI.java:745) at org.apache.hadoop.fs.Path.initialize(Path.java:260) ... 12 more 错误原因hive-site.xml里的临时目录没有设置好，一共有三个 1234567891011121314151617&lt;property&gt; &lt;name&gt;Hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;$&#123;system:Java.io.tmpdir&#125;/$&#123;system:user.name&#125;&lt;/value&gt; &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;$&#123;system:Java.io.tmpdir&#125;/$&#123;system:user.name&#125;/operation_logs&lt;/value&gt; &lt;description&gt;Top level directory where operation logs are stored if logging functionality is enabled&lt;/description&gt;&lt;/property&gt; 解决方案将hive-site.xml文件中的${system:java.io.tmpdir}替换为hive的临时目录例如我替换为/usr/local/Cellar/hive/tmp，该目录如果不存在则要自己手工创建，并且赋予读写权限 1234567891011121314151617&lt;property&gt; &lt;name&gt;Hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hive/tmp&lt;/value&gt; &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hive/tmp/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hive/tmp/root/operation_logs&lt;/value&gt; &lt;description&gt;Top level directory where operation logs are stored if logging functionality is enabled&lt;/description&gt;&lt;/property&gt;","tags":[{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Mac安装Apache Hive-3.2.1","date":"2019-10-17T06:58:34.000Z","path":"2019/10/17/apache-hive:3.1.2-mac-install/","text":"Mac安装Apache Hive-3.2.1教程 安装Hadoop下载包进行安装，则hadoop需要独立安装 安装Hivebrew安装1$ brew install hive 此命令会把hive依赖的hadoop安装，所以就不需要单独进行安装hadoop该命令默认安装的版本较新，我的hive是3.1.2，hadoop是3.2.1，安装位置：/usr/local/Cellar/hive/ 环境变量修改12345$ vim ~/.bash_profileexport HIVE_HOME=/usr/local/Cellar/hive/3.1.2export PATH=&quot;$HIVE_HOME/bin:$PATH&quot;$ source ~/.bash_profile 使用mysql作为hive元数据存储在mysql中为hive 创建用户，及初始化数据库以下在mysql 中操作，注意：这里创建的用户名是 hadoop， 密码 mysql第一行：创建数据库第二、三行 创建用户，赋予权限第四行 权限生效 1234create database hive;CREATE USER &#x27;hadoop&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mysql&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;hadoop&#x27;@&#x27;%&#x27; WITH GRANT OPTION;flush privileges; 查看权限是否已经存储 1SELECT * FROM mysql.user; 修改配置文件hive-site.xml修改hive配置文件，我的配置文件位置在 /usr/local/Cellar/hive/3.1.2/libexec/conf如果不存在hive-site.xml文件，则使用下面这个命令创建一个默认的hive-site.xml 1$ cp hive-default.xml.template hive-site.xml 修改配置文件 123456789101112131415161718&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;mysql&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;mysql &lt;value&gt;jdbc:mysql://localhost:3306/hive&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; javax.jdo.option.ConnectionUserName – 连接mysql的账号，hadoopjavax.jdo.option.ConnectionPassword – 连接mysql的密码，mysqljavax.jdo.option.ConnectionURL – 对应上一步创建的数据库，localhost:3306/hive hadoop中创建hive所需仓库1234$ $HADOOP_HOME/bin/hadoop fs -mkdir /tmp$ $HADOOP_HOME/bin/hadoop fs -mkdir -p /user/hive/warehouse$ $HADOOP_HOME/bin/hadoop fs -chmod g+w /tmp$ $HADOOP_HOME/bin/hadoop fs -chmod g+w /user/hive/warehouse $HADOOP_HOME – 代表您的hadoop工作目录 hive初始化mysql中的数据库hive命令1$ $HIVE_HOME/bin/schematool -dbType msyql -initSchema 可能出现错误1：java.lang.NoSuchMethodError: com.google.common…解决方案：java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument 可能出现错误2：java.lang.ClassNotFoundException: com.mysql…解决方案：java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 启动Hive的Metastore Server服务进程1$ $HIVE_HOME/bin/hive --service metastore &amp; 登录hive客户端命令1$ $HIVE_HOME/bin/ hive 可能出现的错误1：java.lang.IllegalArgumentException: java.net.URISyntaxException:…解决方案：Exception in thread “main” java.lang.IllegalArgumentException: java.net.URISyntaxException:","tags":[{"name":"Mac安装","slug":"Mac安装","permalink":"https://yangyichao-mango.github.io/tags/Mac%E5%AE%89%E8%A3%85/"},{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Apache Hive环境搭建错误：com.mysql.jdbc.Driver was not found in the CLASSPATH","date":"2019-10-17T06:35:11.000Z","path":"2019/10/17/apache-hive:error-ClassNotFoundException:com.mysql.jdbc.driver/","text":"Apache Hive环境搭建错误：com.mysql.jdbc.Driver was not found in the CLASSPATH 错误场景详情12345678910111213$ $HIVE_HOME/bin/schematool -dbType mysql -initSchemaSLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Metastore connection URL: jdbc:mysql://localhost:3306/hive?characterEncoding=UTF-8Metastore Connection Driver : com.mysql.jdbc.DriverMetastore connection User: hadooporg.apache.hadoop.hive.metastore.HiveMetaException: Failed to load driverUnderlying cause: java.lang.ClassNotFoundException : com.mysql.jdbc.DriverUse --verbose for detailed stacktrace.*** schemaTool failed *** 错误原因在配置hive-site.xml文件时配置了mysql驱动，而hive/lib目录下没有mysql驱动包。 解决方案官网下载mysql驱动下载地址 (https://dev.mysql.com/downloads/connector/j/)把下载好的压缩包（mysql-connector-java-8.0.18.zip）进行解压unzip mysql-connector-java-8.0.18.zip复制到hive/lib下cp mysql-connector-java-8.0.18/mysql-connector-java-8.0.18.jar hive/lib","tags":[{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Apache Hive环境搭建错误：java.lang.NoSuchMethodError: com.google.common...","date":"2019-10-17T06:14:27.000Z","path":"2019/10/17/apache-hive:error-NoSuchMethodError:com.google.common.base.Preconditions.checkArgument/","text":"Apache Hive环境搭建错误：java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument 错误场景详情12345678910111213141516171819202122$ $HIVE_HOME/bin/schematool -dbType mysql -initSchemaSLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338) at org.apache.hadoop.mapred.JobConf.setJar(JobConf.java:536) at org.apache.hadoop.mapred.JobConf.setJarByClass(JobConf.java:554) at org.apache.hadoop.mapred.JobConf.&lt;init&gt;(JobConf.java:448) at org.apache.hadoop.hive.conf.HiveConf.initialize(HiveConf.java:5141) at org.apache.hadoop.hive.conf.HiveConf.&lt;init&gt;(HiveConf.java:5104) at org.apache.hive.beeline.HiveSchemaTool.&lt;init&gt;(HiveSchemaTool.java:96) at org.apache.hive.beeline.HiveSchemaTool.main(HiveSchemaTool.java:1473) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:323) at org.apache.hadoop.util.RunJar.main(RunJar.java:236) 错误原因这是因为hive内依赖的guava.jar和hadoop内的版本不一致造成的。 解决方案查看hadoop安装目录下share/hadoop/common/lib内guava.jar版本查看hive安装目录下lib内guava.jar的版本，如果两者不一致，删除版本低的，并拷贝高版本的，问题解决！","tags":[{"name":"Apache Hive","slug":"Apache-Hive","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hive/"}]},{"title":"Apache Hadoop错误：Unable to load native-hadoop library for your platform","date":"2019-10-17T03:34:57.000Z","path":"2019/10/17/apache-hadoop:error-unable-to-load-native-hadoop-library-from-you-platform/","text":"Apache Hadoop错误：Unable to load native-hadoop library for your platform 错误场景详情12$ hadoop fs -ls /WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 错误原因Hadoop是使用Java语言开发的,但是有一些需求和操作并不适合使用java所以会引入了本地库（Native Libraries）的概念，通过本地库，Hadoop可以更加高效地执行某一些操作.当我们在linux 输入 hdoop fs -ls / 去查看 hdfs 文件系统上的资源时会出现下面错误 解决方案解决方案1在Hadoop的配置文件core-site.xml中可以设置是否使用本地库：（Hadoop默认的配置为启用本地库） 12345&lt;property&gt; &lt;name&gt;hadoop.native.lib&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;description&gt;Should native hadoop libraries, if present, be used.&lt;/description&gt;&lt;/property&gt; 解决方案2有博客说可以直接下载编译好的位包，替换原来的native包由于在我本地安装的Apache Hadoop 3.2.1版本中没有找到lib文件夹，所以在3.2.1版本中暂时不能使用此种方法 执行查看文件命令 1234$ hadoop fs -ls /2019-10-17 11:33:09,369 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 1 itemsdrwxr-xr-x - xxx supergroup 0 2019-10-17 11:23 /tmp","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"}]},{"title":"Mac安装Apache Hadoop-3.2.1","date":"2019-10-17T02:12:31.000Z","path":"2019/10/17/apache-hadoop:3.2.1-mac-install/","text":"Mac安装Apache hadoop-3.2.1教程 Java环境配置安装Java，查看Java版本以测试是否安装成功1234$ java -versionjava version &quot;1.8.0_191&quot;Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 查看Java安装位置信息，之后配置Hadoop运行环境需要使用12$ /usr/libexec/java_home/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home ssh配置配置ssh12$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys$ chmod 0600 ~/.ssh/authorized_keys 创建ssh公钥如果没有ssh公钥，执行以下命令创建 1$ ssh-keygen -t rsa 开启远程登录 测试远程登录是否开启1$ ssh localhost 安装hadoopbrew安装hadoopbrew安装的一般都是最新的hadoop，我这里是hadoop 3.2.1 如果需要安装其他版本的hadoop，通过brew安装指定版本的软件进行安装 123456$ brew install hadoopUpdating Homebrew...==&gt; Downloading https://www.apache.org/dyn/closer.cgi?path=hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz==&gt; Downloading from http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz######################################################################## 100.0%🍺 /usr/local/Cellar/hadoop/3.2.1: 21,686 files, 774.1MB, built in 10 minutes 1 second 注意上面的下载信息中 默认brew是会从apache官方的镜像中下载 1==&gt; Downloading https://www.apache.org/dyn/closer.cgi?path=hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz 如果下载很慢，可以配置国内镜像进行下载(清华大学开源软件镜像站) 1==&gt; Downloading from http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz 安装完之后查看hadoop安装位置 1234567891011121314151617$ brew info hadoophadoop: stable 3.2.1Framework for distributed processing of large data setshttps://hadoop.apache.org/Conflicts with: yarn (because both install `yarn` binaries)/usr/local/Cellar/hadoop/hdfs (20 files, 1MB) Built from source/usr/local/Cellar/hadoop/3.2.1 (22,408 files, 815.8MB) Built from source on 2019-10-17 at 09:46:37From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/hadoop.rb==&gt; RequirementsRequired: java &gt;= 1.8 ✔==&gt; Analyticsinstall: 4,572 (30 days), 10,774 (90 days), 44,762 (365 days)install_on_request: 3,822 (30 days), 9,128 (90 days), 38,206 (365 days)build_error: 0 (30 days) 配置hadoop需要修改的配置文件都在/usr/local/Cellar/hadoop/3.2.1/libexec/etc/hadoop这个目录下 hadoop-env.sh配置 export JAVA_HOME 将/usr/libexec/java_home查到的 Java 路径配置进去，记得去掉注释 #。 1export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home core-site.xml修改core-site.xml 文件参数,配置NameNode的主机名和端口号 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hadoop/hdfs/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml变量dfs.replication指定了每个HDFS数据库的复制次数。 通常为3, 由于我们只有一台主机和一个伪分布式模式的DataNode，将此值修改为1 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 格式化格式化hdfs操作只要第一次才使用，否则会造成数据全部丢失 1$ hdfs namenode -format 启动服务启动服务 1$ ./start-all.sh 启动成功后，可以在http://localhost:9870/http://localhost:8088/cluster进行查看 关闭服务 1$ ./stop-all.sh","tags":[{"name":"Apache Hadoop","slug":"Apache-Hadoop","permalink":"https://yangyichao-mango.github.io/tags/Apache-Hadoop/"},{"name":"Mac安装","slug":"Mac安装","permalink":"https://yangyichao-mango.github.io/tags/Mac%E5%AE%89%E8%A3%85/"}]},{"title":"useful-api-for-java","date":"2019-10-16T02:16:10.000Z","path":"2019/10/16/java-api:useful-api/","text":"API Retrofit（http请求工具包） Resilience4j（接口重试，限流，熔断器工具）","tags":[{"name":"Java Api","slug":"Java-Api","permalink":"https://yangyichao-mango.github.io/tags/Java-Api/"}]},{"title":"Apache Flink 零基础入门（四）：DataStream API 编程 学习心得","date":"2019-10-15T07:57:16.000Z","path":"2019/10/15/apache-flink:study-4-datastream-api/","text":"学习心得 DataStreamRichParallelSourceFunction用户通过实现SourceFunction自定义DataSource 如果设置了并行度，则会产生指定并行度个数的DataSource消费客户端去消费DataSource 1StreamExecutionEnvironment.setParallelism(int) 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class GroupedProcessingTimeWindow &#123; private static final Logger LOGGER = LoggerFactory.getLogger(GroupedProcessingTimeWindow.class); private static class DataSource extends RichParallelSourceFunction&lt;Tuple2&lt;String, Integer&gt;&gt; &#123; private volatile boolean isRunning = true; @Override public void run(SourceContext&lt;Tuple2&lt;String, Integer&gt;&gt; ctx) throws Exception &#123; Random random = new Random(); while (isRunning) &#123; TimeUnit.MILLISECONDS.sleep((getRuntimeContext().getIndexOfThisSubtask() + 1) * 1000 * 5); String key = &quot;类别&quot; + (char) (&#x27;A&#x27; + random.nextInt(3)); int value = random.nextInt(10) + 1; LOGGER.info(&quot;Thread: &#123;&#125;, key: &#123;&#125;, value: &#123;&#125;, dataSource object: &#123;&#125;)&quot; , Thread.currentThread().getName() , key , value , this); ctx.collect(new Tuple2&lt;&gt;(key, value)); &#125; &#125; @Override public void cancel() &#123; isRunning = false; &#125; &#125; public static void main(String[] args) throws Exception &#123; StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(2); DataSource dataSource = new DataSource(); LOGGER.info(&quot;dataSource object: &#123;&#125;&quot;, dataSource); DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; ds = env.addSource(dataSource); KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = ds.keyBy(0); // KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = ds.keyBy(&quot;f0&quot;); 通过指定字段名 f0 keyedStream .sum(1) // .sum(&quot;f1&quot;) 通过制定字段名 f1 .keyBy((KeySelector&lt;Tuple2&lt;String, Integer&gt;, Object&gt;) stringIntegerTuple2 -&gt; StringUtils.EMPTY) .fold(new HashMap&lt;String, Integer&gt;(), new FoldFunction&lt;Tuple2&lt;String, Integer&gt;, HashMap&lt;String, Integer&gt;&gt;() &#123; @Override public HashMap&lt;String, Integer&gt; fold(HashMap&lt;String, Integer&gt; accumulator, Tuple2&lt;String, Integer&gt; value) throws Exception &#123; accumulator.put(value.f0, value.f1); return accumulator; &#125; &#125;) .addSink(new SinkFunction&lt;HashMap&lt;String, Integer&gt;&gt;() &#123; @Override public void invoke(HashMap&lt;String, Integer&gt; value, Context context) throws Exception &#123; // 每个类型的商品成交量 LOGGER.info(&quot;&#123;&#125;&quot; , value); // 商品成交总量 LOGGER.info(&quot;&#123;&#125;&quot; , value.values().stream().mapToInt(v -&gt; v).sum()); &#125; &#125;); env.execute(); &#125;&#125; 通过查看dataSource object:的log就会发现上面这个例子中国产生了3个DataSource实例。 EvictorCountEvictor：保持窗口内元素数量符合用户指定数量，如果多于用户指定的数量，从窗口缓冲区的开头丢弃剩余的元素。DeltaEvictor：使用 DeltaFunction和 一个阈值，计算窗口缓冲区中的最后一个元素与其余每个元素之间的 delta 值，并删除 delta 值大于或等于阈值的元素。TimeEvictor：以毫秒为单位的时间间隔作为参数，对于给定的窗口，找到元素中的最大的时间戳max_ts，并删除时间戳小于max_ts - interval的所有元素。 keyedStreamKeyedStream.fold(R initialValue, FoldFunction&lt;T, R&gt; folder)添加一个合并key分组的算子，FoldFunction会接收到同一key的value，只有key相同的值才会被分发到同一个folder。 可能出现的问题Apache Flink: Return type of function could not be determined automatically due to type erasure错误场景：在用户定义DAG图算子的时候，可能会出现不支持lambda表达式的情况 原因：为了执行程序，Flink需要知道要处理的值的类型，因为它需要序列化和反序列化数据。Flink的类型系统基于描述数据类型的TypeInformation进行序列化和反序列化，会将Java中的基本类型以及Object类型与TypeInformation进行映射。当您指定一个函数时，Flink会尝试推断该函数的返回类型。但是某些Lambda函数由于类型擦除而丢失了此信息（可以自己编译后再对编译成的.class文件进行反编译，然后查看函数签名，发现函数签名具体类型被擦除），因此Flink无法通过此自动推断类型。Flink Java Lambda表达式 因此，必须显式声明返回类型。 解决方案1：用户自己定义返回类型 1234567DataStream&lt;String&gt; wordDataStream = dataStream.flatMap( (String sentence, Collector&lt;String&gt; out) -&gt; &#123; for(String word: sentence.split(&quot;\\\\W+&quot;)) &#123; out.collect(word); // collect objects of type String &#125; &#125;).returns(Types.STRING); 解决方案2：显示声明返回类型 12345678910111213141516DataStream&lt;String&gt; wordDataStream = dataStream.flatMap( new FlatMapFunction&lt;String, String&gt;() &#123; @Override public void flatMap(String sentence, Collector&lt;String&gt; out) &#123; // normalize and split the line String[] words = sentence.toLowerCase().split(&quot;\\\\W+&quot;); // emit the pairs for (String word : words) &#123; if (word.length() &gt; 0) &#123; out.collect(word); &#125; &#125; &#125; &#125;)","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"Hello World","date":"2019-10-14T12:54:25.000Z","path":"2019/10/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"生产实践 | 基于 Flink 的视频直播核心指标监控","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/apache-flink:learning-files/","text":"Flink 学习资料 Flink 系列官网文档还是最准确的。直接上视频和资料，懒癌患者直接拿走即可~ 视频b站链接，很多大厂的实战，讲解很详细，很适合初学者。 资料 链接：https://pan.baidu.com/s/1GzVJYpUxkucLS9ZikZWuRw、提取码：64n4 其他视频链接可点击公众号 [call me] 联系博主私聊获取 文档1.Flink 官网文档、Flink 官网中文文档 2.《Stream Processing with Apache Flink》 这本由 Flink PMC 写的 Flink 书籍也是很适合初学者，并且中文版已经出版了 ：《基于 Apache Flink 的流处理》，由 Flink committer 崔星灿大佬翻译 3.ververica 中文网和 Flink 钉钉群直播教程 4.微信公众号(由Flink 中文社区维护)：Flink 中文社区 以及 Flink 5.Flink 知识图谱以及社区专刊 6.加入 Apache Flink China社区 钉钉群（群号：23138101），很多大佬活跃 7.订阅 Flink user、user-zh 邮件列表，可在官网查看订阅方式，邮件列表中有很多解决方案，也有大佬们活跃解答 8.Flink 视频系列 github地址 oreilly 流模型介绍 Streaming 101: The world beyond batch Streaming 102: The world beyond batch Flink 源码 github gitee 书籍社刊书籍《Stream Processing with Apache Flink》 《基于 Apache Flink 的流处理》 社刊源自 ververica，社刊链接，总共分为 4 期，可以直接在 ververica 官网下载。 系列博客1.云邪原理系列 2.金竹漫谈系列 3.杨华的源码 4.Apache Flink 零基础入门系列 5.zhisheng 6.彻底明白Flink系统学习系列 7.kangqi 8.flink菜鸟","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"实时开发需求确认模板","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/apache-flink:realtime-demand-template/","text":"实时开发需求确认模板 实时指标整个链路开发过程中的一些经验。 需求评估分析实时指标是否符合该需求场景，以及在该场景中实时指标能够发挥的价值。 1.实时指标所能提供的分析能力实时计算的输出内容，以及提供的分析能力：OLAP 分析，key-value 实时数据服务，维度填充，数据打标等。 2.产出维度，指标的合理性从需求出发，评估实时指标产出的维度和指标的合理性。 3.需求可配置变量 评估维度 评估指标 监控数据范围 监控数据范围动态配置改变？ 监控数据起止时间 监控数据的起止时间动态配置改变？ 监控数据的某些配置变量 当变量发生变动时，可能会对产出的实时数据有什么影响，对计算链路有什么影响，会决定实时计算链路的实现方式。 4.面向用户范围评估 SLA 等服务质量等级保障，以及提供的实时数据服务的可用性等级，并且提前和业务方确认可用性和出现故障时的恢复时间等问题。 评估维度 评估指标 时间语义 事件时间、处理时间？事件时间：可以通过获取数据的时间戳，使用处理时间来真实反映和还原事件，但是可能会出现数据条数过小窗口不能触发，或者在一些有截止日期的活动结束的最后一个窗口不能触发的问题；处理时间：处理时间一般和事件时间差距很小，经验值一般 diff 小于 1%，只能反映流式框架处理数据时的时间戳，但是不会出现上述事件时间的两个问题。因此需要评估需求的逻辑精确度是否要求很高？ 数据一致性 至少一次、精确一次？至少一次：受限于目前的上下游以及依赖中间件的能力，比如 010 版本及以下的 Kafka 不支持两阶段提交，所以只能达到至少一次的语义；精确一次：整条实时计算链路中的所有组件都需要支持精确一次的语义（从技术层面或者业务逻辑层面达到精确一次）。评估需求逻辑是否可接受任务发生失败时有重复数据产生？ SLA 要求 评估需求的 SLA 要求，整条实时计算链路的 SLA 要求，产出数据最多延迟多长时间？数据准确率几个9？提供的接口服务是否需要考虑跨集群、机房备份、双写；是否需要建立多条计算链路以供故障切换？一旦发生故障，下游消费方能容忍的最大故障时长？下游消费方在发生故障时的兜底策略？ 可行性评估1.技术可行性 评估维度 评估指标 QPS 确定 QPS 以评估实时上下游以及依赖组件的选型以及能力。 数据输入 首先确定数据输入是否能够计算实时指标，然后评估上游提供的数据在计算实时指标时整个实时计算链路的逻辑以及复杂度。比如：是否需要用到双流 join，需要评估双流 join 所存在的误差是否在可接受范围内，一般可通过离线误差对比或经验值给出结论。常见输入中间件：消息队列，接口等，常用中间件：Kafka，rpc，http。 数据依赖 调研目前可用的哪些中间件可以提供能力来支持当前指标计算？举例：key-value等，常用依赖中间件：Redis。 数据输出 确定输出下游消费方的消费需求以及能力，以评估实时产出的数据以及存储组件是否能够满足其需求？常见输出中间件：消息队列，OLAP，key-value，接口等，常用中间件：Kafka，Druid，Redis，rpc。产出维度，一般场景下，维度值不建议是大数量级别的数据，比如说使用 user_id，device_id。 2.成本可行性 评估维度 评估指标 QPS 确定 QPS 以评估实时上下游以及依赖中间件的资源消耗。确定资源消耗是否在可接受范围之内？ 数据输入 确定整个实时计算链路的逻辑以及复杂度，来评估可能的资源消耗。 数据依赖 确定整个实时计算链路的逻辑以及复杂度，来评估可能的资源消耗。 数据输出 由输出内容以及存储组件来评估下游存储中间件的资源消耗。举例：维度值不建议是大数量级别的数据，比如说使用 user_id，device_id 作为维度或者产出明细数据，虽然使用 OLAP 在维度聚合场景下很灵活，但是这些场景下使用 OLAP 可能会造成很大的资源消耗。 综合以上技术和成本可行性以及需求收益等指标，以评估实时指标的 ROI。 3.数据输入消息队列日志最常见的实时数据源就是消息队列日志，首先我们需要确定日志类型，不同的日志类型决定了指标或者维度字段是否可以产出以及其准确性，一般情况下有以下三种类型日志： 日志类型 备注 埋点日志 维度最全，数据准确 web server log 维度次全，数据准确度一般 binlog 数据库真实数据，反映的是真实数据，数据最准确，维度信息一般很少 接口这里的接口一般是用来根据需求圈定一批需要进行监控的数据内容。接口的提供方式可以是http，配置中心配置，rpc接口等。 4.数据依赖实时一般情况下都会或多或少依赖到外部组件，最常见的就是 key-value 存储。场景：很常见的一类需求就是对数据源中的数据进行打标然后产出，这里的标签数据就会存储在 key-value 中间件中。需要评估访问外存的 QPS，以及外存提供的能力。 5.数据输出 输出组件 备注 消息队列 常见中间件：kafka等 key-value存储 常见中间件：Redis，HBase，服务化接口等 OLAP 常见中间件：Druid，ClickHouse等 技术方案评估","tags":[{"name":"Apache Flink","slug":"Apache-Flink","permalink":"https://yangyichao-mango.github.io/tags/Apache-Flink/"}]},{"title":"","date":"2019-09-01T06:21:53.000Z","path":"2019/09/01/wechat-blog/broadcast/","text":"实时新增类指标标准化处理方案 实时指标整个链路开发过程中的一些经验。 实时新增类指标大体上可以将实时新增类指标以以下两种维度进行分类。 identity id 类型维度 identity id 类型 备注 number(long) 类型 identity id 数值类型 identity id 的好处在于可以使用 Bitmap 类组件做到精确去重。 字符类型 identity id 字符类型 identity id 去重相对复杂，有两种方式，在误差允许范围之内使用 BloomFilter 进行去重，或者使用 key-value 组件进行精确去重。 产出数据类型维度 产出数据类型 备注 明细类数据 此类数据一般是要求将新增的数据明细产出，uv 的含义是做过滤，产出的明细数据中的 identity id 不会有重复。输出明细数据的好处在于，我们可以在下游使用 OLAP 引擎对明细数据进行各种维度的聚合计算，从而很方便的产出不同维度下的 uv 数据。 聚合类数据 将一个时间窗口内的 uv 进行聚合，并且可以计算出分维度的 uv，其产出数据一般都是[维度 + uv_count]，但是这里的维度一般情况下是都是固定维度。如果需要拓展则需要改动源码。 计算链路因此新增产出的链路多数就是以上两种维度因子的相互组合。 number(long) 类型 identity id 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public interface RoaringBitmapDuplicateable&lt;Model&gt; &#123; long DEFAULT_DUPLICATE_MILLS = 24 * 3600 * 1000L; BiPredicate&lt;Long, Long&gt; ROARING_BIT_MAP_CLEAR_BI_PREDICATE = (start, end) -&gt; end - start &gt;= DEFAULT_DUPLICATE_MILLS; // 初始化 default ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; getBitMapValueState(String name) &#123; return this.getRuntimeContext().getState( new ValueStateDescriptor&lt;&gt;(name, TypeInformation.of( new TypeHint&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt;() &#123; &#125;)) ); &#125; RuntimeContext getRuntimeContext(); long getLongId(Model model); Optional&lt;Logger&gt; getLogger(); default BiPredicate&lt;Long, Long&gt; roaringBitMapClearBiPredicate() &#123; return ROARING_BIT_MAP_CLEAR_BI_PREDICATE; &#125; default List&lt;Model&gt; duplicateAndGet(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Date, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Date, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Map&lt;Long, Model&gt; idModelsMap = models .stream() .collect(Collectors.toMap(this::getLongId, Function.identity(), (oldOne, newOne) -&gt; oldOne)); Set&lt;Long&gt; ids = idModelsMap.keySet(); List&lt;Model&gt; newModels = Lists.newArrayList(); for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; if (idModelsMap.containsKey(id)) &#123; newModels.add(idModelsMap.get(id)); &#125; &#125; &#125; newModels.stream() .map(this::getLongId) .forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return newModels; &#125; default long duplicateAndCount(List&lt;Model&gt; models, long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitMap = checkAndGetState(windowStartTimestamp, bitMapValueState); Set&lt;Long&gt; ids = models .stream() .map(this::getLongId) .collect(Collectors.toSet()); List&lt;Long&gt; newIds = Lists.newArrayList(); int count = 0; for (Long id : ids) &#123; if (!bitMap.f1.contains(id)) &#123; newIds.add(id); count++; &#125; &#125; newIds.forEach(bitMap.f1::add); bitMapValueState.update(bitMap); return count; &#125; default Tuple2&lt;Long, Roaring64NavigableMap&gt; checkAndGetState(long windowStartTimestamp , ValueState&lt;Tuple2&lt;Long, Roaring64NavigableMap&gt;&gt; bitMapValueState) throws IOException &#123; Tuple2&lt;Long, Roaring64NavigableMap&gt; bitmap = bitMapValueState.value(); if (null == bitmap) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;New RoaringBitMapValueState Timestamp=&#123;&#125;&quot;, windowStartTimestamp)); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else if (this.roaringBitMapClearBiPredicate().test(bitmap.f0, windowStartTimestamp)) &#123; this.getLogger().ifPresent(logger -&gt; logger.info(&quot;Clear RoaringBitMapValueState, from start=&#123;&#125; to end=&#123;&#125;&quot;, bitmap.f0, windowStartTimestamp)); bitMapValueState.clear(); bitmap.f1.clear(); Tuple2&lt;Long, Roaring64NavigableMap&gt; newBitMap = Tuple2.of(windowStartTimestamp, new Roaring64NavigableMap()); bitMapValueState.update(newBitMap); return newBitMap; &#125; else &#123; return bitmap; &#125; &#125;&#125; 字符类型 identity id使用 Flink state 使用 key-value 外存 如果选用的是 Redis 作为 key-value 过滤，那么这里会有一个巧用 Redis bit 特性的优化。举一个一般场景下的方案与使用 Redis bit 特性的方案做对比： 场景：假如需要同一天有几十场活动，并且都希望计算出这几十场活动的 uv，那么我们就可以按照下图设计 Redis bit 结构。 通常方案： 这种场景下，如果有 1 亿用户，需要同时计算 50 个活动或者 50 个不同维度下的 uv。那么理论上最大 key 数量为 1 亿 * 50 = 50 亿个 key。 Redis bit 方案： 这样做的一个优点，就是这几十场活动的 uv 计算都使用了相同的 Redis key 来计算，可以大幅度减少 Redis 的容量占用。使用此方案的话，以上述相同的用户和活动场数，理论上最大key 数量仅仅为 1 亿，只是 value 数量会多占几十个 bit。","tags":[{"name":"Apache Druid","slug":"Apache-Druid","permalink":"https://yangyichao-mango.github.io/tags/Apache-Druid/"},{"name":"Apache Zookeeper","slug":"Apache-Zookeeper","permalink":"https://yangyichao-mango.github.io/tags/Apache-Zookeeper/"}]}]